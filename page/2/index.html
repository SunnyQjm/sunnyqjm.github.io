<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2">















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'ANPOHDJJYB',
      apiKey: '',
      indexName: 'Ming.J blog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"搜索文章","hits_empty":"没有找到任何结果呦T_T: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="建明 | Ming.J">
<meta property="og:url" content="http://qjm253.cn/page/2/index.html">
<meta property="og:site_name" content="建明 | Ming.J">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="建明 | Ming.J">





  
  
  <link rel="canonical" href="http://qjm253.cn/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>建明 | Ming.J – 至清  至静</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">建明 | Ming.J</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">至清  至静</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-首页">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-关于">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-分类">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/SunnyQjm" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2018/05/23/c++01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/23/c++01/" class="post-title-link" itemprop="url">C++ unsigned int 和 int 混用的问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-23 18:00:00" itemprop="dateCreated datePublished" datetime="2018-05-23T18:00:00+08:00">2018-05-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-20 10:55:18" itemprop="dateModified" datetime="2019-04-20T10:55:18+08:00">2019-04-20</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>且看下面一段诡异的代码</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span>(a &lt; <span class="number">-6</span>)&#123;           <span class="comment">//下面的输出语句会执行</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned 5 &lt; -6"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行上面的代码，会输出 “unsigned 5 &lt; -6”</li>
<li>这看起来一点都不科学 _(:з」∠)_</li>
</ul>
<blockquote>
<h2 id="敲黑板，讲重点"><a href="#敲黑板，讲重点" class="headerlink" title="敲黑板，讲重点"></a>敲黑板，讲重点</h2><p><strong>！！！在c++里面，如果一个表达式里面同时有 unsigned int 和 int ，执行的时候会尝试把 int 转成 unsigned int。</strong></p>
<ul>
<li>这个时候如果int的值是非负的，执行的结果当然和预期一样</li>
<li>但是如果int的值是负数，它的值就变成 <strong>int的最大值</strong> + <strong>原值</strong> =&gt; 其实是C++类型转换的锅，如果是int转unsigned，就会用int的最大值对原值取模</li>
</ul>
</blockquote>
<ul>
<li><h3 id="验证一下-int-转-unsigned-int-的时候编译器怎么处理的"><a href="#验证一下-int-转-unsigned-int-的时候编译器怎么处理的" class="headerlink" title="验证一下 int 转 unsigned int 的时候编译器怎么处理的"></a>验证一下 int 转 unsigned int 的时候编译器怎么处理的</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>执行上面的代码输出为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4294967295</span> <span class="number">4294967294</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其中 2<sup>32</sup> - 1 = 4294967295</p>
</li>
</ul>
</li>
<li><h3 id="举几个栗子加深理解"><a href="#举几个栗子加深理解" class="headerlink" title="举几个栗子加深理解"></a>举几个栗子加深理解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Example 1</span></span><br><span class="line">  u_int a = <span class="number">-5</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span>(a + b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"(unsigned)-5 + 4 &gt; 0 =&gt; and the value is: "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Example 2;</span></span><br><span class="line">  <span class="built_in">string</span> s;</span><br><span class="line">  <span class="keyword">if</span>(s.size() &lt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s.size() &lt; -1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以上代码的输出为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">unsigned</span>)<span class="number">-5</span> + <span class="number">4</span> &gt; <span class="number">0</span> =&gt; <span class="keyword">and</span> the value is: <span class="number">4294967295</span></span><br><span class="line">s.size() &lt; <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其中Example 1很好理解，执行 <strong><em>a + b</em></strong> 的时候，b被转成了unsigned int，变成了一个很大的正数</p>
</li>
<li>而Example 2中，<strong>string对象的size()函数返回的也是一个无符号整数</strong>，所以也存在unsigned int 和 int 在同一个表达式里混用的问题。</li>
<li>不解释 =&gt; <strong><em>u_int &lt;=&gt; unsigned int</em></strong></li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2018/05/21/computer_networking_05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/21/computer_networking_05/" class="post-title-link" itemprop="url">Chapter 5 The Data Link Layer</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-21 18:00:00" itemprop="dateCreated datePublished" datetime="2018-05-21T18:00:00+08:00">2018-05-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-20 10:55:18" itemprop="dateModified" datetime="2019-04-20T10:55:18+08:00">2019-04-20</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="Link-Layer-Introduction-and-Services"><a href="#Link-Layer-Introduction-and-Services" class="headerlink" title="Link Layer: Introduction and Services"></a>Link Layer: Introduction and Services</h2><ul>
<li>链路层实现相邻节点间的可靠数据传输</li>
<li><strong>nodes</strong>(节点) =&gt; <strong>主机/端系统</strong> 和 <strong>路由器</strong></li>
<li><strong>links</strong>(链路) =&gt; 连接两相邻节点间的通信频道</li>
</ul>
</blockquote>
<ul>
<li><h3 id="The-Services-Provided-by-the-Link-Layer（链路层所提供的服务）"><a href="#The-Services-Provided-by-the-Link-Layer（链路层所提供的服务）" class="headerlink" title="The Services Provided by the Link Layer（链路层所提供的服务）"></a>The Services Provided by the Link Layer（链路层所提供的服务）</h3><p><strong>链路层</strong> 所提供的 <strong>最基本的服务</strong> 就是 <strong>在两个相邻节点见得单个通信链路上转移datagram</strong></p>
<ul>
<li><h4 id="成帧（Framing）"><a href="#成帧（Framing）" class="headerlink" title="成帧（Framing）"></a>成帧（<strong><em>Framing</em></strong>）</h4><ul>
<li>在 <strong>发送端</strong> 将构造数据帧，将datagram放入数据域，加头加尾（尾部是用来检测及纠错的），<strong>打包成帧</strong></li>
<li>在 <strong>接收端解开</strong> 收到的 <strong>数据帧</strong>，将datagram传递给上层</li>
</ul>
</li>
<li><h4 id="链路接入（Link-access）"><a href="#链路接入（Link-access）" class="headerlink" title="链路接入（Link access）"></a>链路接入（<strong><em>Link access</em></strong>）</h4><ul>
<li><strong>MAC</strong> (<strong><em>Medium access control</em></strong>, 介质访问控制) 协议详细规定了数据帧何时如何发送到链路上</li>
<li>MAC协议还用于当多个节点共享同一链路的时候，协调多个节点如何传递数据帧</li>
</ul>
</li>
<li><h4 id="可靠数据传输（Relilable-delivery）"><a href="#可靠数据传输（Relilable-delivery）" class="headerlink" title="可靠数据传输（Relilable delivery）"></a>可靠数据传输（<strong><em>Relilable delivery</em></strong>）</h4><p>数据链路层可提供两相邻节点间的可靠数据传输（但不是必须的，大多数无线协议是不提供可靠数据传输的）</p>
</li>
<li><h4 id="流量控制（flow-control）"><a href="#流量控制（flow-control）" class="headerlink" title="流量控制（flow control）"></a>流量控制（<strong><em>flow control</em></strong>）</h4><p>调节接收端发包的速率，防止接收端缓存溢出</p>
</li>
<li><h4 id="差错检测（Error-detection）"><a href="#差错检测（Error-detection）" class="headerlink" title="差错检测（Error detection）"></a>差错检测（<strong><em>Error detection</em></strong>）</h4><p>通过添加错误检测位，在接收端可以对收到的数据帧进行错误检测</p>
</li>
<li><h4 id="差错纠正（Error-correction）"><a href="#差错纠正（Error-correction）" class="headerlink" title="差错纠正（Error correction）"></a>差错纠正（<strong><em>Error correction</em></strong>）</h4></li>
<li><h4 id="半双工和全双工（Half-duplex-and-full-duplex）"><a href="#半双工和全双工（Half-duplex-and-full-duplex）" class="headerlink" title="半双工和全双工（Half-duplex and full-duplex）"></a>半双工和全双工（<strong><em>Half-duplex and full-duplex</em></strong>）</h4></li>
</ul>
</li>
<li><h3 id="链路层的实现"><a href="#链路层的实现" class="headerlink" title="链路层的实现"></a>链路层的实现</h3><img src="/img/computer_network/computer_network_66.png" title="网络适配器与其他主机组件以及网络协议栈的关系">
<p>数据链路层的实现是：硬件 + 软件</p>
<ul>
<li><strong>大部分功能在硬件（网卡）中实现</strong>：framing, link access, flow control, err dectection 等等</li>
<li><strong>部分功能由运行在CPU上的软件完成</strong>：发送端从网络层接收datagram，以及接收端将解开frame得到的datagram传递给网络层等</li>
<li><strong>硬件实现的效率高，可以做纠错等比较复杂的操作而不太影响性能</strong></li>
<li>现今很多人致力于将网络层甚至传输层的一部分工作，比如Checksum放到网卡中用硬件来实现，虽然这于网络协议栈分层的思想相悖，但是确实可以提高网络性能</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Error-Detection-and-Correction-Techniques"><a href="#Error-Detection-and-Correction-Techniques" class="headerlink" title="Error-Detection and Correction Techniques"></a>Error-Detection and Correction Techniques</h2><ul>
<li>奇偶校验（<strong><em>Parity checking</em></strong>）</li>
<li>校验和（<strong><em>Checksum</em></strong>）</li>
<li>循环冗余校验（<strong><em>Cyclic Redundancy Check</em></strong>）</li>
</ul>
</blockquote>
<ul>
<li><h3 id="奇偶校验（Parity-checking）"><a href="#奇偶校验（Parity-checking）" class="headerlink" title="奇偶校验（Parity checking）"></a>奇偶校验（<strong><em>Parity checking</em></strong>）</h3><ul>
<li><h4 id="奇校验和偶校验"><a href="#奇校验和偶校验" class="headerlink" title="奇校验和偶校验"></a>奇校验和偶校验</h4><ul>
<li>奇校验：数据位上1的个数个校验位上1的个数之和为奇数</li>
<li>偶校验：数据位上1的个数个校验位上1的个数之和为偶数</li>
</ul>
</li>
<li><h4 id="One-bit-even-parity（单比特位偶校验）"><a href="#One-bit-even-parity（单比特位偶校验）" class="headerlink" title="One-bit even parity（单比特位偶校验）"></a>One-bit even parity（单比特位偶校验）</h4><img src="/img/computer_network/computer_network_67.png" title="单比特位偶校验图示">
<ul>
<li>存在的问题：当有偶数个bit为发送错误的时候，这种方式无法检测</li>
<li><strong>可以用来检错，但是准确率不高</strong></li>
</ul>
</li>
<li><h4 id="Two-dimensional-even-parity（二位偶校验）"><a href="#Two-dimensional-even-parity（二位偶校验）" class="headerlink" title="Two-dimensional even parity（二位偶校验）"></a>Two-dimensional even parity（二位偶校验）</h4><img src="/img/computer_network/computer_network_68.png" title="二位偶校验图示">
<ul>
<li>即使偶数位比特位发送错误，也能检测出来</li>
<li>通过二维校验位的定位，可以精确到哪一个bit位发生错误，进而改正这个错误（接收端如果能自行改正错误将降低网络的整体时延，提升网络的性能）</li>
<li><strong>可以检错，也可以纠错</strong></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="校验和（Checksum）"><a href="#校验和（Checksum）" class="headerlink" title="校验和（Checksum）"></a>校验和（<strong><em>Checksum</em></strong>）</h3><p>通常发送端用校验和算法将让整个数据包的所有bit位参与计算，得到一个校验和（最简单的实现方式是将其看做一系列的数值，直接相加），在接收端再次计算这个校验和，并与收到的校验和逐bit比对</p>
</li>
<li><h3 id="循环冗余校验（Cyclic-Redundancy-Check）"><a href="#循环冗余校验（Cyclic-Redundancy-Check）" class="headerlink" title="循环冗余校验（Cyclic Redundancy Check）"></a>循环冗余校验（<strong><em>Cyclic Redundancy Check</em></strong>）</h3><img src="/img/computer_network/computer_network_69.png" title="循环冗余校验码格式">
<ul>
<li><h4 id="数据格式说明"><a href="#数据格式说明" class="headerlink" title="数据格式说明"></a>数据格式说明</h4><ul>
<li><strong>前d位为数据域</strong></li>
<li><strong>后r位为CRC码</strong></li>
</ul>
</li>
<li><h4 id="生成多项式G"><a href="#生成多项式G" class="headerlink" title="生成多项式G"></a>生成多项式G</h4><ul>
<li>生成多项式 <strong>G</strong> 共有 <strong>r + 1位</strong> （其中R位CRC码的长度）</li>
<li>可能直接以 <strong>二进制的形式</strong> 给出</li>
<li><p>也可能以 <strong>多项式的形式</strong> 给出（需要先转成二进制形式）</p>
<p>Eg.: G = x<sup>4</sup> + x<sup>3</sup> + x  ==&gt; G : 11010</p>
</li>
</ul>
</li>
<li><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><img src="/img/computer_network/computer_network_70.png" title="计算CRC码的栗子">
<ul>
<li>在data后面加上r位0用与计算</li>
<li>其中里面每一步处理的时候执行的是 <strong>异或运算</strong></li>
<li>若最后的结果位数不够r为，则要在前面补上足够的0</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Multiple-Access-Protocols（多路访问协议）"><a href="#Multiple-Access-Protocols（多路访问协议）" class="headerlink" title="Multiple Access Protocols（多路访问协议）"></a>Multiple Access Protocols（多路访问协议）</h2><ul>
<li>网络的两种链路类型<ul>
<li>point-to-point link (点对点链路) =&gt; 只有一个发送端和接收端</li>
<li>brodcast link (广播链路) =&gt; 可能同时存在多个发送端和接收端在同一个链路上通信</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ul>
<li><h4 id="多路访问问题（multiple-access-problem）"><a href="#多路访问问题（multiple-access-problem）" class="headerlink" title="多路访问问题（multiple access problem）"></a>多路访问问题（<strong><em>multiple access problem</em></strong>）</h4><p>当在同一个通信链路上同时存在多个发送端和接收端的时候，他们之间要进行通信，由于同一时刻必然只有一个接收端和发送端，如何确保并协调这些节点的通信就是 <strong>多路访问问题</strong> =&gt; <strong>多路访问协议</strong>（<strong><em>Multiple Access Protocol</em></strong>）就是致力于解决这个问题</p>
</li>
<li><h4 id="碰撞的发生及处理"><a href="#碰撞的发生及处理" class="headerlink" title="碰撞的发生及处理"></a>碰撞的发生及处理</h4><p>在广播链路中，通常一个节点发送数据，该链路连接的所有节点都会收到一份copy，如果同一时刻有两个发送端在发送数据，则接收端无法解析这些数据，这就发送了 <strong>碰撞</strong>（<strong><em>collide</em></strong>） =&gt; 通常一旦碰撞发生，接收端就会选择丢弃这些包，这就相当于丢包发送了。这一段时间，两个发送端发送数据都不会被成功接收，链路并没有成功传输数据，<strong>浪费了带宽资源</strong>。而且通常不作处理的话，接入的节点越多，发生碰撞的几率越高，带宽就被大量的浪费</p>
</li>
<li><h4 id="多路访问协议分类"><a href="#多路访问协议分类" class="headerlink" title="多路访问协议分类"></a>多路访问协议分类</h4><ul>
<li><strong>信道分隔协议</strong>（<strong><em>channel partitioning protocols</em></strong>）</li>
<li><strong>随机访问协议</strong>（<strong><em>random access protocols</em></strong>）</li>
<li><strong>轮询协议</strong>（<strong><em>taking-turns protocols</em></strong>）</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="Channel-Partitioning-Protocols"><a href="#Channel-Partitioning-Protocols" class="headerlink" title="Channel Partitioning Protocols"></a>Channel Partitioning Protocols</h3><img src="/img/computer_network/computer_network_71.png" title="4个节点的TDM和FDM分隔信道图示">
<ul>
<li>采用固定的资源分配方式，<strong>资源独占独享</strong></li>
<li><strong>资源利用率低</strong></li>
<li><strong>不会发生冲突</strong></li>
<li>TDM 和 FDM</li>
</ul>
</li>
<li><h3 id="Random-Access-Protocols"><a href="#Random-Access-Protocols" class="headerlink" title="Random Access Protocols"></a>Random Access Protocols</h3><blockquote>
<p>使用随机访问协议时，一个 <strong>正在传输的节点</strong> 总是可以 <strong>享用所有的带宽</strong>。当 <strong>发生碰撞</strong> 时，所有 <strong>参与碰撞的节点</strong> 都会 <strong>重传数据包</strong>。但并不是立即重传，而是 <strong>随机等待一段时间之后再重传</strong>（<strong><em>It waits a random delay before retransmitting th frame</em></strong>）。而且每个参与碰撞的节点<strong>产生时延都是独立且随机的</strong>，这样就可以保证一部分节点可以错开其它节点，不发生冲突而成功传送数据包。</p>
</blockquote>
<ul>
<li><h4 id="Sloted-ALOHA-（分时隙的ALOHA协议）"><a href="#Sloted-ALOHA-（分时隙的ALOHA协议）" class="headerlink" title="Sloted ALOHA （分时隙的ALOHA协议）"></a>Sloted ALOHA （分时隙的ALOHA协议）</h4><ul>
<li><h5 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h5><ul>
<li><p>所有数据帧的长度都为L比特（<strong><em>All frames consist of exactly L bits</em></strong>）</p>
</li>
<li><p>每个时隙的大小为L/R秒，也就是说一个在 <strong>一个时隙内刚好可以传输一个数据帧</strong> （<strong><em>Time is divided int oslots of size L/R seconds, that is, a slot equals the time to transmit one frame</em></strong>）</p>
</li>
<li><p><strong>节点只在时隙开始的时候传递数据包</strong>（<strong><em>Nodes start to transmit framges only at the beginings of slots</em></strong>） =&gt; 也就是说在时隙内不会有其它未在传输的节点试图传递数据</p>
</li>
<li><p>所有节点都是同步的，这样所有节点都能知道时隙什么时候开始（<strong><em>The nodes are synchronized so that each node knows when the slots begin</em></strong>）=&gt; 前面的是书上的原话，同步和异步的定义在不同的场景下的定义可能不一样。这里所说的同步应该是对时间轴进行同步，所有实现的时候，只要时隙一开始，所有节点都能知道，并单独决定是否发送数据帧。</p>
</li>
<li><p>一旦两个或更多的数据帧在同一时隙内发生了 <strong>冲突</strong>（<strong><em>collide</em></strong>），所有的节点都能在时隙结束前知道发生了冲突。（<strong><em>If two or more frames collide in a slot, then all the nodes detect the collission event before the slot ends</em></strong>）</p>
</li>
</ul>
</li>
<li><h5 id="每个节点所执行的操作"><a href="#每个节点所执行的操作" class="headerlink" title="每个节点所执行的操作"></a>每个节点所执行的操作</h5><ul>
<li><p>当节点 <strong>有一个新的数据帧要发送</strong> 时，它会 <strong>等待下一个时隙的开始</strong>，并试图 <strong>在下一个时隙内发送整个数据帧</strong> （<strong><em>When the node has a fresh frame to send, it waits until the begining of the next slot and transmit the entire frame in the slot.</em></strong>）</p>
</li>
<li><p>如果 <strong>没有发送冲突</strong> ，则节点 <strong>认为数据包已成功传输且不用考虑重传</strong>，如果还有数据帧未发的话，这个时候节点就可以准备发送下一个数据帧。（<strong><em>If there isn’t collision, the node has successfully transmited its frame and thus need not consider restransmitting the frame. The node can prepare a new frame for transimission, if it has one</em></strong>）</p>
</li>
<li><p>如果 <strong>发生了冲突</strong>，节点能够在时隙结束前获悉，<strong>节点会在接下来的连续时隙内以概率p重传数据帧</strong>，直到这个数据帧被成功发送且没有发送冲突。（<strong><em>If there is a collision, the node detects the collision before the end of the slot. The node restransmits its frame in each subsequent slot with probability p until the frame is transimited without a collision</em></strong>）</p>
</li>
</ul>
</li>
<li><h5 id="以概率p发送数据帧"><a href="#以概率p发送数据帧" class="headerlink" title="以概率p发送数据帧"></a>以概率p发送数据帧</h5><p>这是在发送冲突以后，节点会重传因为冲突而未传输成功的数据帧。但是为了避免下一时隙的大概率冲突，Slotted ALOHA协议选择让每个节点以概率p重传，也就是说<strong>发送冲突的每个节点在下一时隙有概率p的可能重传数据包，有 (1 - p) 的可能选择等待</strong>（值得注意的是，选择等待的节点在没有重传成功之前，都会在下一时隙开始时以概率p重传发送冲突的数据包） 。而且每个节点在未重传成功之前，都会每次以概率p发送，且是各自独立的，这也就实现了随机访问协议中 <strong>当冲突发生的时候，每个节点会独立的随机等待一段时间</strong> 的特性</p>
</li>
<li><h5 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h5><img src="/img/computer_network/computer_network_72.png" title="Slotted ALOHA协议执行示例">
<p>上面假设三个节点各有一个数据包需要发送</p>
<ul>
<li>1时刻，3个节点都试图发送数据，发送冲突</li>
<li>2时刻，3个节点都有需要重传的数据包，但是选择等待</li>
<li>3时刻node3选择等待，但是另外连个节点选择发送，发送冲突</li>
<li>4时刻只有node2选择发送，发送成功（至此，node2已经没有需要发送的数据帧）</li>
<li>5时刻node1和node3都选择等待</li>
<li>6时刻只有node1选择发送，发送成功（至此，node1已经没有需要发送的数据帧）</li>
<li>7时刻，node3成功发送数据帧</li>
</ul>
<p>可以看出，发送3个数据帧，却用了7个时隙，浪费了带宽</p>
</li>
<li><h5 id="Slotted-ALOHA-协议的优点"><a href="#Slotted-ALOHA-协议的优点" class="headerlink" title="Slotted ALOHA 协议的优点"></a>Slotted ALOHA 协议的优点</h5><ul>
<li>单节点的瞬时带宽可达到最大带宽</li>
<li>时隙的分配高度分散，只给需要传输数据的节点分配时隙（当系统中每个时隙只有一个节点需要发送数据的时候，该协议可以工作的很好）</li>
<li>实现简单</li>
</ul>
</li>
<li><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>有可能发生碰撞进而浪费时隙（而且参与的节点越多，发生碰撞的可能性越大）</li>
<li>需要严格的时钟同步</li>
</ul>
</li>
<li>当有 <strong>大量的节点参与</strong> 的时候，<strong>时隙（带宽）的最大利用率</strong> 大概只有 <strong>1 / e ≈ 37%</strong></li>
</ul>
</li>
<li><h4 id="Aloha-pure-ALOHA"><a href="#Aloha-pure-ALOHA" class="headerlink" title="Aloha (pure ALOHA)"></a>Aloha (pure ALOHA)</h4><img src="/img/computer_network/computer_network_73.png" title="Pure ALOHA协议执行示例">
<p>纯的ALOHA协议没有时钟同步。当有一个数据帧要发送的时候就立即发送，当发生冲突的时候就立即以概率p重传，以概率（1  - p）等待传输一个数据帧所需要的时间。=&gt; 冲突发生的概率更大了，当有 <strong>大量的节点参与</strong> 的时候，<strong>带宽的最大利用率</strong> 大概只有 <strong>1 / 2e ≈ 18.5%</strong></p>
</li>
<li><h4 id="Carrier-Sense-Multiple-Access-CSMA-载波侦听多路访问"><a href="#Carrier-Sense-Multiple-Access-CSMA-载波侦听多路访问" class="headerlink" title="Carrier Sense Multiple Access (CSMA, 载波侦听多路访问)"></a>Carrier Sense Multiple Access (CSMA, 载波侦听多路访问)</h4><ul>
<li><h5 id="文明交流所必备的两个素质"><a href="#文明交流所必备的两个素质" class="headerlink" title="文明交流所必备的两个素质"></a>文明交流所必备的两个素质</h5><ul>
<li><p><strong><em>Listen before speaking</em></strong> ：如果别人在啊讲话，则等别人说完再发表言论。在网络世界中，就是当你有一个数据帧需要发送的时候，而这个时候其它节点正在发送数据帧，则当前节点等待一段时间后再看是否还有节点在传输，仍有则继续等待，直到信道空闲的时候，发送数据。=&gt; <strong>载波侦听</strong>（<strong><em>carrier sensing</em></strong>）</p>
</li>
<li><p><strong><em>If someone else begins talking at the same time, stop talking</em></strong> ：如果在发送数据的过程中，发现其它节点也在发送数据，则停止发送数据。=&gt; <strong>冲突检测</strong>（<strong><em>collision dection</em></strong>）</p>
</li>
</ul>
</li>
<li><h5 id="CSMA的大致原理"><a href="#CSMA的大致原理" class="headerlink" title="CSMA的大致原理"></a>CSMA的大致原理</h5><p>发送数据帧之前先侦听信道，如果信道为忙则等待一段时间后再尝试发送，如果为闲，则立即发送。</p>
</li>
<li><h5 id="CSMA仍然存在冲突"><a href="#CSMA仍然存在冲突" class="headerlink" title="CSMA仍然存在冲突"></a>CSMA仍然存在冲突</h5><p>当 <strong>一个节点A发送数据到信道中，到另一个节点B可以侦听到节点A正在发送数据之间存在一段时延</strong>，如果在这短时间内，节点B刚好有数据发送，那么由于它还没有检测到A正在发送数据，就会认为当前信道是空闲的，接着B就开始发送数据，这样冲突就出现了。</p>
</li>
<li><h5 id="不侦听信道，冲突发生时不处理"><a href="#不侦听信道，冲突发生时不处理" class="headerlink" title="不侦听信道，冲突发生时不处理"></a>不侦听信道，冲突发生时不处理</h5><img src="/img/computer_network/computer_network_74.png" title="不侦听信道，冲突发生时不处理">
</li>
<li><h5 id="侦听信道，冲突发生时停止发送"><a href="#侦听信道，冲突发生时停止发送" class="headerlink" title="侦听信道，冲突发生时停止发送"></a>侦听信道，冲突发生时停止发送</h5><img src="/img/computer_network/computer_network_75.png" title="侦听信道，冲突发生时停止发送">
</li>
<li><h5 id="Nonpersistent-CSMA-gt-不持续侦听信道"><a href="#Nonpersistent-CSMA-gt-不持续侦听信道" class="headerlink" title="Nonpersistent CSMA =&gt; 不持续侦听信道"></a>Nonpersistent CSMA =&gt; 不持续侦听信道</h5><ul>
<li>当节点有数据需要发送的时候，信道为闲则发</li>
<li>信道为忙，则等待一段时间后在尝试发送</li>
</ul>
</li>
<li><h5 id="1-persistent-CSMA"><a href="#1-persistent-CSMA" class="headerlink" title="1-persistent CSMA"></a>1-persistent CSMA</h5><ul>
<li>信道为闲，则发</li>
<li>信道为忙，则持续侦听信道，知道信道为闲，然后以概率1发数据（当两个节点同时侦听到信道闲，并都以概率1发数据，就发生了冲突）</li>
</ul>
</li>
<li><h5 id="p-persistent-CSMA"><a href="#p-persistent-CSMA" class="headerlink" title="p-persistent CSMA"></a>p-persistent CSMA</h5><ul>
<li>信道为闲，则发</li>
<li>信道为忙，则持续侦听信道，知道信道为闲，然后以概率p发数据</li>
</ul>
</li>
<li><h5 id="CSMA-with-collision-detection-CSMA-CD-带冲突检测的载波侦听多路访问协议"><a href="#CSMA-with-collision-detection-CSMA-CD-带冲突检测的载波侦听多路访问协议" class="headerlink" title="CSMA with collision detection (CSMA/CD, 带冲突检测的载波侦听多路访问协议)"></a>CSMA with collision detection (CSMA/CD, 带冲突检测的载波侦听多路访问协议)</h5><ul>
<li>要求节点必须全双工工作（发送数据包的同时也尝试接收数据包），<strong>当检测到冲突时</strong>（如果发送数据包的时候收到其他节点发送的数据包就表示发送了冲突），<strong>立即停止发送数据包</strong> =&gt; <strong>可以把冲突带来损失降低</strong></li>
<li>目前为止，所有的无线传输都是半双工的，故不能采用CSMA/CD</li>
</ul>
</li>
<li><h5 id="CSMA-with-collistion-avoid-CSMA-CA-带冲突避免的载波侦听多路访问协议"><a href="#CSMA-with-collistion-avoid-CSMA-CA-带冲突避免的载波侦听多路访问协议" class="headerlink" title="CSMA with collistion avoid (CSMA/CA, 带冲突避免的载波侦听多路访问协议)"></a>CSMA with collistion avoid (CSMA/CA, 带冲突避免的载波侦听多路访问协议)</h5><p>因为无线传输时半双工的，无法再发包的同时检测冲突，故一旦冲突发生，发包也不会停止，故应该尽量避免冲突</p>
</li>
</ul>
</li>
<li><h4 id="Taking-Turns-Protocols（轮流协议）"><a href="#Taking-Turns-Protocols（轮流协议）" class="headerlink" title="Taking-Turns Protocols（轮流协议）"></a>Taking-Turns Protocols（轮流协议）</h4><ul>
<li><h5 id="polling-protocol-轮询协议"><a href="#polling-protocol-轮询协议" class="headerlink" title="polling protocol (轮询协议)"></a>polling protocol (轮询协议)</h5><p>主节点对每个节点进行轮询，只要当被询问时才可以发送数据</p>
<ul>
<li>优点：没有冲突，没有空时隙</li>
<li>缺点：会有询问延时，需要主节点，会有单点故障</li>
</ul>
</li>
<li><h5 id="token-passing-protocol（令牌传递协议）"><a href="#token-passing-protocol（令牌传递协议）" class="headerlink" title="token-passing protocol（令牌传递协议）"></a>token-passing protocol（令牌传递协议）</h5><p>一个特殊的帧被作为令牌，在节点之间按特定的顺序传递，只有持有令牌的节点才可以发送数据（且每次发送的数据有上限）</p>
<ul>
<li>优点：不需要主节点，没有冲突，没有空时隙</li>
<li>缺点：可能有些节点中途宕机，导致令牌无法传递，或者持有令牌后宕机，导致令牌丢失等等</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="Local-Area-Networks-LANs-本地局域网"><a href="#Local-Area-Networks-LANs-本地局域网" class="headerlink" title="Local Area Networks (LANs, 本地局域网)"></a>Local Area Networks (LANs, 本地局域网)</h4><img src="/img/computer_network/computer_network_76.png" title="LAN">
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Link-Layer-Address-（链路层寻址）"><a href="#Link-Layer-Address-（链路层寻址）" class="headerlink" title="Link-Layer Address （链路层寻址）"></a>Link-Layer Address （链路层寻址）</h2></blockquote>
<ul>
<li><h3 id="MAC-Address"><a href="#MAC-Address" class="headerlink" title="MAC Address"></a>MAC Address</h3><img src="/img/computer_network/computer_network_77.png" title="每个连接到LAN的网络适配器都有一个唯一的MAC地址">
<ul>
<li>MAC地址是 <strong>数据链路层的地址</strong>，同时也是数据链路层所采用的编址方式</li>
<li><strong>长度为48 bits</strong>，常用12个16进制的数字表示（2个一组，6组）</li>
<li>每个网络适配器上有一个网路地址，网卡出厂的时候的MAC地址是全球唯一的（是由IEEE统一管理的），但是现在可以用软件修改网络适配器的MAC地址，这里仍然假设它是唯一且不变的。</li>
</ul>
</li>
<li><h3 id="Address-Resolution-Protocol-ARP-地址解析协议"><a href="#Address-Resolution-Protocol-ARP-地址解析协议" class="headerlink" title="Address Resolution Protocol (ARP, 地址解析协议)"></a>Address Resolution Protocol (ARP, 地址解析协议)</h3><blockquote>
<p>ARP 协议实现的是IP地址到MAC地址的映射</p>
</blockquote>
<img src="/img/computer_network/computer_network_78.png" title="每个节点都有网络层地址和链路层地址">
<ul>
<li><p>当 <strong>一个节点发送一个frame</strong> 时，实际上所有在 <strong>同一个子网内的节点都会收到</strong> 一个copy，只是在链路层做了一层判断，若 <strong>该frame的目的MAC地址与本节点的MAC地址匹配则解包，传递给上层，否则直接丢弃</strong>。</p>
</li>
<li><p><strong>每一个</strong> 藉由网络适配器在局域网内通信的 <strong>节点都会在内存中维护一张 ARP table</strong>（地址映射表），保存了 <strong>当前局域网内所有已知主机的IP地址与MAC地址的映关系</strong>。（且映射表中的每一个表项都有一个TTL，一旦过期便会移除该表项）</p>
</li>
<li><p>当欲发送的frame的目标IP在本地ARP table中 <strong>找不到对应的映射时</strong> ，节点 <strong>发送一个APR query package</strong>，目的MAC地址为全1，作为广播，只有与目的IP匹配的设备会返回一个正常的数据帧，节点再记录下IP地址与返回消息中包含的目标节点的MAC地址的映射。</p>
<img src="/img/computer_network/computer_network_79.png" title="ARP table">
</li>
<li><p><strong>ARP协议是即插即用的</strong></p>
</li>
<li><p><strong>MAC地址只在本局域网内有效</strong></p>
<img src="/img/computer_network/computer_network_80.png" title="一个路由器连接两个子网">
<p>=&gt; <strong>数据帧在穿越路由器的时候链路层首部的源MAC地址和目的MAC地址都要修改</strong></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Ethernet-以太网"><a href="#Ethernet-以太网" class="headerlink" title="Ethernet (以太网)"></a>Ethernet (以太网)</h2><ul>
<li>它是互联网中有线网络通信的事实标准</li>
<li>所采用的MAC (<strong><em>Multiple Access Control</em></strong>, 多路访问控制) 协议为 <strong>1-persistent CSMA/CD</strong> (<strong><em>Carrier Sense Multiple Access with Collide Detection</em></strong>, 带冲突检测的载波侦听多路访问协议)</li>
<li>以太网相较于其他有线局域网最大的优势：<strong>实现简单，价格便宜</strong></li>
</ul>
</blockquote>
<ul>
<li><h3 id="Ethernet-Frame-Structure-以太网帧结构"><a href="#Ethernet-Frame-Structure-以太网帧结构" class="headerlink" title="Ethernet Frame Structure (以太网帧结构)"></a>Ethernet Frame Structure (以太网帧结构)</h3><img src="/img/computer_network/computer_network_81.png" title="以太网帧结构2">
<ul>
<li><strong>Preamble</strong> (<strong><em>8 bytes</em></strong>) : 前序/序文，不算在以太网帧长度里面<ul>
<li><strong>Dest. address</strong> (<strong><em>6 bytes</em></strong>) : 目的端MAC地址节点A向B发一个数据包，在数据包到达B之前，B恰好要想A发一个数据包，此时因未收到A发的包，故认为信道空闲，B向A发一个包。在B收到A的包后，意识到发送了冲突，停止发送数据包。<em>**</em></li>
</ul>
</li>
<li><strong>Source address</strong> (<strong><em>6 bytes</em></strong>) : 源端MAC地址</li>
<li><strong>Type</strong> : 标识使用的是哪个网络层协议</li>
<li><strong>Data</strong> : 数据域</li>
<li><strong>CRC</strong> : 冗余校验码</li>
</ul>
<p>=&gt; <strong>以太网frame的长度范围：64 bytes ~ 1518 bytes</strong> (其中最大是因为协议规定了MTU，需要有最小长度的原因稍后会解释)</p>
</li>
<li><h3 id="CSMA-CD-Thernet’s-Multiple-Access-Protocol"><a href="#CSMA-CD-Thernet’s-Multiple-Access-Protocol" class="headerlink" title="CSMA/CD: Thernet’s Multiple Access Protocol"></a>CSMA/CD: Thernet’s Multiple Access Protocol</h3><ul>
<li>信道空闲时，立即发送，若信道为忙，则持续侦听信道 =&gt; <strong>持续侦听</strong></li>
<li>信道侦听过程中，一旦信道再次空闲，则以概率1发送数据包 =&gt; <strong>1-persistent</strong></li>
<li>在边发送数据的同时，边接收数据 =&gt; <strong>发送数据过程中如果收到数据包则表示发送了冲突</strong></li>
<li>一旦<strong>发生冲突</strong>，立即<strong>停止发送数据包</strong>，并<strong>广播一个信号</strong>（告知其它用户发送冲突了），同时<strong>等待一段时间</strong>（具体等待的时间由 <strong>“二进制退避算法”</strong> 求得）</li>
</ul>
</li>
<li><h3 id="二进制退避算法"><a href="#二进制退避算法" class="headerlink" title="* 二进制退避算法"></a>* 二进制退避算法</h3><p>{0， 1， 2， ···， 2<sup>m</sup> - 1}</p>
<ul>
<li>其中m是发生冲突的次数</li>
<li>随机选择一个元素 x 512 bits times</li>
<li><strong>bit times</strong>: 在当前网络环境下传输1 bit所需要的时间</li>
<li><strong>冲突10次以后集合不在扩大</strong>，即集合最大为1024个元素。<strong>冲突16次以后直接丢弃该包</strong>，不再传输</li>
</ul>
</li>
<li><h3 id="为什么以太网帧的长度最小为64-bits？"><a href="#为什么以太网帧的长度最小为64-bits？" class="headerlink" title="为什么以太网帧的长度最小为64 bits？"></a>为什么以太网帧的长度最小为64 bits？</h3><ul>
<li><h4 id="数据帧长度不够长所引发的问题"><a href="#数据帧长度不够长所引发的问题" class="headerlink" title="数据帧长度不够长所引发的问题"></a>数据帧长度不够长所引发的问题</h4><img src="/img/computer_network/computer_network_82.png" title="数据帧长度不够长所引发的问题">
<p>节点A向B发一个数据包，在数据包到达B之前，B恰好要想A发一个数据包，此时因未收到A发的包，故认为信道空闲，B向A发一个包。在B收到A的包后，意识到发送了冲突，停止发送数据包。<strong>如果A在B发的包到达A之前就已经将数据包发送完毕了，即A发的数据包不够长的情况下，A可能以为数据包发送成功了吗，而实际上是发送冲突了</strong></p>
</li>
<li><h4 id="为什么是64个字节"><a href="#为什么是64个字节" class="headerlink" title="为什么是64个字节"></a>为什么是64个字节</h4><img src="/img/computer_network/computer_network_83.png" title="为什么是64个字节">
</li>
</ul>
</li>
<li><h3 id="CSMA-CD-efficiency"><a href="#CSMA-CD-efficiency" class="headerlink" title="CSMA/CD efficiency"></a>CSMA/CD efficiency</h3><img src="/img/computer_network/computer_network_84.png" title="CSMA/CD efficiency">
<ul>
<li>当d<sub>prop</sub> -&gt; 0，或d<sub>trans</sub> -&gt; ∞，效率 -&gt; 1</li>
<li>数据包长度越长，节点间距离越短，效率越高</li>
<li>节点数据↑，发送冲突的可能性↑，效率↓</li>
</ul>
</li>
<li><h3 id="不同的以太网标准"><a href="#不同的以太网标准" class="headerlink" title="不同的以太网标准"></a>不同的以太网标准</h3><img src="/img/computer_network/computer_network_85.png" title="不同的以太网标准">
<ul>
<li>T开头的都是双绞线</li>
<li>所有非T开头的都是光纤</li>
<li>同轴电缆的格式：10Base2</li>
</ul>
</li>
</ul>
<p>=&gt; <strong>以太网负载在30%以内的时候性能很好，基本不丢包，但超过30%就会发生一系列的问题</strong></p>
<blockquote>
<h2 id="Link-layer-Switches-链路层交换机"><a href="#Link-layer-Switches-链路层交换机" class="headerlink" title="Link-layer Switches (链路层交换机)"></a>Link-layer Switches (链路层交换机)</h2></blockquote>
<ul>
<li><h3 id="几种常见网络设备区别"><a href="#几种常见网络设备区别" class="headerlink" title="几种常见网络设备区别"></a>几种常见网络设备区别</h3><ul>
<li><strong>中继器</strong>（<strong><em>repeter</em></strong>）：物理层设备 =&gt; <strong>将信号放大后转发</strong></li>
<li><strong>集线器</strong>（<strong><em>hubs</em></strong>）：物理层设备 =&gt; <strong>不能隔离冲突域</strong>（集线器是一种特殊的中继器）</li>
<li><strong>网桥</strong>（<strong><em>Bridge</em></strong>）：二层网络设备 =&gt; <strong>可隔离冲突域</strong></li>
<li><strong>交换机</strong>（<strong><em>Switches</em></strong>）：二层网络设备 =&gt; <strong>可隔离冲突域</strong></li>
<li><strong>路由器</strong>（<strong><em>Router</em></strong>）：3层网络设备 =&gt; <strong>可隔离广播域</strong></li>
</ul>
<p>=&gt; 网桥和交换机的功能基本一致，不过 <strong>网桥是二段口的，而交换机是多端口</strong> 的，同时 <strong>交换机还兼备“自学习”</strong> 等功能</p>
</li>
<li><h3 id="冲突域和广播域"><a href="#冲突域和广播域" class="headerlink" title="冲突域和广播域"></a>冲突域和广播域</h3><ul>
<li><strong>冲突域</strong>：在同一个冲突域的两个设备同时通信会导致冲突</li>
<li><strong>广播域</strong>：在同一个广播域中的设备可以互相广播</li>
</ul>
</li>
<li><h3 id="交换机（Switches）"><a href="#交换机（Switches）" class="headerlink" title="交换机（Switches）"></a>交换机（Switches）</h3><ul>
<li>是 <strong>链路层设备</strong>，比Hub更智能，其重要作用 =&gt; <strong>存储转发以太网帧</strong></li>
<li><strong>对主机透明</strong></li>
<li><strong>即插即用</strong></li>
<li><strong>自学习</strong></li>
<li>允许多路同步传输 =&gt; <strong>交换机隔离了冲突域</strong></li>
</ul>
</li>
<li><h3 id="Switch-table-and-self-learn"><a href="#Switch-table-and-self-learn" class="headerlink" title="Switch table and self-learn"></a>Switch table and self-learn</h3><blockquote>
<p>交换机通过自学习填充交换表</p>
</blockquote>
<ul>
<li><h4 id="self-learn（自学习）"><a href="#self-learn（自学习）" class="headerlink" title="self-learn（自学习）"></a>self-learn（自学习）</h4><p>交换机通过自学习可以在 Switch table中记录下从哪个端口可以到达哪个主机（下面建立交换表的过程中会详细讲述自学习）</p>
</li>
<li><h4 id="Switch-table"><a href="#Switch-table" class="headerlink" title="Switch table"></a>Switch table</h4><img src="/img/computer_network/computer_network_86.png" title="交换表">
<ul>
<li><p>交换表初始时为空</p>
</li>
<li><p>当收到一个frame时，记录下发送端的MAC地址以及从哪个端口进来的，并去查询交换表中有无到目的主机MAC地址对应的记录，若有则直接转发到对应端口，若无，执行下一步</p>
</li>
<li><p>若交换表中无对应的记录，则向所有的端口广播一个消息，目的MAC地址设置为目的主机，目的主机收到之后会回发一个数据包，交换机记录下其MAC地址以及从哪个端口可达。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>交换机可以将一个子网分隔成多个局域网</strong></p>
</li>
<li><h3 id="hubs-routers-switches的比较"><a href="#hubs-routers-switches的比较" class="headerlink" title="hubs, routers, switches的比较"></a>hubs, routers, switches的比较</h3><img src="/img/computer_network/computer_network_87.png" title="hubs, routers, switches的比较">
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2018/05/19/computer_networking_04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/19/computer_networking_04/" class="post-title-link" itemprop="url">Chapter 4 The Network Layer</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-19 18:00:00" itemprop="dateCreated datePublished" datetime="2018-05-19T18:00:00+08:00">2018-05-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-20 10:55:18" itemprop="dateModified" datetime="2019-04-20T10:55:18+08:00">2019-04-20</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>网络层完成主机到主机之间的数据传输</li>
<li>网络层协议存在于所有的主机和路由器当中（二层交换机中没有）</li>
<li>当IP数据报通过路由器时，路由器会检查所有数据报首部字段（Header Checksum）</li>
</ul>
</blockquote>
<ul>
<li><h3 id="Forwarding-and-Routing-存储和转发"><a href="#Forwarding-and-Routing-存储和转发" class="headerlink" title="Forwarding and Routing ( 存储和转发 )"></a>Forwarding and Routing ( 存储和转发 )</h3><ul>
<li><h4 id="Forwarding（转发）"><a href="#Forwarding（转发）" class="headerlink" title="Forwarding（转发）"></a>Forwarding（转发）</h4><p>When a packet arrives at a router’s input link, the router must move the packet to the appropriate.</p>
<p>=&gt; 转发指的是路由器将某个入口链路上到来的数据包转移到合适的出口链路的过程。</p>
</li>
<li><h4 id="Routing（路由）"><a href="#Routing（路由）" class="headerlink" title="Routing（路由）"></a>Routing（路由）</h4><p>The networklayer must determine the route or path taken by packets as they flow from a sender to a receiver. The algorithms that calculate these paths are reffered to as <strong>routing algorithms</strong>.</p>
<p>=&gt; 路由是指网络通过运行路由算法，计算出一条从源端到目的端的路径的过程</p>
</li>
<li><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul>
<li><strong>转发是路由器内部的事，而路由不是</strong>（路由需要网络里各个路由器的参与）</li>
<li>网络中的各个路由器，通过运行 <strong>路由算法</strong> (<strong><em>routing algorithms</em></strong>)计算出保存在各个路由器本地的 <strong>本地转发表</strong> (<strong>local forwarding table</strong>)。路由器根据此转发表来进行转发数据包。</li>
</ul>
</li>
<li><h4 id="Connection-Setup（连接建立）"><a href="#Connection-Setup（连接建立）" class="headerlink" title="Connection Setup（连接建立）"></a>Connection Setup（连接建立）</h4><ul>
<li>这是 <strong>网络</strong> 除转发和路由外 <strong>的第三个重要功能</strong>（互联网没有这个功能）</li>
<li>在网络层建立连接</li>
<li>EG.：ATM、frame-relay</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Virtual-Circuit-and-Datagram-Networks"><a href="#Virtual-Circuit-and-Datagram-Networks" class="headerlink" title="Virtual Circuit and Datagram Networks"></a>Virtual Circuit and Datagram Networks</h2><ul>
<li><strong>虚电路网络</strong>：在网络层建立连接的网络</li>
<li><strong>数据报网络</strong>：在网络层不建立连接的网络</li>
</ul>
</blockquote>
<ul>
<li><h3 id="Virtual-Circuit-Networks-（虚电路网络）"><a href="#Virtual-Circuit-Networks-（虚电路网络）" class="headerlink" title="Virtual-Circuit Networks （虚电路网络）"></a>Virtual-Circuit Networks （虚电路网络）</h3><ul>
<li><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul>
<li>从源到目的端的路径</li>
<li>VC number是标识沿路径每条链路上的号码（<strong>在每条链路上唯一即可</strong>）</li>
<li>沿途路由器中转发表中的项（<strong>由进入端口号的VC Number决定从哪个口出去，以及出去的时候VC Number修改为什么</strong>）</li>
</ul>
</li>
<li><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li>网络结构<img src="/img/computer_network/computer_network_43.png" title="一个简单的路电路网络示例"></li>
<li>上述网络结构中路由器A的转发表<img src="/img/computer_network/computer_network_44.png" title="路由器A的转发表">
</li>
</ul>
</li>
<li><p>虚电路网络中连接一旦建立，数据包所走的路径就确定了（而互联网不是）</p>
</li>
</ul>
</li>
<li><h3 id="Datagram-networks（数据报网络）"><a href="#Datagram-networks（数据报网络）" class="headerlink" title="Datagram networks（数据报网络）"></a>Datagram networks（数据报网络）</h3><ul>
<li>no call setup at network layer =&gt; <strong>网络层无连接建立</strong></li>
<li>routers: no state about end-to-end connections =&gt; <strong>路由器不保持端到端的连接状态</strong></li>
<li>Packets forward using destination host address =&gt; <strong>数据包的转发是根据目的端主机地址来进行转发的</strong></li>
<li>查询路由表进行转发的时候采用的是 <strong>最长前缀匹配</strong> (<strong><em>longest perfix matching rule</em></strong>)</li>
<li>IP是数据包网络的寻址方式</li>
</ul>
</li>
<li><h3 id="虚电路网络-VS-数据报网络"><a href="#虚电路网络-VS-数据报网络" class="headerlink" title="虚电路网络 VS 数据报网络"></a>虚电路网络 VS 数据报网络</h3><ul>
<li>Internet(互联网) =&gt; 数据报网络<ul>
<li>data exchange among computers</li>
<li>弹性服务，无严格的定时要求</li>
<li>“smart” end system =&gt; 终端相对智能</li>
<li>many link type =&gt; 有多种链路类型</li>
</ul>
</li>
<li>ATM =&gt; 虚电路网络<ul>
<li>envolved from telephone =&gt; 演化自电话技术</li>
<li>有严格的定时要求，可靠性要求高</li>
<li>“dump” end systems =&gt; 端系统简单，网络内部实现复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="What’s-inside-a-Router"><a href="#What’s-inside-a-Router" class="headerlink" title="What’s inside a Router?"></a>What’s inside a Router?</h2></blockquote>
<ul>
<li><h3 id="Router的两个功能"><a href="#Router的两个功能" class="headerlink" title="Router的两个功能"></a>Router的两个功能</h3><ul>
<li>run routing algorithms/protocol (<strong><em>RIP, OSPF, BGP</em></strong>)<br>=&gt; 运行路由算法/协议</li>
<li>forwarding datagrams from incoming to outgoing link<br>=&gt; 从入链路到出链路转发数据报</li>
</ul>
<img src="/img/computer_network/computer_network_45.png" title="路由器架构">
</li>
<li><h3 id="Input-ports"><a href="#Input-ports" class="headerlink" title="Input ports"></a>Input ports</h3><img src="/img/computer_network/computer_network_46.png" title="输入端处理流程">
<ul>
<li>Line termination =&gt; 物理层</li>
<li>Lookup =&gt; 根据数据报的目的地址，在输入口内存中使用转发表查找应该从哪个端口输出</li>
<li>forwarding =&gt; 将数据包转移到对应的出口</li>
<li>queueing =&gt; 如果数据报到达的速率比交换结构的转发速率要快，则导致排队的发生</li>
</ul>
</li>
<li><h3 id="三种类型的交换"><a href="#三种类型的交换" class="headerlink" title="三种类型的交换"></a>三种类型的交换</h3><img src="/img/computer_network/computer_network_47.png" title="三种交换技术">
<ul>
<li>Memory：共享内存 =&gt; 交换速率受内存大小的限制</li>
<li>Bus：总线型 =&gt; 交换速率受总线带宽的限制</li>
<li>Crossbar</li>
</ul>
</li>
<li><h3 id="Output-ports"><a href="#Output-ports" class="headerlink" title="Output ports"></a>Output ports</h3><img src="/img/computer_network/computer_network_48.png" title="出口端处理流程">
</li>
<li><h3 id="Where-does-Queuing-Occur"><a href="#Where-does-Queuing-Occur" class="headerlink" title="Where does Queuing Occur?"></a>Where does Queuing Occur?</h3><p>路由器中排队的发生可能在入口端的接收缓存或者是出口端的发送缓存</p>
<ul>
<li><h4 id="发送排队的时机"><a href="#发送排队的时机" class="headerlink" title="发送排队的时机"></a>发送排队的时机</h4><ul>
<li>入端口收到数据包的速率大于路由器转移数据包的速率 =&gt; 入口端发生排队</li>
<li>出口端收到路由器转发过来的数据包的速率大于发送数据包的速率 =&gt; 出口端发生排队</li>
</ul>
</li>
<li><p><strong>网络中所有数据的调度都是非抢占式的</strong></p>
</li>
<li><h4 id="缓存溢出时的策略"><a href="#缓存溢出时的策略" class="headerlink" title="缓存溢出时的策略"></a>缓存溢出时的策略</h4><ul>
<li>drop-tail: 如果缓存已满，则直接将新收到的数据包丢弃</li>
<li>RED(<strong><em>Random Early Detection</em></strong>) =&gt; 随机早期检测。在缓存将满而未满的时候就主动随机丢弃缓存队列中的数据包 （可以优化网络的拥塞状态）</li>
</ul>
</li>
</ul>
</li>
<li><p>路由协议一般是应用层的</p>
</li>
</ul>
<blockquote>
<h2 id="IP-Internet-Protocol-网际协议"><a href="#IP-Internet-Protocol-网际协议" class="headerlink" title="IP(Internet Protocol, 网际协议)"></a>IP(Internet Protocol, 网际协议)</h2><ul>
<li>PDU为Datagram</li>
</ul>
</blockquote>
<ul>
<li><h3 id="Datagram-Format-（数据报结构）"><a href="#Datagram-Format-（数据报结构）" class="headerlink" title="Datagram Format （数据报结构）"></a>Datagram Format （数据报结构）</h3><img src="/img/computer_network/computer_network_49.png" title="IPV4数据报结构">
<ul>
<li>Version (<strong><em>4bits</em></strong>) : IP协议版本号</li>
<li>Header Length (<strong><em>4bits</em></strong>) : <strong>IP数据报头的长度，单位为字节</strong> 。包括头部Options</li>
<li>Type of service (<strong><em>8bits</em></strong>) : TOS，用来标识IP数据报的服务类型</li>
<li>Datagram length (<strong><em>16bits</em></strong>) : <strong>整个数据报的长度，单位为字节</strong>。包括头部和数据域</li>
<li>第二行的个字段主要用于分片</li>
<li>Time-to-live (<strong><em>8bits</em></strong>) : TTL，有效时间 =&gt; 通常指的是跳数</li>
<li>Upper-layer protocol (<strong><em>8bits</em></strong>) : 上层所使用的协议</li>
<li><p>Header-checksum (<strong><em>16bits</em></strong>) : 首部校验和</p>
</li>
<li><h4 id="网络层只对Datagram首部进行校验"><a href="#网络层只对Datagram首部进行校验" class="headerlink" title="网络层只对Datagram首部进行校验"></a>网络层只对Datagram首部进行校验</h4><ul>
<li><h5 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h5><ul>
<li>data在传输层有checksum，故可以不需要再网络层对data进行校验</li>
<li>网络层提供的是不可靠的传输，允许出错</li>
</ul>
</li>
<li><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>只对首部进行校验，可以减少delay，同时减轻路由器的负载 =&gt; <strong>每个路由器都要网络层数据包处理，所以要让处理的开销尽量的小</strong></p>
</li>
<li><h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><ul>
<li>当某个正在网络中传播的数据包data部分出错，其途经的路由器由于只对其网络层头部进行校验，而不对data进行校验，所以会将这个出错的包继续传递，直到传递到终端才检测出来数据包错误。=&gt; <strong>造成传输资源的浪费</strong></li>
<li>TCP和UDP之外的其它传输层协议可能本身并不具备校验功能</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="为何每个路由器都要对数据包进行重新打包？"><a href="#为何每个路由器都要对数据包进行重新打包？" class="headerlink" title="为何每个路由器都要对数据包进行重新打包？"></a>为何每个路由器都要对数据包进行重新打包？</h4><p><strong>header中的数据</strong> 每经过一个路由器都 <strong>会改变</strong>，比如TTL每跳减一，因此 <strong>header checksum 需要重新计算</strong></p>
</li>
<li><p>IPv4 datagram 首部 <strong>最小、默认</strong> 开销为 <strong>20个字节</strong> =&gt; 严格来讲，由于Options域的存在，首部的开销是不确定的</p>
</li>
</ul>
</li>
<li><h3 id="IPv4-Datagram-Fragmentation-（IPv4-数据报分片）"><a href="#IPv4-Datagram-Fragmentation-（IPv4-数据报分片）" class="headerlink" title="IPv4 Datagram Fragmentation （IPv4 数据报分片）"></a>IPv4 Datagram Fragmentation （IPv4 数据报分片）</h3><ul>
<li><h4 id="为什么（何时）要进行分片？"><a href="#为什么（何时）要进行分片？" class="headerlink" title="为什么（何时）要进行分片？"></a>为什么（何时）要进行分片？</h4><p>低层（链路层）网络不同协议所支持的 <strong>MTU</strong> ( <strong><em>maximun transimit unit, 最大传输单元</em></strong> ) 不一致。而互联网中不同链路可以采用不同的协议，就可能导致 <strong>路由器两端链路的MTU不一致</strong>。=&gt; <strong>当路由器两端链路的MTU不一致，且是从MTU大的一端 -&gt; 小的一端的时候，就可能需要分片</strong> (当然，除了分片之外，路由器也可以选择主动丢弃，让发送端去调节数据包的大小)</p>
</li>
<li><h4 id="IPv4用于实现分片的头部字段"><a href="#IPv4用于实现分片的头部字段" class="headerlink" title="IPv4用于实现分片的头部字段"></a>IPv4用于实现分片的头部字段</h4><img src="/img/computer_network/computer_network_50.png" title="IPV4用于实现分片的字段">
<ul>
<li><strong>Identification</strong> : 属于同一个数据包的分片都有一个相同的Id</li>
<li><strong>DF</strong> : 若该标识置1，则表示不分片</li>
<li><strong>MF</strong> : 若该标识置1，则表示不是最后一个分片</li>
<li><strong>Fragment Offset</strong>: 分片的偏移量<img src="/img/computer_network/computer_network_51.png" title="IPv4分片偏移图示">
<ul>
<li><strong>单位是8bits</strong></li>
<li>一定要注意，<strong>偏移计算的是data部分，每个分片都单独有一个网络层头部</strong></li>
<li>当 <strong>(MTU - 首部size)</strong> 不是8的倍数时，每个分片data部分的最大size，取不超过但最大的能整除8的数</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h4><img src="/img/computer_network/computer_network_52.png" title="一个IP分片的栗子">
</li>
<li><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li><strong>发送主机</strong> 或者 <strong>路由器</strong> 都有 <strong>可能对IP数据报进行分片</strong></li>
<li>一个 <strong>IP分组可能被多次分段</strong>（分片）</li>
<li>但 <strong>IP分片重组</strong> (<strong><em>reassembly</em></strong>) 仅在目的主机进行</li>
</ul>
</li>
<li><h4 id="为何IP分片重组只在目的主机进行"><a href="#为何IP分片重组只在目的主机进行" class="headerlink" title="为何IP分片重组只在目的主机进行"></a>为何IP分片重组只在目的主机进行</h4><ol>
<li>不同的数据包从源端到目的端所走的路径可能不同，这就导致 <strong>不同分片可能经由不同的路由器组到达目的端</strong> ==&gt; 换句话说，途中的某个路由器可能无法收到同一个数据包的所有分片，就无法进行分片重组</li>
<li>这样可以减少路由器的开销，提高网络核心的效率</li>
</ol>
</li>
</ul>
</li>
<li><h3 id="IPv4-Addressing-（IPv4编址）"><a href="#IPv4-Addressing-（IPv4编址）" class="headerlink" title="IPv4 Addressing （IPv4编址）"></a>IPv4 Addressing （IPv4编址）</h3><ul>
<li><h4 id="IP-address"><a href="#IP-address" class="headerlink" title="IP address"></a>IP address</h4><ul>
<li><strong>主机</strong> 和 <strong>路由器</strong> 接口长度为32bits的标识</li>
<li>常采用 <strong>点分十进制</strong> (<strong><em>dotted-decimal notation</em></strong>)进行表示</li>
</ul>
</li>
<li><h4 id="Interface（接口）"><a href="#Interface（接口）" class="headerlink" title="Interface（接口）"></a>Interface（接口）</h4><p>主机或路由器和物理链路的接口</p>
</li>
<li><h4 id="Subnets（子网）"><a href="#Subnets（子网）" class="headerlink" title="Subnets（子网）"></a>Subnets（子网）</h4><p>To determine the subnets, detach each interface from its host or router, creating islands of isolated networks, with interfaces terminating the end points of the isolated networks. Each of these isolated networks is called a <strong>subnet</strong></p>
<ul>
<li>同一个子网内IP的高位比特位一致</li>
<li>拔开所有接口后，仍然连砸一起的网络属于同一个子网</li>
</ul>
</li>
<li><h4 id="CIDR-Classless-Interdomain-Routing-无类型域间选路"><a href="#CIDR-Classless-Interdomain-Routing-无类型域间选路" class="headerlink" title="CIDR(Classless Interdomain Routing, 无类型域间选路)"></a>CIDR(Classless Interdomain Routing, 无类型域间选路)</h4><blockquote>
<ul>
<li>网络地址（子网地址）部分是长度可变的</li>
<li>格式：<strong>a.b.c.d/x</strong> =&gt; 其中x表示的是网络地址（子网地址）部分的长度</li>
</ul>
</blockquote>
<img src="/img/computer_network/computer_network_53.png" title="IP地址网络地址和主机地址划分示意图">
<ul>
<li><strong>子网地址</strong>（网络地址）：前 <strong>x</strong> 位保留，后 <strong>32-x</strong> 位置0</li>
<li><strong>主机地址</strong>：前 <strong>x</strong> 位置0，后 <strong>32-x</strong> 位保留</li>
<li><strong>子网掩码</strong> (<strong><em>subnet mask</em></strong>)：前 <strong>x</strong> 位置1，后 <strong>32-x</strong> 位置0 =&gt; <strong>网络地址部分全置1，主机地址部分全置0</strong></li>
</ul>
</li>
<li><h4 id="Classful-Addressing（分类编址）"><a href="#Classful-Addressing（分类编址）" class="headerlink" title="Classful Addressing（分类编址）"></a>Classful Addressing（分类编址）</h4><blockquote>
<p>当ip地址表示的时候没有 <strong>/x</strong> 的时候，就可能采用的是这种方式判断网络地址和主机地址</p>
</blockquote>
<ul>
<li>Class A: 0.0.0.0 ~ 127.255.255.255 =&gt; <strong>A类地址前8位为网络地址</strong></li>
<li>Class B: 128.0.0.0 ~ 191.255.255.255 =&gt; <strong>B类地址前16位为网络地址</strong></li>
<li>Class C: 192.0.0.0 ~ 223.255.255.255 =&gt; <strong>C类地址前24位为网络地址</strong></li>
<li>Class D: 224.0.0.0 ~ 239.255.255.255 =&gt; <strong>D类地址为多播地址</strong></li>
<li>Class E: 240.0.0.0 ~ 255.255.255.255 =&gt; <strong>E类地址预留未用</strong></li>
</ul>
</li>
<li><h4 id="Private-IP（私有IP地址-内网地址）"><a href="#Private-IP（私有IP地址-内网地址）" class="headerlink" title="Private IP（私有IP地址 / 内网地址）"></a>Private IP（私有IP地址 / 内网地址）</h4><p>==&gt; 在很大程度上可以对互联网进行扩容（通过NAT技术）</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
</li>
<li><h4 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h4><ul>
<li><strong>0.0.0.0</strong> =&gt; 本主机</li>
<li>0···0 | Host =&gt; 主机地址</li>
<li>255.255.255.255 =&gt; 全局广播地址</li>
<li>network | 1···1 =&gt; 子网内广播地址</li>
<li>127 + Anything =&gt; 回环（Loopback）地址</li>
</ul>
</li>
<li><h4 id="如何辨别IP地址"><a href="#如何辨别IP地址" class="headerlink" title="如何辨别IP地址"></a>如何辨别IP地址</h4><img src="/img/computer_network/computer_network_54.png" title="子网划分以及IP地址范围示意图">
<ul>
<li><p><strong>IP地址范围</strong> 是包括了主机地址部分全0和全1的两个地址，但是 <strong>可分配给主机的IP地址范围</strong> 不包括。</p>
</li>
<li><p>Explicit（显示）：VLSM =&gt; 通过可变长子网掩码判别网络地址和主机地址</p>
</li>
<li>Implicit（隐式）：Classful =&gt; 通过判断ip地址属于哪一类IP地址，进而判断网络地址和主机地址</li>
</ul>
</li>
<li><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Subnet mask is: 255.255.255.224</span><br><span class="line">Host IP: 202.112.41.241</span><br><span class="line">Problems:</span><br><span class="line">  1. network address and host address ?</span><br><span class="line">  2. how many subnets are created at most ?</span><br><span class="line"></span><br><span class="line">解： 首先判断将当前的子网掩码转为2进制：</span><br><span class="line">      255.255.255.224 =&gt; 1···100000 （前27位为1）</span><br><span class="line">      224 =&gt; 11100000</span><br><span class="line">      241 =&gt; 11110001</span><br><span class="line"></span><br><span class="line">  ①.  网络地址：202.112.41.224</span><br><span class="line">      主机地址：0.0.0.17</span><br><span class="line"></span><br><span class="line">  ②.  分析可知该IP属于C类IP，前24位是网络地址</span><br><span class="line">    27 - 24 = 3（位）</span><br><span class="line">    2^3 = 8（个）</span><br><span class="line"></span><br><span class="line">    所以对多可以创建8个子网。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h3 id="DHCP-Dynamic-Host-Configuration-Protocol-动态主机配置协议"><a href="#DHCP-Dynamic-Host-Configuration-Protocol-动态主机配置协议" class="headerlink" title="DHCP (Dynamic Host Configuration Protocol, 动态主机配置协议)"></a>DHCP (Dynamic Host Configuration Protocol, 动态主机配置协议)</h3><ul>
<li><strong>plug-and-play</strong> =&gt; 即插即用</li>
<li>基于UDP</li>
<li>动态自动分配IP地址，可充分利用IP地址资源</li>
</ul>
<img src="/img/computer_network/computer_network_55.png" title="DHCP客户端和服务端交互示意图">
<ul>
<li><h4 id="为何选用UDP"><a href="#为何选用UDP" class="headerlink" title="为何选用UDP"></a>为何选用UDP</h4><ul>
<li>TCP延迟大，UDP效率高</li>
<li>一开始Client并没有IP地址，无法与服务端建立连接，只能通过UDP广播的形式与服务端通信</li>
<li>分配IP的去求对丢包和可靠传输的要求不高。</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="IPv4地址耗尽的解决措施"><a href="#IPv4地址耗尽的解决措施" class="headerlink" title="IPv4地址耗尽的解决措施"></a>IPv4地址耗尽的解决措施</h3><ul>
<li>VLSM / CIDR IPv4</li>
<li>DHCP</li>
<li>NAT</li>
<li>IPv6</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="NAT-Network-Address-Translation-网络地址转换"><a href="#NAT-Network-Address-Translation-网络地址转换" class="headerlink" title="NAT (Network Address Translation, 网络地址转换)"></a>NAT (Network Address Translation, 网络地址转换)</h2><ul>
<li>NAT是在共有IP地址和私有IP地址之间进行转换的技术</li>
<li>NAT中的每个外网端口号对应内网主机当中的一个进程 =&gt; <strong>使得一个IP的资源被充分的利用</strong></li>
</ul>
</blockquote>
<img src="/img/computer_network/computer_network_56.png" title="NAT工作示意图">
<ul>
<li><p>对于从 <strong>内网流出的数据包</strong>，将其 <strong>源IP地址和端口号</strong> 从私有的IP地址和端口号 <strong>替换成公网的IP地址和端口号</strong></p>
</li>
<li><p>将内网IP、端口与外网IP、端口的 <strong>映射关系</strong>，保存在 <strong>NAT table</strong> 当中</p>
</li>
<li><p>对于从 <strong>外网流入的数据包</strong>，参照 <strong>NAT Table</strong>，将 <strong>目的IP地址和端口号</strong> 替换成私有的IP和端口</p>
</li>
</ul>
<blockquote>
<h2 id="ICPM-Internet-Control-Message-Protocol-互联网控制消息协议"><a href="#ICPM-Internet-Control-Message-Protocol-互联网控制消息协议" class="headerlink" title="ICPM (Internet Control Message Protocol, 互联网控制消息协议)"></a>ICPM (Internet Control Message Protocol, 互联网控制消息协议)</h2></blockquote>
<img src="/img/computer_network/computer_network_57.png" title="ICMP消息类型">
<ul>
<li>报告差错 =&gt; 用于在IP主机路由器之间传递控制消息（主机通否？主机可达否？路由可用否？）</li>
<li>ping</li>
</ul>
<blockquote>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><ul>
<li>IP地址扩容</li>
<li>提供区分服务</li>
<li>减少路由器的工作，提高效率 =&gt; <strong>IPv6</strong> 有分片机制，但是在基本首部中是不支持的，在扩展首部中可以支持。但 <strong>规定之只能在端系统中进行分片和重组</strong>，路由器不可操作扩展首部（除了逐跳选项）</li>
</ul>
</blockquote>
<ul>
<li><h3 id="制定IPv6协议的动机"><a href="#制定IPv6协议的动机" class="headerlink" title="制定IPv6协议的动机"></a>制定IPv6协议的动机</h3><ul>
<li><strong>32位的IPv4地址不够用</strong> =&gt; 这是最主要的动机</li>
<li>IPv6首部的格式有利于提高转发和处理速率</li>
<li>IPv6首部的变化，提高了Qos</li>
</ul>
</li>
<li><h3 id="IPv6-datagram-format"><a href="#IPv6-datagram-format" class="headerlink" title="IPv6 datagram format"></a>IPv6 datagram format</h3><blockquote>
<ul>
<li>首部长度固定为40 bits (基本首部)</li>
<li>路由器上不允许进行分片</li>
</ul>
</blockquote>
<ul>
<li><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol>
<li>IPv6吧IP地址的长度增加到了16个字节</li>
<li>IPv6简化了IP Datagram的首部格式 =&gt; 字段数减少了，且基本首部的长度是固定的</li>
<li>IPv6增强了对进一步扩展的支持 =&gt; 将IPv4首部中Options项移到了扩展首部当中</li>
<li>IPv6增强了对Qos（Quality of Service）的支持</li>
<li>IPv6增强了对安全的支持</li>
<li>IPv6增加了对Anycast通信方式的支持</li>
</ol>
</li>
<li><h4 id="IPv6数据报的一般格式"><a href="#IPv6数据报的一般格式" class="headerlink" title="IPv6数据报的一般格式"></a>IPv6数据报的一般格式</h4><img src="/img/computer_network/computer_network_59.png" title="IPv6数据报的一般格式">
</li>
<li><h4 id="IPv6数据报的首部"><a href="#IPv6数据报的首部" class="headerlink" title="IPv6数据报的首部"></a>IPv6数据报的首部</h4><ul>
<li><strong>长度固定为40个字节</strong>，称为基本首部</li>
<li><strong>取消不必要的功能</strong>，字段个数减为8</li>
<li><strong>取消Header checksum</strong> 加快了路由器处理数据报的速度</li>
<li><strong>支持扩展首部</strong>（分片、逐跳选项、路由选择…） =&gt; <strong>数据报途中经过的路由器都不处理这些扩展首部</strong>（除了逐跳选项），这 <strong>大大提高了路由器的处理效率</strong></li>
<li>有效载荷（payload）= 扩展首部 + 数据</li>
<li>地址长度扩展为128位</li>
</ul>
</li>
<li><h4 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h4><img src="/img/computer_network/computer_network_58.png" title="IPv6数据报格式">
</li>
<li><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><ul>
<li>记法：采 <strong>冒号十六进制记法</strong>，支持零压缩</li>
<li>IPv6支持：<strong>单播、组播、任播</strong>（目的站是一组计算机，但数据报在交付的时候只交付其中的一个，通常是距离最近的一个）</li>
</ul>
</li>
<li><h4 id="IPv4映射的IPv6地址"><a href="#IPv4映射的IPv6地址" class="headerlink" title="IPv4映射的IPv6地址"></a>IPv4映射的IPv6地址</h4><img src="/img/computer_network/computer_network_60.png" title="IPv4映射的IPv6地址">
</li>
</ul>
</li>
<li><h3 id="IPv6相较于IPv4的变化"><a href="#IPv6相较于IPv4的变化" class="headerlink" title="IPv6相较于IPv4的变化"></a>IPv6相较于IPv4的变化</h3><ul>
<li>IPv6首部长度固定为40字节，而IPv4的默认为20，可以由options</li>
<li>IPv6基本首部中没有分片字段，移动到了扩展首部中（而且IPv6的分片和重组只能在终端上运行）</li>
<li>IPv6没有首部Checksum =&gt; <strong>简化路由器的工作，提高效率</strong></li>
<li>IPv6地址长度为128位，而IPv4为32位</li>
<li>IPv6支持任播，而IPv4不支持</li>
<li>IPv6首部字段减少，提高了路由器的处理效率</li>
</ul>
</li>
<li><h3 id="ICMPv6"><a href="#ICMPv6" class="headerlink" title="ICMPv6"></a>ICMPv6</h3><ul>
<li>差错报告报文</li>
<li>提供信息的报文</li>
<li>多播听众发现报文</li>
<li>邻端发现报文</li>
</ul>
</li>
<li><h3 id="IPv4向IPv6过渡的方案"><a href="#IPv4向IPv6过渡的方案" class="headerlink" title="IPv4向IPv6过渡的方案"></a>IPv4向IPv6过渡的方案</h3><ul>
<li>双协议栈——Dual IP Layer/Dualo Stack =&gt; <strong>在主机和路由器上同时实现IPv4和IPv6两种协议</strong></li>
<li>隧道技术（<strong><em>Tunneling</em></strong>）：把IPv6分组封装在IPv4分组当中传送 =&gt; <strong>把IPv6 datagram 整体作为数据封装在IPv4 datagram 中进行传送</strong></li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Routing-algorithms-（路由算法）"><a href="#Routing-algorithms-（路由算法）" class="headerlink" title="Routing algorithms （路由算法）"></a>Routing algorithms （路由算法）</h2><ul>
<li><strong>Routing</strong> =&gt; 确定一条从源端到目的端的一条路径的过程（不一定是最短的）</li>
<li><strong>global routing algorithms</strong> =&gt; 集中式路由算法</li>
<li><strong>decentralized routing algorithms</strong> =&gt; 分散式路由算法</li>
</ul>
</blockquote>
<ul>
<li><h3 id="The-Link-State-LS-Routing-Algorithms"><a href="#The-Link-State-LS-Routing-Algorithms" class="headerlink" title="The Link-State (LS) Routing Algorithms"></a>The Link-State (LS) Routing Algorithms</h3><blockquote>
<ul>
<li>链路状态路由算法（<strong>集中式</strong>）</li>
<li>采用Dijstra算法求最短路径</li>
</ul>
</blockquote>
<ul>
<li><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><ul>
<li><strong>u</strong> =&gt; 源端</li>
<li><strong>N’</strong> =&gt; 一个包含所有到源端最短路径已知的点的集合</li>
<li><strong>C(x, y)</strong> =&gt; x, y之间的link-cost</li>
<li><strong>D(v)</strong> =&gt; 节点v到源端的距离，不可达则为∞</li>
<li><strong>P(v)</strong> =&gt; 节点v到源端路径的前向节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Initiazation:</span><br><span class="line">  N' = &#123;u&#125;</span><br><span class="line">  <span class="keyword">for</span> all nodes v</span><br><span class="line">    <span class="keyword">if</span> v adjacent to u</span><br><span class="line">      then D(v) = C(u, v)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      D(v) = ∞</span><br><span class="line"></span><br><span class="line">Loop</span><br><span class="line">  find w <span class="keyword">not</span> in N' such that D(w) is a minimum, add to N'</span><br><span class="line">  update D(v) <span class="keyword">for</span> all v adjacent to w</span><br><span class="line">    D(v) = min&#123;D(v), D(w) + C(w, v)&#125;</span><br><span class="line">Until all nodes in N'</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h4><img src="/img/computer_network/computer_network_61.png" title="一个链路运行链路状态路由算法的栗子">
</li>
<li><h4 id="运行链路状态路由算法得到的结果"><a href="#运行链路状态路由算法得到的结果" class="headerlink" title="运行链路状态路由算法得到的结果"></a>运行链路状态路由算法得到的结果</h4><img src="/img/computer_network/computer_network_62.png" title="运行链路状态路由算法得到的结果">
<ul>
<li><strong>得到一颗最小生成树</strong></li>
<li><strong>得到一张转发表</strong></li>
</ul>
</li>
<li><p>在LS路由算法中，为了获取所有节点的Link-cost，有一个 <strong>链路状态广播</strong>（利用洪泛获取link-cost信息） 的过程，开销相对较大</p>
</li>
</ul>
</li>
<li><h3 id="The-Distance-Vector-DV-Routing-Algorithms"><a href="#The-Distance-Vector-DV-Routing-Algorithms" class="headerlink" title="The Distance-Vector(DV) Routing Algorithms"></a>The Distance-Vector(DV) Routing Algorithms</h3><blockquote>
<ul>
<li>链路状态路由算法（分散式）</li>
<li>利用的是动态规划的思想</li>
</ul>
</blockquote>
<ul>
<li><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><ul>
<li><strong>Dx(y)</strong> =&gt; x到y的最短路径的link-cost</li>
<li><strong>Dx(y) = MINv{C(x, v) + Dv(y)}</strong> =&gt; 其中，v为x的所有邻居</li>
</ul>
<p>对于每个节点x，运行如下路由算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Initialization:</span><br><span class="line">  <span class="keyword">for</span> all destinations y in N:</span><br><span class="line">    Dx(y) = C(x, y)   <span class="comment">//如果是x的邻居则有值，否则为 ∞</span></span><br><span class="line">  <span class="keyword">for</span> each neighbor w:</span><br><span class="line">    <span class="comment">//一开始不知道邻居到其它节点的Link-cost</span></span><br><span class="line">    Dx(y) = ? <span class="keyword">for</span> all desrinations y in N</span><br><span class="line">  <span class="keyword">for</span> each neighbor w:</span><br><span class="line">    <span class="comment">//向自己的邻居节点发送自己已知的距离向量</span></span><br><span class="line">    send distance <span class="built_in">vector</span> Dx = [Dx(y): y in N] to w、</span><br><span class="line"></span><br><span class="line">Loop</span><br><span class="line">  <span class="comment">//等待自己到邻居的link-cost改变，或者收到邻居发给自己的距离向量</span></span><br><span class="line">  wait (until I see a link cost change to some neighbor w <span class="keyword">or</span></span><br><span class="line">    until I receive a distance <span class="built_in">vector</span> from some neighbor w)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> each y in N:</span><br><span class="line">    Dx(y) = MINv&#123;C(x, v) + Dv(y)&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果自己到任一节点的link-cost发生变化，向所有的邻居发送距离向量</span></span><br><span class="line">  <span class="keyword">if</span> Dx(y) change <span class="keyword">for</span> any destination y:</span><br><span class="line">    send distance <span class="built_in">vector</span> Dx = [Dx(y): y in N] to all neighbors</span><br><span class="line">forever</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="伪代码说明"><a href="#伪代码说明" class="headerlink" title="伪代码说明"></a>伪代码说明</h4><ul>
<li>每个节点在本地保存自己的距离向量和所有邻居节点的距离向量</li>
<li>一旦自己到邻居的link-cost变化或者收到邻居发的距离向量，则重新计算自己的距离向量，如果有变化就发给所有的邻居。</li>
</ul>
</li>
<li><h4 id="Link-cost-change"><a href="#Link-cost-change" class="headerlink" title="Link-cost change:"></a>Link-cost change:</h4><ul>
<li>good news travels fast =&gt; 当某个 link-cost 减小，网络很快趋于稳定（收敛）</li>
<li>bad news travels slow =&gt; 当某个 link-cost 增大，需要经过很多次迭代才收敛（存在计数到无穷问题）</li>
</ul>
</li>
<li><h4 id="poison-reverse-毒性反转"><a href="#poison-reverse-毒性反转" class="headerlink" title="poison reverse(毒性反转)"></a>poison reverse(毒性反转)</h4><p>当RouterA发现与RouterX的连接断开，并准备向邻居节点发送新的距离向量的时候，并不是忽略它，而是将到他的路径毒化，设置其跳数为最大跳数加1，即不可到达。让其他节点尽快知道RouterX已经不可经由RouterA到达了，加快网络的收敛速度。</p>
</li>
</ul>
</li>
<li><h3 id="DV-vs-LS"><a href="#DV-vs-LS" class="headerlink" title="DV vs LS"></a>DV vs LS</h3><ul>
<li>Message Complexity（报文复杂性）<ul>
<li>LS: n个node，E跳link，需发送O(nE)个messages</li>
<li>DV: 只在相邻节点间传递消息</li>
</ul>
</li>
<li>收敛速度<ul>
<li>LS: 固定，要求发送O(nE)个messages =&gt; 可能存在震荡</li>
<li>DV: 收敛时间变化不定 =&gt; 环路问题，计数到无穷问题</li>
</ul>
</li>
<li>健壮性<ul>
<li>LS: 节点<strong>可能通告不正确的链路费用</strong> ；每个节点仅计算自己的表</li>
<li>DV: 节点<strong>可能通告不正确的路径信息</strong> ；每个节点的表都由他人使用 =&gt; 差错通过网络进行传播</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">Distance Vector</th>
<th style="text-align:center">Link State</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">仅与邻居节点交换消息</td>
<td style="text-align:center">向网络上所有其他节点广播消息</td>
</tr>
<tr>
<td style="text-align:center">消息包括到所有节点的最短距离</td>
<td style="text-align:center">消息仅包括到邻居节点的距离</td>
</tr>
<tr>
<td style="text-align:center">收敛速度比较慢</td>
<td style="text-align:center">收敛速度比较快</td>
</tr>
<tr>
<td style="text-align:center">会广播不正确的路径信息</td>
<td style="text-align:center">会广播不正确的链路信息</td>
</tr>
<tr>
<td style="text-align:center">有计数到无穷（Count to Infinity Problem）问题</td>
<td style="text-align:center">没有计数到无穷（Count to Infinity Problem）问题</td>
</tr>
</tbody>
</table>
<ul>
<li><h3 id="Hierarchical-Routing（分层式路由）"><a href="#Hierarchical-Routing（分层式路由）" class="headerlink" title="Hierarchical Routing（分层式路由）"></a>Hierarchical Routing（分层式路由）</h3><ul>
<li>Intra-AS routing algorithms =&gt; <strong>自治系统内部路由算法</strong></li>
<li>Inter-AS routing algorithms =&gt; <strong>自治系统间路由算法</strong>（只传递可达性信息）</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Routing-in-the-Internet"><a href="#Routing-in-the-Internet" class="headerlink" title="Routing in the Internet"></a>Routing in the Internet</h2><ul>
<li><strong>内部网关协议</strong>(<strong><em>IGP</em></strong>) =&gt; 自治系统内部路由协议的总称<ul>
<li>RIP</li>
<li>OSPF</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><ul>
<li><strong>基于UDP</strong>，且RIP为应用层协议（RIP的报文封装在UDP数据报中发送，故RIP为应用层协议）=&gt; 值得注意的是，<strong>路由器应该有应用层和传输层</strong>，否则无法运行路由协议。但是在转发数据包的时候不使用传输层和应用层的功能</li>
<li><strong>采用距离向量路由算法</strong>（DV算法）=&gt; 以跳数作为距离指标，并且将跳数限制在15跳以内</li>
<li><strong>RIP跳数</strong> =&gt; 从当前节点到目的节点所穿越的子网个数，包含目的子网（最小为1）</li>
<li><strong>RIP协议的最大跳数为15</strong></li>
<li><strong>每30s更新一次，如果180s未收到某个邻居节点的向量表，则认为其已经断开</strong>（采用毒性反转之后，如果收到某个邻居节点的向量表中包含某个跳数大于RIP的最大跳数，就认为那条路径断开，而不用等待180s）</li>
<li><h4 id="转发表示例"><a href="#转发表示例" class="headerlink" title="转发表示例"></a>转发表示例</h4><img src="/img/computer_network/computer_network_63.png" title="RIP转发表示例">
</li>
</ul>
</li>
<li><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><ul>
<li>读书路由协议属于应用层，而 <strong>OSPF</strong> 不是，它 <strong>是传输层协议</strong>。它在IP之上却没有使用其他传输层协议</li>
<li><strong>采用的是链路状态路由算法</strong>（LS算法）</li>
</ul>
</li>
<li><h3 id="BGP-边界网关协议"><a href="#BGP-边界网关协议" class="headerlink" title="BGP(边界网关协议)"></a>BGP(边界网关协议)</h3><ul>
<li>自治系统间的路由协议</li>
<li>基于TCP</li>
<li>主要传递可达性信息</li>
</ul>
</li>
<li><h3 id="静态路由表的计算-（！！！圈重点）"><a href="#静态路由表的计算-（！！！圈重点）" class="headerlink" title="静态路由表的计算 （！！！圈重点）"></a>静态路由表的计算 （！！！圈重点）</h3><ul>
<li><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><img src="/img/computer_network/computer_network_64.png" title="静态路由表栗子题目"></li>
<li><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><img src="/img/computer_network/computer_network_65.png" title="静态路由表栗子解答"></li>
</ul>
</li>
<li><h3 id="单播、组播、广播、任播"><a href="#单播、组播、广播、任播" class="headerlink" title="单播、组播、广播、任播"></a>单播、组播、广播、任播</h3><ul>
<li>单播：一对一，只有一个接收端</li>
<li>组播：一对一组 =&gt; 组内成员可以来自不同的子网，接收端是组内的所有成员</li>
<li><p>广播：一对所有 =&gt; 默认是在某个子网内部，不能穿越路由器</p>
</li>
<li><p>共性：一个发送端</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Brodcast-and-multicast-routing"><a href="#Brodcast-and-multicast-routing" class="headerlink" title="Brodcast and multicast routing"></a>Brodcast and multicast routing</h2><p><strong>实现广播的两种复制数据的方式</strong></p>
<ul>
<li>Source-duplication =&gt; <strong>源端复制</strong>（效率很低）</li>
<li>In-network duplication =&gt; <strong>网内复制</strong>（会有洪泛问题）</li>
</ul>
</blockquote>
<ul>
<li><h3 id="Uncontrolled-Flooding（不可控洪泛）"><a href="#Uncontrolled-Flooding（不可控洪泛）" class="headerlink" title="Uncontrolled Flooding（不可控洪泛）"></a>Uncontrolled Flooding（不可控洪泛）</h3><p>When node receives broadcast packet, sends copy to all neighbors</p>
<p><strong>当收到某个邻居的广播报文时，无条件地转播给其它所有的邻居</strong></p>
<p>=&gt; 如果有网络有回路存在，就会导致“广播风暴”</p>
</li>
<li><h3 id="Controlled-Flooding（可控洪泛）"><a href="#Controlled-Flooding（可控洪泛）" class="headerlink" title="Controlled Flooding（可控洪泛）"></a>Controlled Flooding（可控洪泛）</h3><ul>
<li><h4 id="Sequence-number-controlled-flooding-（序列号可控洪泛）"><a href="#Sequence-number-controlled-flooding-（序列号可控洪泛）" class="headerlink" title="Sequence-number-controlled flooding （序列号可控洪泛）"></a>Sequence-number-controlled flooding （序列号可控洪泛）</h4><p>给每个数据包都加上一个序列号，当再次收到一个序列号相同的数据包的时候不再转发给邻居</p>
<p>=&gt; 可以避免“广播风暴”，但是不能完全解决冗余数据包的问题</p>
</li>
<li><h4 id="Reverse-path-forwarding-RPF-反向路径转发"><a href="#Reverse-path-forwarding-RPF-反向路径转发" class="headerlink" title="Reverse path forwarding (RPF, 反向路径转发)"></a>Reverse path forwarding (RPF, 反向路径转发)</h4><ul>
<li>依赖于路由器知道自己与发送端的一条最短路径</li>
<li>当收到一个数据包的时候<ul>
<li><strong>先创建一个从自己到源端的最短路径</strong></li>
<li>如果发送这个 <strong>数据包的节点在该路径上</strong>，<strong>则将其转发给所有的邻居</strong>，否则不转发</li>
</ul>
</li>
<li>可以避免 <strong>广播风暴</strong>，但是仍然存在冗余数据包问题</li>
</ul>
</li>
<li><h4 id="利用生成树进行广播"><a href="#利用生成树进行广播" class="headerlink" title="利用生成树进行广播"></a>利用生成树进行广播</h4><p>生成树构建好之后，路由器收到一个广播数据包，只转发向包含于生成树的路径转发数据包</p>
<p>=&gt; 没有冗余数据包，也可以避免广播风暴</p>
</li>
</ul>
</li>
<li><h3 id="用于组播的协议"><a href="#用于组播的协议" class="headerlink" title="用于组播的协议"></a>用于组播的协议</h3><ul>
<li>Distance-Vector Multicast Routing Protocol(DVMRP)</li>
<li>Protocol-Independent Multicast(PIM) routinh protocol</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2018/05/09/computer_networking_03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/09/computer_networking_03/" class="post-title-link" itemprop="url">Chapter 3 Transport Layer</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-09 18:00:00" itemprop="dateCreated datePublished" datetime="2018-05-09T18:00:00+08:00">2018-05-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-20 10:55:18" itemprop="dateModified" datetime="2019-04-20T10:55:18+08:00">2019-04-20</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="Introduction-of-Transport-Layer-Servicers-（传输层提供的服务）"><a href="#Introduction-of-Transport-Layer-Servicers-（传输层提供的服务）" class="headerlink" title="Introduction of Transport-Layer Servicers （传输层提供的服务）"></a>Introduction of Transport-Layer Servicers （传输层提供的服务）</h2><ul>
<li>传输层将网络层所提供的主机到主机之间的 <strong>逻辑通信</strong>（<strong><em>logical comminication</em></strong>）扩展为进程到进程间的通信 =&gt; <strong>!!最主要的的功能</strong></li>
<li><strong>传输层只在端系统（end systems / hosts）中才有</strong>，在路由器和二层交换机上没有</li>
<li>Inetnet的传输层协议：<strong>TCP、UDP</strong></li>
</ul>
</blockquote>
<ul>
<li><h3 id="传输层-VS-网络层"><a href="#传输层-VS-网络层" class="headerlink" title="传输层 VS 网络层"></a>传输层 VS 网络层</h3><ul>
<li><p><strong>网络层</strong> 完成的是 <strong>主机到主机</strong> 之间的逻辑通信， <strong>传输层</strong> 完成的是不同主机间 <strong>进程到进程</strong> 的逻辑通信 =&gt; 可以说，<strong>传输层扩展了网络层的配送域</strong></p>
<p>PS: 并不是说传输层可以单独完成不同主机间进程到进程通信，肯定是要基于网络层及之下各层所提供服务的支持。但是以应用进程的视角来看，确实它只要把通信的消息传给传输层，传输层会帮他把消息投递到目的主机的传输层，目的主机进程就从它的传输层中获取消息。</p>
</li>
<li><p><strong>网络层提供的是不可靠的传输</strong>（<strong><em>best-effort delivery service</em></strong>）， 而 <strong>传输层可以</strong> 在网络层不可靠的基础上引入一些可靠数据传输的机制，来向上 <strong>提供可靠的传输</strong>（如：TCP）</p>
</li>
<li><p>网络层和传输层都不能提供最短延迟和最小带宽的保障</p>
</li>
</ul>
</li>
<li><h3 id="Internet-传输层协议"><a href="#Internet-传输层协议" class="headerlink" title="Internet 传输层协议"></a>Internet 传输层协议</h3><ul>
<li><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul>
<li>可靠数据传输 （<strong><em>reliable data transfer</em></strong>）</li>
<li>保证数据有序分发</li>
<li>拥塞控制（<strong><em>congestion control</em></strong>）</li>
<li>流量控制（<strong><em>flow control</em></strong>）</li>
</ul>
</li>
<li><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul>
<li>不可靠</li>
<li>无序分发</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Multiplexing-and-DeMultiplexing-（分解与复用）"><a href="#Multiplexing-and-DeMultiplexing-（分解与复用）" class="headerlink" title="Multiplexing and DeMultiplexing （分解与复用）"></a>Multiplexing and DeMultiplexing （分解与复用）</h2><p>传输层通过复用收集各进程的消息，通过分解将消息分发给各个进程</p>
</blockquote>
<ul>
<li>各层的PDU（某一层协议所处理的最小数据单元）<img src="/img/computer_network/computer_network_01.jpg" title="五层网络协议栈模型"></li>
<li>Socket 是数据穿梭于网络进程和网络之间的大门，同时也就是传输层和进程之间的门户。与传输层直接通信的其实是进程中的Socket（一个进程可以由多个Socket）</li>
<li><h3 id="Demultiplexing（分解）"><a href="#Demultiplexing（分解）" class="headerlink" title="Demultiplexing（分解）"></a>Demultiplexing（分解）</h3>传输层将收到的网络层投递给它的Segments，去除传输层头部，分发给正确的Socket</li>
<li><h3 id="Multiplexing（复用）"><a href="#Multiplexing（复用）" class="headerlink" title="Multiplexing（复用）"></a>Multiplexing（复用）</h3><p>传输层收集来自各个Socket的message，并加上传输层头部，生产Segment，再交由网络层</p>
</li>
<li><p>每个Socket对应于一个端口号，传输层在分发Segments的时候通过目的端端口号判断应该分发给哪个Socket</p>
</li>
<li><h3 id="UDP-的-Multiplexing-and-DeMultiplexing"><a href="#UDP-的-Multiplexing-and-DeMultiplexing" class="headerlink" title="UDP 的 Multiplexing and DeMultiplexing"></a>UDP 的 Multiplexing and DeMultiplexing</h3><ul>
<li>一个 <strong>UDP Socket</strong> 由一个二元组唯一标识（目的IP，目的端口号）</li>
<li>UDP协议在分发的时候就根据上面提到的二元组分发Segment给对应的Socket（实际上是去除传输层头部，然后将里面的Message发送给Socket）</li>
<li><strong>来自不同IP、端口（源IP，源端口），但是目的IP和端口号一致的Segment会被分发给同一个Socket</strong></li>
</ul>
</li>
<li><h3 id="TCP-的-Multiplexing-and-DeMultiplexing"><a href="#TCP-的-Multiplexing-and-DeMultiplexing" class="headerlink" title="TCP 的 Multiplexing and DeMultiplexing"></a>TCP 的 Multiplexing and DeMultiplexing</h3><ul>
<li>一个 <strong>TCP Socket</strong> 有一个四元组唯一标识（源IP，源端口号，目的IP，目的端口号）</li>
<li>TCP协议在分发的时候就根据标识TCP Socket的四元组来分发Segments</li>
<li><strong>来自不同IP、端口（源IP，源端口）的Segment会被分发给不同的Socket</strong></li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Connectionless-Transport-UDP-（无连接的传输层协议）——UDP）"><a href="#Connectionless-Transport-UDP-（无连接的传输层协议）——UDP）" class="headerlink" title="Connectionless Transport: UDP （无连接的传输层协议）——UDP）"></a>Connectionless Transport: UDP （无连接的传输层协议）——UDP）</h2><ul>
<li>UDP（User Datagram Protocol, 用户数据报协议）</li>
<li>基于UDP的应用层协议：SNMP、RIP、DNS、NFS</li>
</ul>
</blockquote>
<ul>
<li><h3 id="为什么需要UDP？"><a href="#为什么需要UDP？" class="headerlink" title="为什么需要UDP？"></a>为什么需要UDP？</h3><ul>
<li>UDP <strong>不需要建立连接</strong> （少了建立连接的开销以及带来的时延）</li>
<li><strong>实现简单</strong> =&gt; 发送者与接受者之间由于是无连接的，所以不需要保存连接状态信息</li>
<li><strong>没有拥塞控制</strong> =&gt; 不限速</li>
<li><strong>UDP头部较小</strong>（<strong><em>Small packet header overhead</em></strong>）=&gt; UDP由于需要实现的功能较少，头部的字段也比较少，只需要8 byte</li>
</ul>
</li>
<li><h3 id="UDP的应用场景"><a href="#UDP的应用场景" class="headerlink" title="UDP的应用场景"></a>UDP的应用场景</h3><ul>
<li>多媒体（在线视频）</li>
<li>具有重复性操作的场合（如：DNS）</li>
<li>一对多通信的场景</li>
</ul>
<img src="/img/computer_network/computer_network_21.png" title="常见应用层协议所用的传输层协议"></li>
<li><h3 id="UDP所提供的服务"><a href="#UDP所提供的服务" class="headerlink" title="UDP所提供的服务"></a>UDP所提供的服务</h3><ul>
<li>传输层将网络层所提供的 <strong>主机到主机</strong> 之间的逻辑通信 <strong>扩展到进程到进程</strong> 间的逻辑通信</li>
<li><strong>校验和</strong>（<strong><em>Checksum</em></strong>）</li>
</ul>
</li>
<li><h3 id="UDP-Segment-Structure"><a href="#UDP-Segment-Structure" class="headerlink" title="UDP Segment Structure"></a>UDP Segment Structure</h3><img src="/img/computer_network/computer_network_23.png" title="UDP Segment Structure">
<ul>
<li><strong>首部</strong> 只有四个字段，<strong>只占8 bits</strong> 结构异常简单</li>
<li><strong>Length指的是整个Segment的长度</strong>，包括数据域，以字节为单位</li>
<li><strong>UDP的Checksum只能检错，不能纠错</strong></li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Principles-of-Reliable-Data-Transfer（可靠数据传输原理）"><a href="#Principles-of-Reliable-Data-Transfer（可靠数据传输原理）" class="headerlink" title="Principles of Reliable Data Transfer（可靠数据传输原理）"></a>Principles of Reliable Data Transfer（可靠数据传输原理）</h2><ul>
<li><strong>校验和</strong> =&gt; 检验比特差错</li>
<li><strong>ACK反馈</strong></li>
<li><strong>序列号</strong> =&gt; 解决冗余数据包问题（冗余数据包指的是接收端会收到一个数据包的多份拷贝）</li>
<li><strong>定时器超时重传</strong> =&gt; 解决丢包问题</li>
<li><strong>重传</strong></li>
</ul>
</blockquote>
<img src="/img/computer_network/computer_network_24.png" title="传输层实现可靠数据传输示意图">
<ul>
<li><h3 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h3>=&gt; <strong>假设信道完全可靠，无丢包，无比特差错</strong><img src="/img/computer_network/computer_network_25.png" title="rdt1.0协议有限状态机示意图">
<ul>
<li>发送端传输层只要完成从应用层接收message，打包（给message加上传输层头部，构建Segment），并发送给可靠信道进行传输。而接收端传输层只需要从信道获取Segment，解包，然后分发给对应的Socket即可</li>
</ul>
</li>
<li><h3 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h3><p>=&gt; <strong>假设信道无丢包，但是有可能发生比特差错</strong><br>=&gt; rdt2.0是一个典型的 <strong>ARQ协议</strong>，也是一种<strong>停等协议</strong>（<strong><em>stop-and-wait protocol</em></strong>）</p>
<img src="/img/computer_network/computer_network_26.png" title="rdt2.0协议有限状态机示意图">
<ul>
<li><h4 id="ARQ-Automatic-Repeat-reQuest-protocols"><a href="#ARQ-Automatic-Repeat-reQuest-protocols" class="headerlink" title="ARQ (Automatic Repeat reQuest) protocols"></a>ARQ (Automatic Repeat reQuest) protocols</h4><p><strong><em>In a computer network setting, reliable data transfer protocols based on such retransmission are known as ARQ prorocols</em></strong></p>
<p>在计算机网络中，<strong>基于重传的可靠数据传输协议</strong>，我们称之为ARQ协议</p>
<ul>
<li><strong>ARQ协议的要求：</strong><ul>
<li>Error detection（错误检测）</li>
<li>Receiver feedback（接收反馈）</li>
<li>Retransmission（重传）</li>
</ul>
</li>
<li><strong>rdt2.0 协议就是一种ARQ协议</strong></li>
</ul>
</li>
<li><h4 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h4><ul>
<li>从上层应用层获取消息，打包，发送到信道传输。接着进入等待状态，<strong>等待接收端的ACK/NAK</strong>。</li>
<li>如果收到ACK，则表示接收端收到了正确无误的数据包，状态切换回等待消息的状态，如果有消息就继续发送，如果没有，则等待应用层的消息</li>
<li>如果收到NAK，则表示接收端收到了数据包，但是数据包 <strong>发生了比特差错，则重传</strong>之前发送的数据包</li>
</ul>
</li>
<li><h4 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h4><ul>
<li>接收端从下层接收到数据包之后进行校验，如果 <strong>发生比特差错</strong>，则 <strong>向发送端发送一个NAK并丢弃该数据包</strong></li>
<li>如果 <strong>没有发生比特差错</strong>，则解包后 <strong>传递给上层</strong>，并<strong>向发送端发送一个ACK</strong></li>
</ul>
</li>
<li><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4>如果当<strong>接收端返回的ACK/NAK也发生了比特差错</strong>时，发送端并不知道此次发送是否成功，那么它该作何处理？<ul>
<li><h5 id="思路一：xxx-gt-你说什么？-gt-你说什么？-gt-你说什么？-gt-…"><a href="#思路一：xxx-gt-你说什么？-gt-你说什么？-gt-你说什么？-gt-…" class="headerlink" title="思路一：xxx -&gt; 你说什么？-&gt; 你说什么？-&gt; 你说什么？-&gt; …"></a>思路一：xxx -&gt; 你说什么？-&gt; 你说什么？-&gt; 你说什么？-&gt; …</h5>简单粗暴，接收端收到一个回复不知道是ACK还是NAK就再次询问客户端到底有没有正确接收。怕不是要打起来一会儿。。。</li>
<li><h5 id="思路二：引入比特校准机制"><a href="#思路二：引入比特校准机制" class="headerlink" title="思路二：引入比特校准机制"></a>思路二：引入比特校准机制</h5>添加最够的Checksum，让其既具备检错功能，也具备纠错功能。这要求信道传输数据包的时候不能丢失（在rdt2.0的假设中是具备的，但是实际中是会发生丢包的），而且可能因为要兼具纠错功能，Checksum会很长</li>
<li><h5 id="思路三：瞎几把重传"><a href="#思路三：瞎几把重传" class="headerlink" title="思路三：瞎几把重传"></a>思路三：瞎几把重传</h5>一旦发送端收到的回复发生比特差错，无法判断的时候，就直接重传。这是一个稍微可行的方案，但是由于在无法判断传输是否成功的情况就重传，客户端可能会收到一个数据包的多个拷贝(<strong>产生冗余数据包（duplicate packets）问题</strong>)，这个时候客户端就不知道该如何判断服务器发过来的是一个没有接收过的数据包还是一个冗余的数据包 =&gt;</li>
</ul>
</li>
<li><h4 id="解决冗余数据包问题-gt-引入序列号-sequence-number-机制"><a href="#解决冗余数据包问题-gt-引入序列号-sequence-number-机制" class="headerlink" title="解决冗余数据包问题 =&gt; 引入序列号 (sequence number) 机制"></a>解决冗余数据包问题 =&gt; 引入序列号 (<strong><em>sequence number</em></strong>) 机制</h4>发送端在发送数据包的头部多加一个Sequence number的字段，接收端在接收到一个数据包的时候将其序列号取出，与自己已经接收到的前一个数据包的序列号对比，就可以判断这个数据包是不是冗余的了。因为rdt2.0采用是一种停等协议的工作模式，所以用1 bit的序列号就可以解决这个问题</li>
</ul>
</li>
<li><h3 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h3><p>=&gt; 在rdt2.0的基础上采用上面思路三 + 引入序列号的方式解决了冗余数据包问题</p>
<p>=&gt; 还是采用了NAK + ACK的实现方案</p>
<img src="/img/computer_network/computer_network_27.png" title="rdt2.1 Sender">
<img src="/img/computer_network/computer_network_28.png" title="rdt2.1 Receiver"></li>
<li><h3 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h3><p>=&gt; 在rdt2.1的基础上，去除了NAK，收到错误数据包之后不发送NAK，而将最近一次成功接收到的数据包的ACK发送回去</p>
<p>=&gt; 这种方案就导致发送端可能接收到同一个数据包的多个ACK (<strong>冗余ACK，duplicate ACKs</strong>)</p>
<img src="/img/computer_network/computer_network_29.png" title="rdt2.2 Sender">
<img src="/img/computer_network/computer_network_30.png" title="rdt2.2 Receiver">
</li>
<li><h3 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h3><p>=&gt; <strong>假设信道可能丢包，但是有可能发生比特差错</strong></p>
<p>=&gt; 在rdt2.2的基础上，考虑丢包问题。</p>
<p>=&gt; <strong>定时器 + 超时重传 =&gt; 解决丢包问题</strong></p>
<img src="/img/computer_network/computer_network_31.png" title="rdt3.0 Sender">
<p>接收端FMS(finite-state machine, 有限状态机)图同rdt2.2</p>
</li>
<li><h3 id="Pipelined-Reliable-Data-Transfer-Protocols（流水线型可靠数据传输协议）"><a href="#Pipelined-Reliable-Data-Transfer-Protocols（流水线型可靠数据传输协议）" class="headerlink" title="Pipelined Reliable Data Transfer Protocols（流水线型可靠数据传输协议）"></a>Pipelined Reliable Data Transfer Protocols（流水线型可靠数据传输协议）</h3><img src="/img/computer_network/computer_network_32.png" title="停等协议与流水线型协议的对比">
rdt3.0其实已经是一个可用的协议了，但是采用停等协议大大限制了网络的传输性能（发送端必须接收到接收端返回的ACK才发送下一个数据包或者重传，增大了传输时延，降低了带宽利用率）。而相比之下，<strong><em>流水线型可靠数据传输协议</em></strong> <strong>允许已发送未确认的数据包可以有多个</strong><ul>
<li>Go-Back-N (回退N)</li>
<li>Selective repeat（选择重传）</li>
</ul>
</li>
<li><h3 id="Go-Back-N-GBN"><a href="#Go-Back-N-GBN" class="headerlink" title="Go-Back-N (GBN)"></a>Go-Back-N (GBN)</h3><p>回退N</p>
<blockquote>
<ul>
<li><strong>定时器超时</strong>，所有已发送未被确认的数据包都 <strong>重传</strong></li>
<li><strong>采用累积确认</strong>：收到ack=10，则表示序列号为10及之前的数据包都已正确接收，接收端下一个期望收到的数据包的序列号为11</li>
<li>接收端收到乱序的数据包直接丢弃</li>
</ul>
</blockquote>
<ul>
<li><h4 id="Go-Back-N滑动窗口"><a href="#Go-Back-N滑动窗口" class="headerlink" title="Go-Back-N滑动窗口"></a>Go-Back-N滑动窗口</h4><img src="/img/computer_network/computer_network_33.png" title="发送端视角看回退N的序列号窗口">
<ul>
<li><strong>base</strong> : 最早的发送却没有被确认的数据包的序列号</li>
<li><strong>nextseqnum</strong> : 最小的没有使用的序列号（实际上指的是发送下一个非重传数据包时所使用的序列号）</li>
<li><strong>N</strong> : 发送端序列号窗口的大小（限制发送端已发送未被确认数据包的数量，在流量控制的时候可以遏制发送端发包的速率）</li>
<li><strong>[base, nextseqnum - 1]</strong> : 已发送未被确认的数据包的序列号范围</li>
<li><strong>[0, base - 1]</strong> : 发送且已被确认的数据包的序列号</li>
<li><strong>[nextseqnum, base + N - 1]</strong> : 剩余可用的序列号范围（指的是该时刻在不溢出发送窗口大小N的情况下，可以继续使用的序列号）<blockquote>
<p>ps: 如果序列号的取值是以取模的方式循环使用，上面的范围划分就略有变动，但是意思是差不多的</p>
</blockquote>
</li>
</ul>
</li>
<li><h4 id="Go-Back-N-FSM-图"><a href="#Go-Back-N-FSM-图" class="headerlink" title="Go-Back-N FSM 图"></a>Go-Back-N FSM 图</h4><ul>
<li><h5 id="发送端-1"><a href="#发送端-1" class="headerlink" title="发送端"></a>发送端</h5><img src="/img/computer_network/computer_network_34.png" title="Go-Back-N发送端FSM图">
<ul>
<li><strong>上层的调用</strong>（<strong><em>Invocation from above</em></strong>）: 当上层调用rdt_send()发送数据包的时候，<strong>发送端检查发送窗口是否已满</strong>（即检查一发送未确认的数据包的个数是不是已经达到N了），如果满了就通知上层拒绝发送（接着上层肯能会一段时间后重试），没有满则生成一个Segment并发送</li>
<li><strong>收到一个ACK</strong>（Receipt of an ACK）: 发送端采用 <strong>累积确认</strong>（<strong><em>cumulative acknowledgment</em></strong>）的方式，例如：收到ack=10，则表示序列号为10及之前的数据包都已正确接收，接收端下一个期望收到的数据包的序列号为11</li>
<li><strong>超时事件</strong>（<strong><em>A timeout event</em></strong>）: 发送端开始发送数据包的时候回启动一个定时器，之后<strong>每收到一个ACK会检查是否还有已发送未确认的数据包</strong>。有则重启定时器，没有则停止定时器。<strong>一旦定时器超时，所有已发送但未确认的数据包都将被重传</strong>（最多重传N个）</li>
</ul>
</li>
<li><h5 id="接收端-1"><a href="#接收端-1" class="headerlink" title="接收端"></a>接收端</h5><img src="/img/computer_network/computer_network_35.png" title="Go-Back-N接收端FSM图">
<ul>
<li><strong>接收端收到</strong> 一个序列号为n的 <strong>有序的数据包</strong>（<strong><em>in-order packet</em></strong>, 表示接收端最近一次传递给上层的数据包的序列号为n-1），则给发送端回一个对应序列号的ACK，同时将数据包解包够传递给上层</li>
<li><strong>接收端收到错误的数据包</strong> 则 <strong>直接丢弃</strong></li>
<li><strong>接收端收到正确但乱序的数据包</strong>（就比如收到的数据包序列号为n，但是上一次传递给上层的数据包的序列号不是n-1），接收端的处理也是 <strong>直接丢弃</strong>。这虽然看起来很浪费，但却是比较明智的处理方式。试想，如果接收端收到一个序列号为n+1的数据包，但是上一次传递给上层的却是序列号为n-1的数据包，则很可能序列号为n的数据包在传输的过程中丢失了，那么必然导致发送端计时器超时，发送端会重发数据包为n和n+1的数据包，所以接收端完全没有必要缓存序列号为n+1的数据包（这样实现起来简单并且有效）。</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul>
<li>发送端既然采用的是累积确认，那么如果发送端收到一个对序列号为n的ACK，但是上次收到的是n-3的，对n-1和n-2的ACK可能丢失了。这个时候发送端不会理会那两个丢失的ACK。因为接收端是有序接收的，所以发送端收到对序列号为n的数据包的ACK就可以认为序列号为n以及比n小的数据包都已经成功被接收了</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="Selective-Repeat（SR）"><a href="#Selective-Repeat（SR）" class="headerlink" title="Selective Repeat（SR）"></a>Selective Repeat（SR）</h3><p>选择重传</p>
<img src="/img/computer_network/computer_network_36.png" title="选择重传（SR）发送方与接收方的序号空间">
<ul>
<li><h4 id="发送端-2"><a href="#发送端-2" class="headerlink" title="发送端"></a>发送端</h4><ul>
<li><strong>从上层收到数据</strong>（<strong><em>Data received from above</em></strong>）：当发送端接收到上层的数据时，<strong>获取下一个可用的序列号</strong>，如果该序列好在发送端序列号窗口内（表示当前窗口未满），则打包发送。如果不在序列号窗口内，则和GBN一样，发回给上层或缓存起来。</li>
<li><strong>超时</strong>（<strong><em>Timeout</em></strong>）：发送端会为每一个已发送未确认的数据包维护一个逻辑计时器，一旦某个计时器超时，就重发它所负责监视的那个数据包。</li>
<li><strong>收到ACK</strong>（<strong><em>ACK received</em></strong>）：<ul>
<li>收到的ACK所确认的数据包的序列号 <strong>落在滑动窗口内，则将其标记为已确认</strong></li>
<li>收到的ACK所确认的数据包的序列号 <strong>等于send_base</strong>（就是滑动窗口的第一个序列号），则 <strong>将滑动窗口右移至第一个未被确认的序列号处</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="接收端-2"><a href="#接收端-2" class="headerlink" title="接收端"></a>接收端</h4><ul>
<li>如果<strong>序列号在[recv_base, recv_base + N - 1]范围内被接收</strong>（也就是说收到的数据包在接收端的滑动窗口内）：向发送端 <strong>回一个对该序列号的ACK</strong>。<ul>
<li><strong>如果该序列号不等于recv_base</strong>，则将该序列号标记为已接收，将数据包缓存起来</li>
<li><strong>如果该序列号等于recv_base</strong>，则接收端 <strong>滑动窗口右移</strong>至第一个未标记的序列号处。并将刚才扫过的数据包（就是[old_recv_base, new_recv_base - 1]之间的数据包）一并上交给上层。</li>
</ul>
</li>
<li><p>如果<strong>序列号在[recv_base - N, recv_base - 1]范围内被接收</strong>（也就是说这个刚收到的数据包之前已经接收过并回复ACK了）：向发送端回一个该序列号的ACK</p>
<p>=&gt; 这个ACK看起来是多余的，其实是必须的。因为接收端将ACK发出之后就可能导致滑动窗口右移的操作。如果发送给发送端的ACK没有到达或者出错了，接收端在计时器超时之后就会重传，而这个时候发送端的窗口已经右移了。如果不再对这个数据包回复一个ACK，则导致发送端该序列号一直没有被确认，发送端就会不断重发这个数据包，而且滑动窗口也会停滞不前。</p>
</li>
<li><p><strong>其他情况</strong>（发生比特差错，收到右溢出滑动窗口的包等）：忽略这个数据包，直接丢弃</p>
</li>
</ul>
</li>
<li><h4 id="滑动窗口大小的问题"><a href="#滑动窗口大小的问题" class="headerlink" title="滑动窗口大小的问题"></a>滑动窗口大小的问题</h4><p>=&gt; <strong>滑动窗口的大小应该小于或等于序列号空间大小的一半</strong></p>
<p>当序列号范围有限时，如果接收端滑动窗口太大，可能导致接收端无法判断刚接收到的数据包是一个新的未接收过的数据包还是重复的已经接收过的数据包</p>
<ul>
<li><p>举个栗子：</p>
<img src="/img/computer_network/computer_network_37.png" title="采用有限序列号范围时，接收端滑动窗口太大的栗子">
<ul>
<li>图中，<strong>1等待接收</strong>（可能由于丢包，比特差错等，等待发送端重传。或者是由于所走路由的问题，比2,3到来的晚），<strong>2,3已经接收</strong>，<strong>4可以接收</strong></li>
<li>recv_base = 1, N = 4。显然，序列号是采用 mod 6 的方式复用的</li>
<li>这个时候 <strong>收到一个序列号为4的数据包</strong>，<ul>
<li>那么它 <strong>可能是一个新到来的落在滑动窗口内的数据包</strong>(<strong><em>[1, 2, 3, 4] =&gt; [recv_base, recv_base + N - 1]</em></strong>)</li>
<li>也 <strong>可能是上一轮滑动窗口中已经接收并回复ACK</strong>，但是由于发送端没有正确接收到ACK而重发的数据包，因此 <strong>这个数据包可能是之前已经接收过的冗余数据包</strong>（<strong><em>[3, 4, 5, 0] =&gt; [recv_base - N, recv_base - 1]</em></strong>）</li>
</ul>
</li>
<li><strong>对于第一种情况，我们需要缓存该数据包并回复ACK，而对于第二种情况我们只需要回复ACK即可</strong></li>
</ul>
</li>
<li><p>为了避免上述情况，<strong>滑动窗口的大小应该小于或等于序列号空间大小的一半</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Connection-Oriented-Transport-TCP"><a href="#Connection-Oriented-Transport-TCP" class="headerlink" title="Connection-Oriented Transport: TCP"></a>Connection-Oriented Transport: TCP</h2><ul>
<li>点对点（<strong><em>Point-to-Point</em></strong>）</li>
<li>传输可靠、有序的字节流 =&gt; 对每个字节进行编号</li>
<li>流水线型（<strong><em>Pipelined</em></strong>）</li>
<li>发送端和接收端都有缓存（<strong><em>send &amp; receive buffers</em></strong>）</li>
<li>全双工通信（<strong><em>full-duplex service</em></strong>）</li>
<li>面向连接的（<strong><em>connection-oriented</em></strong>）</li>
<li>拥塞控制（<strong><em>congestion control</em></strong>）</li>
<li>流量控制（<strong><em>flow control</em></strong>）</li>
</ul>
</blockquote>
<ul>
<li><h3 id="TCP接收和发送缓存"><a href="#TCP接收和发送缓存" class="headerlink" title="TCP接收和发送缓存"></a>TCP接收和发送缓存</h3><img src="/img/computer_network/computer_network_38.png" title="TCP发送和接收缓存">
=&gt; <strong>注意：</strong>在TCP连接的两端各自都有自己的发送和接收缓存（因为TCP是全双工的，所以两端的终端都有发送和接收数据的需求）</li>
<li><h3 id="MSS（Maximum-Segment-Size-最大报文长度）"><a href="#MSS（Maximum-Segment-Size-最大报文长度）" class="headerlink" title="MSS（Maximum Segment Size, 最大报文长度）"></a>MSS（Maximum Segment Size, 最大报文长度）</h3><p><strong><em>MSS is the maximun amount of application-layer data</em></strong></p>
<p>MSS指的是Segment中应用层数据的最大长度，并不包括传输层头部</p>
</li>
<li><h3 id="TCP-Segment-Structure"><a href="#TCP-Segment-Structure" class="headerlink" title="TCP Segment Structure"></a>TCP Segment Structure</h3><img src="/img/computer_network/computer_network_39.png" title="TCP报文结构">
<ul>
<li><h4 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h4><ul>
<li><strong><em>Source port</em></strong> : 源端端口号（<strong><em>16 bits</em></strong>）</li>
<li><strong><em>Dest port</em></strong> : 目的端端口号（<strong><em>16 bits</em></strong>）</li>
<li><strong><em>Sequence number</em></strong> : 序列号（<strong><em>32 bits</em></strong>）</li>
<li><strong><em>Acknowledgment number</em></strong> : 确认号（<strong><em>32 bits</em></strong>）</li>
<li><strong><em>Header length</em></strong> : TCP Segment头部（传输层头部）的长度（<strong><em>4 bits</em></strong>）。<strong>单位是4个字节，一行</strong></li>
<li><strong><em>Unused</em></strong> : 目前未使用的字段域（<strong><em>6 bits</em></strong>）</li>
<li><strong><em>Flag filed</em></strong> : 标志域（<strong><em>6 bits</em></strong>）<ul>
<li><strong><em>URG、PSH</em></strong> : 与urgent data pointer filed 并用，处理紧急数据包（实践中未用到） =&gt; Don’t care now</li>
<li><strong><em>ACK</em></strong> : 标识这个数据包是不是一个ACK</li>
<li><strong><em>RST、SYN、FIN</em></strong> : 这三个字段域用于创建TCP连接过程中</li>
</ul>
</li>
<li><strong><em>Receive window</em></strong> : 该字段用于流量控制，指示的是发送数据包一端，接收窗口的剩余可用大小</li>
<li><strong><em>Internet checksum</em></strong> : 校验和，用于检测数据包是否出错</li>
<li><strong><em>Urgent data pointer</em></strong> : 指向紧急数据尾的指针（实践中未用）=&gt; Don’t care</li>
<li><strong><em>Options</em></strong> : TCP Segment头部的可选字段，可以没有</li>
<li><strong><em>Data</em></strong> : TCP Segment的数据域，包含了上层传递下来的message</li>
</ul>
</li>
<li><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><ul>
<li><strong>TCP首部的开销至少是20个字节</strong>，通常默认情况下Options字段域是为空的</li>
<li><strong>Header length 的单位是4个字节</strong>（一行32bits）</li>
</ul>
</li>
<li><h3 id="TCP的序列号和确认号"><a href="#TCP的序列号和确认号" class="headerlink" title="TCP的序列号和确认号"></a>TCP的序列号和确认号</h3><ul>
<li>序列号和确认号是TCP提供可靠数据传输最重要的两个重要字段</li>
<li><strong>TCP</strong> 把data看做有序的字节流。它按字节编号，<strong>给每一个字节分配一个序列号</strong> =&gt; <strong>一个Segment的序列号由其数据域第一个字节的序列号所代表</strong></li>
<li><p><strong>TCP同样也是使用累积确认的机制</strong>，但是和之前讲的有点不一样：<strong><em>The acknowledgment number that Host A puts in its segment is the sequence number of the next byte Host A is expecting from Host B</em></strong> （主机A在给主机B发送的ACK包的确认号是主机A期望从主机B获取到的下一个数据包的序列号）</p>
<p>例如：发送端如果收到确认号为536的ACK包，则表示序列号为536之前的所有数据包均已被成功接收，并且接收端期望下一个收到序列号为536的数据包</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="Reliable-Data-Transfer-gt-TCP-的可靠数据传输"><a href="#Reliable-Data-Transfer-gt-TCP-的可靠数据传输" class="headerlink" title="Reliable Data Transfer =&gt; (TCP)的可靠数据传输"></a>Reliable Data Transfer =&gt; (TCP)的可靠数据传输</h3><ul>
<li>TCP在IP不可靠服务的基础上实现了可靠数据传输</li>
<li><strong>流水线型协议</strong> =&gt; 带宽利用率高</li>
<li><strong>采用累积确认</strong></li>
<li><strong>TCP采用单个重传计时器</strong></li>
<li><strong>重传的时机</strong>：<ul>
<li>定时器超时</li>
<li>收到3次冗余ACK</li>
</ul>
</li>
<li><strong>快速重传</strong> =&gt; 当收到3次冗余ACK时（<strong><em>实际上是收到了4个相同的ACK</em></strong>），就认为定时器超时，重传已发送未确认的编号最小的数据包</li>
</ul>
</li>
<li><h3 id="TCP中使用了哪些机制来实现可靠数据传输"><a href="#TCP中使用了哪些机制来实现可靠数据传输" class="headerlink" title="TCP中使用了哪些机制来实现可靠数据传输"></a>TCP中使用了哪些机制来实现可靠数据传输</h3><ul>
<li><strong>引入序列号来解决冗余数据包的问题</strong><br>=&gt; 接收端收到序列号与之前收到的数据包序列号相同时，就丢弃该包</li>
<li><strong>采用累积确认</strong><br>=&gt; 发送端如果收到确认号为536的ACK包，则表示序列号为536之前的所有数据包均已被成功接收，并且接收端期望下一个收到序列号为536的数据包</li>
<li><strong>TCP采用单个重传计时器+快速重传+累积确认来解决丢包问题</strong><br>=&gt; 当发送端定时器超时或者收到相同数据包的3次冗余ACK时，便重传已发送未被确认的数据包中编号最小的数据包</li>
<li><strong>Checksum</strong> =&gt; 用来检测数据包是否出现差错</li>
</ul>
</li>
<li><h3 id="TCP交互流程图中ACK和ack"><a href="#TCP交互流程图中ACK和ack" class="headerlink" title="TCP交互流程图中ACK和ack"></a>TCP交互流程图中ACK和ack</h3><ul>
<li><strong>ACK</strong> =&gt; 表示的是TCP Segment中的ACK标志域，如果ACK=1则表示这是一个ACK包，如果ACK=0则表示这不是一个ACK包</li>
<li><strong>ack</strong> =&gt; 表示的是TCP Segment中的确认号字段</li>
</ul>
</li>
<li><h3 id="Flow-Control（流量控制）"><a href="#Flow-Control（流量控制）" class="headerlink" title="Flow Control（流量控制）"></a>Flow Control（流量控制）</h3><ul>
<li><strong>调节发送端发包的速率，防止接收端缓存溢出</strong></li>
<li><strong>控制已发送未被确认的数据包的数量 ≤ Receive Window size</strong> （接收端剩余缓存空间的大小 =&gt; 接收端通过ACK返回给发送端）</li>
</ul>
</li>
<li><h3 id="TCP-Connection-Management（TCP连接管理）"><a href="#TCP-Connection-Management（TCP连接管理）" class="headerlink" title="TCP Connection Management（TCP连接管理）"></a>TCP Connection Management（TCP连接管理）</h3><ul>
<li><h4 id="TCP-三路握手"><a href="#TCP-三路握手" class="headerlink" title="TCP 三路握手"></a>TCP 三路握手</h4><img src="/img/computer_network/computer_network_40.png" title="TCP三路握手">
<ul>
<li>① 客户端首先向服务端 <strong>发送一个SYN Segment</strong>，其中SYN = 1，并且 <strong>随机生成一个起始的序列号 client_initial = 5 赋给seq</strong>（将随机生成的序列号填入SYN Segment的序列号字段）=&gt; <strong>没有应用层data，但是占用一个序列号</strong></li>
<li>② 服务端收到客户端发送的TCP SYN Segment后，服务端分配发送和接收buffer以及相关变量。<strong>同时发送一个SYNACK Segment</strong> 给客户端，SYN = 1，ACK=1（表示这是一个ACK包），ack = 6 （client_initial + 1）。同时 <strong>随机生成一个服务端的初始化序列号 server_initial = 17 赋值给seq</strong> （通知客户端我已经接收到你建立连接的请求，并且返回给客户端自己的初始化序列号）。 =&gt; <strong>SYNACK 包也没有应用层data，但也同样占用一个序列号</strong></li>
<li>③ 第三步客户端给服务端返回一个普通的ACK，普通ACK是 <strong>不占用序列号</strong> 的，但是 <strong>可以捎带数据</strong>（捎带数据指的是，客户端可以在建立连接的最后一个ACK中，放入一部分要发送的数据。则这个数据包即完成了作为ACK的职能，也携带了一部分数据。）</li>
</ul>
</li>
<li><h4 id="TCP-四路挥手"><a href="#TCP-四路挥手" class="headerlink" title="TCP 四路挥手"></a>TCP 四路挥手</h4><img src="/img/computer_network/computer_network_41.png" title="客户端发起的双向关闭TCP连接示意图">
<ul>
<li>不含data的正常ACK，序列号可以不写（因为不占用序列号）；</li>
<li>在非ACK数据包中的ack无含义，不用写。</li>
</ul>
</li>
<li><h4 id="TCP状态转换图-gt-点我"><a href="#TCP状态转换图-gt-点我" class="headerlink" title="TCP状态转换图 =&gt; 点我"></a>TCP状态转换图 =&gt; <a href="http://qjm253.cn/2018/01/04/super_c_d/#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">点我</a></h4></li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Principles-of-Congestion-control"><a href="#Principles-of-Congestion-control" class="headerlink" title="Principles of Congestion control"></a>Principles of Congestion control</h2><p>拥塞控制</p>
</blockquote>
<p><strong>调节发送端发包的速率，避免路由器缓存溢出</strong></p>
<blockquote>
<h2 id="TCP-Congestion-Control（TCP拥塞控制）"><a href="#TCP-Congestion-Control（TCP拥塞控制）" class="headerlink" title="TCP Congestion Control（TCP拥塞控制）"></a>TCP Congestion Control（TCP拥塞控制）</h2></blockquote>
<img src="/img/computer_network/computer_network_42.png" title="TCP拥塞窗口的演化（Tahoe and Reno）">
<p>=&gt; TCP Tahoe（代表系统首次启动的情况）： <strong>1~4时刻为慢启动阶段</strong>，cwnd以指数方式增长，其中 <strong>时刻4的时候达到了系统初始设置的慢启动阈值</strong>，系统进入拥塞避免状态，cwnd的增加开始放缓速度，以线性方式增加。到时刻 <strong>8的时候定时器超时</strong>，<strong>ssthesh = cwnd / 2， cwnd = 1 (MSS)</strong>。系统 <strong>进入慢启动阶段</strong>。到时刻12的时候达到了系统初始设置的慢启动阈值，系统进入拥塞避免状态。</p>
<p>=&gt; TCP Reno（代表系统运行时收到3次冗余ACK的情景）：时刻9系统收到3次冗余ACK，<strong>cwnd = cwnd / 2</strong>，系统 <strong>进入快速恢复阶段</strong></p>
<ul>
<li><h3 id="慢启动（slow-start）"><a href="#慢启动（slow-start）" class="headerlink" title="慢启动（slow start）"></a>慢启动（<strong><em>slow start</em></strong>）</h3><p>首次启动时，拥塞窗口（<strong><em>cwnd</em></strong>）的大小置为1 MSS（<strong><em>Maximum Segment Size</em></strong>），接着每收到一个ACK，<strong>cwnd</strong> 的值便翻一番，指数增长。当 <strong>定时器第一次超时时</strong>，<strong>cwnd的值置为1，同时将慢启动阈值</strong> （<strong><em>ssthresh</em></strong>）的值设置为 <strong>cwnd/2</strong>。接下来 <strong>cwnd</strong> 仍然以指数方式增长，但是 <strong>当达到ssthesh时，进入拥塞避免状态</strong>（需要注意的是，初始的时候，ssthesh会设置有一个初始值，当如果第一次启动时在没有超时之前，cwnd达到了预设的ssthesh，也会进入拥塞避免状态）。</p>
</li>
<li><h3 id="拥塞避免（Congestion-Avoidance）"><a href="#拥塞避免（Congestion-Avoidance）" class="headerlink" title="拥塞避免（Congestion Avoidance）"></a>拥塞避免（<strong><em>Congestion Avoidance</em></strong>）</h3><p>当<strong>进入拥塞避免状态之后</strong>，<strong>cwnd</strong> 不再以指数方式增长，而是 <strong>以线性方式增长</strong>。</p>
<ul>
<li><p>当定时器超时时，<strong>ssthesh = cwnd / 2， cwnd = 1 (MSS)</strong>。系统 <strong>进入慢启动阶段</strong>；</p>
</li>
<li><p>当收到3次冗余ACK时，<strong>cwnd = cwnd / 2</strong>，系统 <strong>进入快速恢复阶段</strong></p>
</li>
</ul>
</li>
<li><h3 id="快速恢复（Fast-Recovery）"><a href="#快速恢复（Fast-Recovery）" class="headerlink" title="快速恢复（Fast Recovery）"></a>快速恢复（<strong><em>Fast Recovery</em></strong>）</h3><p>每收到一个冗余ACK，<strong>cwnd + 1</strong></p>
<ul>
<li><p>如果引发TCP进入快速恢复阶段的 <strong>缺失报文段在定时器超时之前到达</strong>，<strong>进入拥塞避免状态</strong>。</p>
</li>
<li><p>如果在此期间，<strong>定时器超时，则ssthesh = cwnd / 2, cwnd = 1 (MSS)，进入慢启动状态</strong></p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2018/05/06/computer_networking_02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/06/computer_networking_02/" class="post-title-link" itemprop="url">Chapter 2 Applicaiton Layer</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-06 18:00:00" itemprop="dateCreated datePublished" datetime="2018-05-06T18:00:00+08:00">2018-05-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-20 10:55:18" itemprop="dateModified" datetime="2019-04-20T10:55:18+08:00">2019-04-20</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="Principles-of-Network-Applications"><a href="#Principles-of-Network-Applications" class="headerlink" title="Principles of Network Applications"></a>Principles of Network Applications</h2><ul>
<li><strong>只有端系统中才有应用层和传输层</strong></li>
</ul>
</blockquote>
<ul>
<li><h3 id="网络应用体系架构（Network-Application-Architectures）"><a href="#网络应用体系架构（Network-Application-Architectures）" class="headerlink" title="网络应用体系架构（Network Application Architectures）"></a>网络应用体系架构（Network Application Architectures）</h3><ul>
<li>client-server （C / S）</li>
<li>Peer-to-peer (P2P)</li>
<li><p>Hybird of C/S and P2P (混合架构)</p>
<blockquote>
<p>ps: 与网络体系架构（5层架构、OSI/ISO七层架构…）做一下区分</p>
</blockquote>
</li>
<li><h4 id="C-S"><a href="#C-S" class="headerlink" title="C/S"></a>C/S</h4><ul>
<li><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li><strong>服务端要一直在线</strong>，且要 <strong>先于客户端启动</strong></li>
<li>服务端通常 <strong>要有一个固定的，长期不变的唯一地址</strong>（IP Address）</li>
<li>客户端之间并不直接进行通信，<strong>所有的客户端都直接与服务端通信</strong></li>
<li>易于管理</li>
</ul>
</li>
<li><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>单点故障</li>
<li>接入客户端过多的时候，容易导致服务器过载（所以服务端通常采用分布式集群，且性能一般都比较强大）</li>
<li>维护、升级成本大</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h4><ul>
<li>不需要一直在线的服务端</li>
<li>任意两个主机之间都可以直接通信</li>
<li><strong>高可扩展性</strong> （<strong><em>设备增加不会系统影响整体的性能</em></strong>），但是不易管理</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="Process-Communication（进程通信）"><a href="#Process-Communication（进程通信）" class="headerlink" title="Process Communication（进程通信）"></a>Process Communication（进程通信）</h3><blockquote>
<p><strong>同一主机的进程之间</strong> 通过 <strong>进程间通信（innerprocess communication）</strong> 进行通信，而不同主机的进程之间通过交换数据报（message）进行通信 =&gt; 发送进程将构造message并将其发送到网络当中，接收进程从网络中接收message，并解析它</p>
</blockquote>
<ul>
<li><h4 id="Client-and-Server-Processes-（客户端和服务端进程）"><a href="#Client-and-Server-Processes-（客户端和服务端进程）" class="headerlink" title="Client and Server Processes （客户端和服务端进程）"></a>Client and Server Processes （客户端和服务端进程）</h4><p><strong><em>In the context of a communication session between on pair of processes, the process that initiates the communication (that is, initially contacts the other process at the begining of the session) is labeled as the client, The process that waits to be contacted to begin the session is the server</em></strong></p>
<ul>
<li><p>通常我们将 <strong>发起通信的一端标记为客户端</strong></p>
</li>
<li><p>不只是C/S架构中有 <strong>服务端和客户端的概念，P2P架构中同样也有</strong>，不同的是在C/S架构中一个进程扮演的角色是固定的，而 <strong>P2P架构中同一个进程既可以是客户端，也可以是服务端</strong>，甚至可以同时扮演两个角色</p>
</li>
</ul>
</li>
<li><h4 id="The-Interface-Between-the-Process-and-the-Computer-Network-进程和网络之间的接口-gt-Socket"><a href="#The-Interface-Between-the-Process-and-the-Computer-Network-进程和网络之间的接口-gt-Socket" class="headerlink" title="The Interface Between the Process and the Computer Network (进程和网络之间的接口) =&gt; Socket"></a>The Interface Between the Process and the Computer Network (进程和网络之间的接口) =&gt; Socket</h4><img src="/img/computer_network/computer_network_08.png" title="进程和Socket关系图解">
<ul>
<li><p><strong>Socket作为Process和Network之间的门户</strong> ，发送和接收message都需要经过Socket。可以把Process比作一个工厂或仓库，而Socket就是工厂或长裤的大门</p>
</li>
<li><p>一个Socket只属于一个Process，而一个Process可以持有多个Socket</p>
</li>
<li><p>我们用 IP+Port 标识一个进程</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="Transport-Services-Available-to-Applications-（传输层给应用层所提供的服务）"><a href="#Transport-Services-Available-to-Applications-（传输层给应用层所提供的服务）" class="headerlink" title="Transport Services Available to Applications （传输层给应用层所提供的服务）"></a>Transport Services Available to Applications （传输层给应用层所提供的服务）</h3><blockquote>
<p>同时也可以说是理想情况下，应用层需要传输层给它提供哪些服务</p>
</blockquote>
<ul>
<li><h4 id="Reliable-Data-Transfer-数据的可靠传输"><a href="#Reliable-Data-Transfer-数据的可靠传输" class="headerlink" title="Reliable Data Transfer (数据的可靠传输)"></a>Reliable Data Transfer (数据的可靠传输)</h4>传输层需要向应用层提供进程到进程的可靠通信</li>
<li><h4 id="Throughput-（最小带宽的保障）"><a href="#Throughput-（最小带宽的保障）" class="headerlink" title="Throughput （最小带宽的保障）"></a>Throughput （最小带宽的保障）</h4>有些网络应用（比如网络电话）是对带宽比较敏感的，被称为 <strong>带宽敏感型应用（bandwidth-sensitive-applications）</strong>。这些应用对吞吐量有一定要求，要求吞吐量至少高于某个速率才能正常工作这样子。所以传输层就需要能为应用层提供保证吞吐量的服务</li>
<li><h4 id="Timing-（延迟保障）"><a href="#Timing-（延迟保障）" class="headerlink" title="Timing （延迟保障）"></a>Timing （延迟保障）</h4></li>
<li><h4 id="Security-（安全保障）"><a href="#Security-（安全保障）" class="headerlink" title="Security （安全保障）"></a>Security （安全保障）</h4></li>
</ul>
</li>
<li><h3 id="Transport-Services-Providede-by-the-Internet"><a href="#Transport-Services-Providede-by-the-Internet" class="headerlink" title="Transport Services Providede by the Internet"></a>Transport Services Providede by the Internet</h3><blockquote>
<p>互联网所提供的传输层服务</p>
</blockquote>
<ul>
<li><h4 id="TCP-Services"><a href="#TCP-Services" class="headerlink" title="TCP Services"></a>TCP Services</h4><blockquote>
<p>提供数据的可靠传输，不提供最小带宽，最短时延的保障，不提供安全保障</p>
</blockquote>
<ul>
<li>connect-oriented (面向连接)</li>
<li>reliable transport (可靠传输)</li>
<li>flow control (流量控制)</li>
<li>congestion control (拥塞控制)</li>
</ul>
</li>
<li><h4 id="UDP-services"><a href="#UDP-services" class="headerlink" title="UDP services"></a>UDP services</h4><blockquote>
<p>不提供可靠数据传输，不提供最小带宽，最短时延的保障，不提供安全保障</p>
</blockquote>
</li>
<li><h4 id="一些经典应用程序所采用的应用层协议和传输层协议"><a href="#一些经典应用程序所采用的应用层协议和传输层协议" class="headerlink" title="一些经典应用程序所采用的应用层协议和传输层协议"></a>一些经典应用程序所采用的应用层协议和传输层协议</h4><img src="/img/computer_network/computer_network_09.png" title="一些经典的应用程序所采用的应用层协议和传输层协议">
<ul>
<li>TCP: Telnet, FTP, SMTP, HTTP</li>
<li>UDP: SNMP, DNS, RTP, RIP</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="The-Web-and-HTTP"><a href="#The-Web-and-HTTP" class="headerlink" title="The Web and HTTP"></a>The Web and HTTP</h2></blockquote>
<ul>
<li><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><blockquote>
<p>HTTP——HypreText Transfer Protol（超文本传输协议）</p>
</blockquote>
<ul>
<li>HTTP是应用层协议（Application protocol）</li>
<li>HTTP采用的是C/S架构</li>
<li>基于TCP</li>
<li>HTTP是无状态的(stateless) =&gt; 不保存用户端的状态信息，所以HTTP协议也被称为无状态协议（stateless protocol）</li>
</ul>
</li>
<li><h3 id="Non-Persistent-and-Persistent-Connections"><a href="#Non-Persistent-and-Persistent-Connections" class="headerlink" title="Non-Persistent and Persistent Connections"></a>Non-Persistent and Persistent Connections</h3><ul>
<li><h4 id="RTT-Round-trip-time-往返时间"><a href="#RTT-Round-trip-time-往返时间" class="headerlink" title="RTT (Round-trip time, 往返时间)"></a>RTT (Round-trip time, 往返时间)</h4><p><strong>定义</strong>：一个很小的数据包（小到可以近乎忽略数据包的长度）从客户端到服务端往返一次所需要的时间</p>
<img src="/img/computer_network/computer_network_02.jpg" title="RTT">
</li>
<li><h4 id="一次HTTP请求的响应时间"><a href="#一次HTTP请求的响应时间" class="headerlink" title="一次HTTP请求的响应时间"></a>一次HTTP请求的响应时间</h4><img src="/img/computer_network/computer_network_10.png" title="一次HTTP请求的响应时间">
<ul>
<li>total = 2*RTT + transimit time</li>
<li>总的响应时间 = 2倍的RTT + 收到整个返回的对象所需要的时间（文件长度/带宽）</li>
</ul>
</li>
<li><h4 id="Non-Persistent-HTTP-（非坚持的HTTP）"><a href="#Non-Persistent-HTTP-（非坚持的HTTP）" class="headerlink" title="Non-Persistent HTTP （非坚持的HTTP）"></a>Non-Persistent HTTP （非坚持的HTTP）</h4><p>每建立一个TCP连接，只能传一个对象（object =&gt; HTML file, JPEG…）</p>
<ul>
<li>由于接收每个对象都要单独建立连接，所以 <strong>接收每个对象所需要的响应时间都包含至少两个RTT</strong></li>
<li><strong>服务器负担重</strong>：传送每个对象都需要服务器维护一个新的连接，而连接的建立和维护是有一定开销的</li>
</ul>
</li>
<li><h4 id="Persistent-HTTP-（坚持的HTTP）"><a href="#Persistent-HTTP-（坚持的HTTP）" class="headerlink" title="Persistent HTTP （坚持的HTTP）"></a>Persistent HTTP （坚持的HTTP）</h4>一个连接建立可以传第一个Object<ul>
<li>这个接收第一个对象的时候需要至少两个RTT，紧接着后面的每个对象都少了建立连接的RTT了。</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="HTTP-Message-Format"><a href="#HTTP-Message-Format" class="headerlink" title="HTTP Message Format"></a>HTTP Message Format</h3><ul>
<li><h4 id="HTTP-Request-Message-HTTP请求消息格式"><a href="#HTTP-Request-Message-HTTP请求消息格式" class="headerlink" title="HTTP Request Message (HTTP请求消息格式)"></a>HTTP Request Message (HTTP请求消息格式)</h4><img src="/img/computer_network/computer_network_11.png" title="HTTP请求消息的通用格式">
<ul>
<li><strong>method field</strong> (方法域)：GET, POST, HEAD, PUT, DELETE …</li>
<li><strong>URL</strong>: 请求位置</li>
<li><strong>Version</strong>：HTTP协议的版本号</li>
<li><strong>Header lines</strong>: 包含了请求头信息，请求头中包含一系列的键值对</li>
<li><strong>Entity body</strong>: 数据域，当使用GET请求的时候，这个域是为空的，当使用POST请求的时候，这个域包含了请求所携带的数据</li>
<li><strong>HTTP Request message都是用ASCII text表示的</strong></li>
<li>需要注意的是，请求中携带数据，不一定要使用POST方法， <strong>GET方法也同样可以携带数据</strong>。虽然GET请求的Entity body域是空的，但是GET方法可以在URL后面包含数据。</li>
</ul>
</li>
<li><h4 id="一个HTTP请求的简单例子"><a href="#一个HTTP请求的简单例子" class="headerlink" title="一个HTTP请求的简单例子"></a>一个HTTP请求的简单例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somedir/page.html HTTP/1.1</span><br><span class="line">Host: www.someschool.edu</span><br><span class="line">Connection: close</span><br><span class="line">User-agent: Mozilla/4.0</span><br><span class="line">Accept-language: fr</span><br></pre></td></tr></table></figure>
<ul>
<li>其中第一行分别是请求方法，URL和HTTP版本</li>
<li>后面四行是请求头<ul>
<li>Host: 服务器主机的域名</li>
<li>Connection: close =&gt; 要求服务器在发送完所请求的数据之后，不保持连接</li>
<li>User-agent =&gt; 通常用来标识浏览器内核版本，服务端可以通过这个请求头对不同的浏览器返回不同的文件，这样就可以实现同一个URL针对不同的浏览器返回不同数据的功能</li>
<li>Accept-language =&gt; 告诉服务器前端所期望服务器返回数据的语言</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="HTTP-Response-Message-（HTTP返回消息格式）"><a href="#HTTP-Response-Message-（HTTP返回消息格式）" class="headerlink" title="HTTP Response Message （HTTP返回消息格式）"></a>HTTP Response Message （HTTP返回消息格式）</h4><img src="/img/computer_network/computer_network_12.png" title="HTTP返回消息的通用格式">
<ul>
<li><strong>status line</strong><ul>
<li><strong>version</strong>: HTTP协议的版本号</li>
<li><strong>status code</strong>: 本次请求的状态码</li>
<li><strong>parase</strong>: 对状态码的简单描述</li>
</ul>
</li>
<li><strong>Header lines</strong>: 包含了返回头信息，返回头中包含一系列的键值对</li>
<li><strong>Entity body</strong>: 数据域，如果有的话包含了服务器返回的数据</li>
</ul>
</li>
<li><h4 id="HTTP-Response-Status-Code-HTTP-返回消息状态码"><a href="#HTTP-Response-Status-Code-HTTP-返回消息状态码" class="headerlink" title="HTTP Response Status Code (HTTP 返回消息状态码)"></a>HTTP Response Status Code (HTTP 返回消息状态码)</h4><blockquote>
<p><a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener">状态码列表</a></p>
</blockquote>
<ul>
<li>200 OK: 本次请求成功，并且所请求的object对象已经在Response消息中返回</li>
<li>301 Moved Permanently: 所请求的Object已经被移到另一个位置，在Response Message的Location 头中包含了Object的新位置，正常情况下浏览器会自动访问新地址</li>
<li>400 Bad Request: 服务器无法理解客户端的请求</li>
<li>404 Not Found: 所请求的object在服务器上不存在</li>
<li>505 HTTP Version Not Supported: 请求的HTTP协议版本不被服务端支持</li>
</ul>
</li>
<li><h4 id="一个HTTP回复消息的简单例子"><a href="#一个HTTP回复消息的简单例子" class="headerlink" title="一个HTTP回复消息的简单例子"></a>一个HTTP回复消息的简单例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Date: Sat, 07 Jul 2007 12:00:15 GMT</span><br><span class="line">Server: Apache/1.3.0 (Unix)</span><br><span class="line">Last-Modified: Sun, 6 May 2007 09:23:24 GMT</span><br><span class="line">Content-Length: 6821</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">(data data data data data ....)</span><br></pre></td></tr></table></figure>
<p>上面的消息中包含：an initial status line，six header lines，the entity body</p>
<ul>
<li>第一行表示服务端HTTP协议版本号为1.1，客户端本次请求的状态码为200，状态码的描述为OK（表示客户端请求的服务器存在，并且服务器上存在客户端所请求的文件）</li>
<li><strong>Connection: close</strong> =&gt; 告知客户端，服务器发送完这个Object对象之后就会关闭连接</li>
<li><strong>Date</strong> =&gt; 表示服务器创建这个message的时间</li>
<li><strong>Server</strong> =&gt; 包含了服务器的一些信息，与User-Agent类似</li>
<li><strong>Last-Modified</strong> =&gt; 表示这个Object的最后修改时间，这个在浏览器进行缓存处理的时候极为有用</li>
<li><strong>Content-Length</strong> =&gt; 返回Object的数据长度</li>
<li><strong>Content-Type</strong> =&gt; 返回Object的类型</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="User-Server-Interaction-Cookies-用户服务器交互：Cookies"><a href="#User-Server-Interaction-Cookies-用户服务器交互：Cookies" class="headerlink" title="User-Server Interaction: Cookies (用户服务器交互：Cookies)"></a>User-Server Interaction: Cookies (用户服务器交互：Cookies)</h3><ul>
<li><h4 id="Cookies-技术四大组件"><a href="#Cookies-技术四大组件" class="headerlink" title="Cookies 技术四大组件"></a>Cookies 技术四大组件</h4><ul>
<li>A cookie header line in the HTTP response message (HTTP返回消息中的一个cookie头行：例如 <strong>Set-cookie: 1678</strong>)</li>
<li>A cookie header line in the HTTP request message（HTTP请求消息中的一个cookie头行：例如 <strong>Cookie: 1678</strong>）</li>
<li>A cookie file kept on the use’s end system and managed by use’s browser (一个cookie文件，持久化在客户终端，并且由客户端浏览器统一管理)</li>
<li>A back-end database at the Web site (网站上的后端数据库 =&gt; 服务器上记录用户的状态信息，通过请求中的cookie，从数据库中取出对应的信息).</li>
</ul>
</li>
<li><h4 id="交互示例"><a href="#交互示例" class="headerlink" title="交互示例"></a>交互示例</h4><img src="/img/computer_network/computer_network_13.png" title="用户通过Cookies与服务器交互示意图">
<ul>
<li>用户一开始向服务器发送一个正常的HTTP请求</li>
<li>服务器在返回的消息中，通过 <strong>Set-cookie</strong> 头示意客户端浏览器保存一个Cookie。客户端浏览器如果打开了Cookie支持，就会将收到的Cookie存起来，持久化到Cookie文件里面</li>
<li>之后对同一网站的请求，浏览器都会在每个请求消息中自动加入 <strong>Cookie</strong> 头，并将之前持久化保存起来的Cookie信息取出，填上去</li>
<li>服务器收到带Cookie头的请求就会去数据库查询相关信息，</li>
</ul>
</li>
<li><p>使用Cookie技术，可以 <strong>在无状态的HTTP上层创建了一个可以保持用户状态的用户会话层</strong></p>
</li>
</ul>
</li>
<li><h3 id="Web-Caching（Web缓存）"><a href="#Web-Caching（Web缓存）" class="headerlink" title="Web Caching（Web缓存）"></a>Web Caching（Web缓存）</h3><blockquote>
<p><strong>Web Caching</strong>（Web缓存）也称之为 <strong>proxy server</strong>（代理服务器）。是一个可以代替源端Web服务器响应客户端请求的这么一个网络实体</p>
<ul>
<li>WEB缓存在同一时刻既作为Client（客户端），也作为Server（服务端）</li>
</ul>
</blockquote>
<ul>
<li><h4 id="Web-Caching-的工作流程"><a href="#Web-Caching-的工作流程" class="headerlink" title="Web Caching 的工作流程"></a>Web Caching 的工作流程</h4><img src="/img/computer_network/computer_network_14.png" title="Web缓存工作示意图">
<ol>
<li>首先，客户端浏览器建立一个到Web缓存的TCP连接，并将请求发送给Web缓存</li>
<li>Web缓存收到客户端的请求之后，检查本地是否有客户端要请求的object的本地缓存，如果有就将其放入HTTP Response Message中返回给客户端，否则转第三步</li>
<li>如果Web Caching中没有客户需要的Object，Web缓存就根据客户端请求中的目标地址，向源Web服务器发起一个请求，获取到客户需要的Object</li>
<li>接着Web缓存将从源服务器中收到的Object缓存到本地，并奖客户端需要的Object放入HTTP Response Message返回给客户端</li>
</ol>
</li>
<li><h4 id="采用Web缓存的好处"><a href="#采用Web缓存的好处" class="headerlink" title="采用Web缓存的好处"></a>采用Web缓存的好处</h4><ol>
<li>WEB缓存可以大大地减少客户端请求的响应时间，特别是当客户端与源服务器的瓶颈带宽远小于客户端与WEB缓存之间的瓶颈带宽的时候。=&gt; <strong>缩短响应时间，提高响应速度</strong></li>
<li><p>Web缓存能够大大减少一个机构的接入 链路到闲特网的通信量。通过减少通信量，该机构(如一家公司或者一所大学)就不必急 于增加带宽，因此降低了费用。此外，Web缓器能从整体上大大减低因特网上的 Web 流量，从而改善了所有应用的性能。 =&gt; <strong>减少源服务器的负载，降低机构的出口带宽费用，改善整个因特网的性能</strong></p>
<img src="/img/computer_network/computer_network_15.png" title="添加本地Web缓存之后的系统">
</li>
<li><p>可以提供另一条路径去访问远程服务器（VPN）。客户端访问不到源服务器但是可以访问Web缓存，而Web缓存可以访问到源服务器，那客户端就可以通过WEB缓存的代理，间接访问源服务器</p>
</li>
</ol>
</li>
<li><h4 id="采用Web缓存可能存在的缺陷"><a href="#采用Web缓存可能存在的缺陷" class="headerlink" title="采用Web缓存可能存在的缺陷"></a>采用Web缓存可能存在的缺陷</h4><ul>
<li>信息的滞后性，客户端获取到的可能不是源端最新的版本</li>
<li>解决办法：通过 <strong>Conditional GET(有条件的GET)</strong>，当Web缓存收到客户端的请求的时候，就向源服务器发送一个有条件的GET，询问客户端请求的Object与Web缓存本地的缓存的对象相比是否有更新。如果有更新，就从源服务器下载Object，更新本地的缓存，并将最新的Object返回给客户端；如果没有更新，Web缓存就直接将本地缓存的Object返回给客户端。</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="Conditional-GET-有条件的GET"><a href="#Conditional-GET-有条件的GET" class="headerlink" title="Conditional GET (有条件的GET)"></a>Conditional GET (有条件的GET)</h3><ul>
<li><h4 id="什么是有条件的GET"><a href="#什么是有条件的GET" class="headerlink" title="什么是有条件的GET"></a>什么是有条件的GET</h4><ul>
<li>The Request message use the <strong>GET</strong> method （用GET方法请求）</li>
<li>The Request message includes an <strong>If-Modified-Since:</strong> header line （请求的时候带上If-Modified-Since头）</li>
</ul>
</li>
<li><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol>
<li><p>一开始Web缓存本地没有缓存，收到一个客户端的请求之后就转而去请求源服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /fruit/kiwi.gif HTTP/1.1</span><br><span class="line">Host: www.exotiquecuisine.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>接着源服务器会返回类似如下的返回消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 7 Jul 2007 15:39:29</span><br><span class="line">Server: Apache/1.3.0 (Unix)</span><br><span class="line">Last-Modified: Wed, 4 Jul 2007 09:23:24</span><br><span class="line">Content-Type: image/gif</span><br><span class="line"></span><br><span class="line">(data data data data ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Web缓存收到源服务器返回的消息之后</strong>，就会将Object缓存下来，同时也 <strong>会把对应的Last-Modified头信息（Object最后修改时间）保存下来</strong>。一段时间后，比如过了一周，又有一个客户端向Web缓存请求这个Object，由于过了一段时间了，这个Object可能被修改/更新过了，所以 <strong>Web缓存需要向源服务器发送一个Conditional GET</strong>， 以确定是否要从源服务器更新本地的缓存。Conditional GET请求如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /fruit/kiwi.gif HTTP/1.1</span><br><span class="line">Host: www.exotiquecuisine.com</span><br><span class="line">If-Modified-Since: Wed, 4 Jul 2007 09:23:24</span><br></pre></td></tr></table></figure>
</li>
<li><p>源服务器收到一个Conditional GET之后，会检查目标Object的最后修改时间和GET请求中 <strong>If-Modified-Since:</strong>字段的时间孰大孰小，如果时间一致，表示不用更新，会返回如下信息（如果时间不一致，则正常返回要请求的Object）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 304 Not Modified</span><br><span class="line">Date: Sat, 14 Jul 2007 15:39:29</span><br><span class="line">Server: Apache/1.3.0 (Unix)</span><br><span class="line"></span><br><span class="line">(empty entity body)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Web缓存的 <strong>Conditional GET请求</strong> 如果收到 <strong>源服务器返回的304状态码</strong>，就认为本地缓存的Object是最新的，直接将其放入HTTP Response Message 当中返回给客户端</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="File-Transfer-FTP-（文件传输协议）"><a href="#File-Transfer-FTP-（文件传输协议）" class="headerlink" title="File Transfer: FTP （文件传输协议）"></a>File Transfer: FTP （文件传输协议）</h2></blockquote>
  <img src="/img/computer_network/computer_network_16.png" title="FTP协议工作示意图">
<ul>
<li><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>基于TCP</li>
<li>采用C/S架构</li>
<li>是应用层协议</li>
<li>控制流和信息流分离，<strong>控制信息的传输采用带外传输</strong>（out-of-bound）的方式</li>
</ul>
</li>
<li><h3 id="两种连接"><a href="#两种连接" class="headerlink" title="两种连接"></a>两种连接</h3><img src="/img/computer_network/computer_network_17.png" title="FTP控制连接和数据连接">
<ul>
<li>FTP协议在 <strong>21端口上传递控制信息</strong>，在 <strong>22端口上传递数据</strong>（文件）</li>
<li>初始时客户端通过向服务器的21号端口建立一条TCP连接（control connection），并且向服务端发送identifycation，username，password等信息。接着服务端向客户端建立一条TCP连接用于传输数据（data connection）。即便在同一个Session，每传递一个新的文件都需要新开一个data connection</li>
<li><strong>控制连接</strong>（control connection）始终处于连接的状态，并且是维持用户状态的（state），<strong>数据连接</strong> 在每传输完一个文件之后就关闭，同时传输多个文件会开启多个数据连接（<strong>Non-Persistent Connection</strong>）</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Electronic-Mail-in-the-Internet-因特网中的电子邮件"><a href="#Electronic-Mail-in-the-Internet-因特网中的电子邮件" class="headerlink" title="Electronic Mail in the Internet (因特网中的电子邮件)"></a>Electronic Mail in the Internet (因特网中的电子邮件)</h2><ul>
<li>SMTP（简单邮件传输协议）=&gt; TCP</li>
<li>POP3</li>
<li>IMAP</li>
</ul>
</blockquote>
<ul>
<li><h3 id="对比SMTP和HTTP"><a href="#对比SMTP和HTTP" class="headerlink" title="对比SMTP和HTTP"></a>对比SMTP和HTTP</h3><ul>
<li><h4 id="同："><a href="#同：" class="headerlink" title="同："></a>同：</h4><ul>
<li>两种协议都是用于从一个主机向另一个主机传输文件</li>
<li>持久HTTP和SMTP都采用持久连接</li>
<li>都是应用层协议</li>
<li>都基于TCP</li>
</ul>
</li>
<li><h4 id="异："><a href="#异：" class="headerlink" title="异："></a>异：</h4><ul>
<li><strong>HTTP</strong> 是一种 <strong>拉式协议（pull protocol）</strong>，它由想接受文件的一端发起连接；而 <strong>SMTP</strong> 是一种 <strong>推式协议（push protocol）</strong>，它由想发送文件的一端发起连接</li>
<li><strong>SMTP</strong> 的message需要使用 <strong>7-bits ASCII</strong> 格式，对于不是7-bits ASCII格式的文字或者包含比特流，都需编码为 7-bits ASCII 格式之后传送。而相比之下，HTTP就没有这种限制</li>
<li>对于包含文本和图形的文档<ul>
<li>HTTP是把每个Object放到一个Response message中发送</li>
<li>而SMTP是把所有的Object放在一个报文中发送</li>
</ul>
</li>
</ul>
</li>
<li>SMTP是一种推式协议，所以不能用来从邮件服务器上获取邮件，而应该采用其它协议来获取邮件</li>
</ul>
</li>
<li><h3 id="收发邮件所用的协议"><a href="#收发邮件所用的协议" class="headerlink" title="收发邮件所用的协议"></a>收发邮件所用的协议</h3><ul>
<li><h4 id="发邮件"><a href="#发邮件" class="headerlink" title="发邮件"></a>发邮件</h4><ul>
<li><strong>SMTP</strong> (Simple Mail Transfer Protocol)</li>
</ul>
</li>
<li><h3 id="收邮件"><a href="#收邮件" class="headerlink" title="收邮件"></a>收邮件</h3><ul>
<li><strong>POP3</strong> (Post Office Protocol——Version 3) =&gt; 邮局协议，端口110<ul>
<li>“download and delete” mode</li>
<li>“download and keep” mode</li>
</ul>
</li>
<li><strong>IMAP</strong> (Internet Mail Access Protocol) =&gt; 互联网邮件访问协议</li>
<li><strong>HTTP</strong> (HyperText Transfer Protocol) =&gt; 超文本传输协议</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ul>
<li>Domain Name System, 域名系统</li>
<li><strong>DNS 协议基于UDP</strong>，PORT 53</li>
</ul>
</blockquote>
<ul>
<li><h3 id="DNS-Servers-组成"><a href="#DNS-Servers-组成" class="headerlink" title="DNS Servers 组成"></a>DNS Servers 组成</h3><ul>
<li><strong><em>A distributed databse implemented in a hierarchy of DNS Servers</em></strong> (一个由分层的DNS服务器实现的分布式数据库)</li>
<li><strong><em>An application-layer protocol that allows hosts to query the distributed database</em></strong> (一个使得主机能够查询这个分布式数据库的应用层协议)</li>
</ul>
</li>
<li><h3 id="Services-Provided-by-DNS-DNS所提供的服务"><a href="#Services-Provided-by-DNS-DNS所提供的服务" class="headerlink" title="Services Provided by DNS (DNS所提供的服务)"></a>Services Provided by DNS (DNS所提供的服务)</h3><ul>
<li>实现域名（<strong><em>hostname</em></strong>）和IP地址的转换 =&gt; 最主要的功能</li>
<li>支持给主机设置别名（<strong><em>Host aliasing</em></strong>）=&gt; 可以给复杂难记的域名指定一个简单易记的别名，别名指向的原域名我们称之为 <strong>规范主机名</strong>(<strong><em>canonical hostname</em></strong>)。我们可以用这个别名通过DNS服务器查到其规范主机名，进而查到对应的IP</li>
<li>支持给邮件服务器设置别名 (<strong><em>Mail Server aliasing</em></strong>)</li>
<li>支持负载均衡 (<strong><em>Load distribution</em></strong>) =&gt; 对同一个域名的访问/请求，可以由多个服务器分担</li>
</ul>
</li>
<li><h3 id="DNS服务为什么不采用集中式设计（centralized-design）"><a href="#DNS服务为什么不采用集中式设计（centralized-design）" class="headerlink" title="DNS服务为什么不采用集中式设计（centralized design）"></a>DNS服务为什么不采用集中式设计（centralized design）</h3><ul>
<li>单点故障 （<strong><em>A Single point of failure</em></strong>）</li>
<li>通信容量限制（<strong><em>Traffic volume</em></strong>）=&gt; 单个服务器无法处理上亿个甚至更多的请求</li>
<li>远距离的集中式数据库（<strong><em>Distant centralized databse</em></strong>）=&gt; 单个DNS服务器无法临近所有主机，距离越远，所产生的时延也就越大</li>
<li>维护困难（<strong><em>Maintenance</em></strong>）=&gt; 单个DNS服务器将为互联网的所有主机保存数据，将会导致中央数据库非常的庞大，难于维护。</li>
</ul>
</li>
<li><h3 id="DNS-Server-是一个分布式、分层的数据库"><a href="#DNS-Server-是一个分布式、分层的数据库" class="headerlink" title="DNS Server 是一个分布式、分层的数据库"></a>DNS Server 是一个分布式、分层的数据库</h3><img src="/img/computer_network/computer_network_18.png" title="DNS Server 分层">
<ul>
<li>Root DNS Servers =&gt; 根域名服务器（全球只有13个，大部分在北美）</li>
<li>Top-level domain (TLD) =&gt; 顶级域名服务器</li>
<li>Authoritative DNS Servers =&gt; 权威域名服务器</li>
<li>Local DNS Server =&gt; 本地域名服务器（通常每个ISP会有一个本地的域名服务器）</li>
</ul>
</li>
<li><h3 id="两种查询方式"><a href="#两种查询方式" class="headerlink" title="两种查询方式"></a>两种查询方式</h3><ul>
<li><h4 id="交互式查询（Interactive-Queries）"><a href="#交互式查询（Interactive-Queries）" class="headerlink" title="交互式查询（Interactive Queries）"></a>交互式查询（Interactive Queries）</h4><img src="/img/computer_network/computer_network_19.png" title="交互式查询方式示意图"></li>
<li><h4 id="递归式查询（Recursive-Queries）"><a href="#递归式查询（Recursive-Queries）" class="headerlink" title="递归式查询（Recursive Queries）"></a>递归式查询（Recursive Queries）</h4><img src="/img/computer_network/computer_network_20.png" title="递归式查询示意图"></li>
</ul>
</li>
<li><h3 id="DNS-Caching-DNS缓存"><a href="#DNS-Caching-DNS缓存" class="headerlink" title="DNS Caching (DNS缓存)"></a>DNS Caching (DNS缓存)</h3><p>DNS服务器会对查询过的域名对应有缓存，并且该缓存会有一个存活时间，被访问的越频繁越不容易失效</p>
<ul>
<li>DNS Caching 可以减少客户端查询DNS服务器所导致的延迟</li>
<li>DNS Caching 可以降低高级域名服务器的负载</li>
</ul>
</li>
<li><h3 id="DNS-Records"><a href="#DNS-Records" class="headerlink" title="DNS Records"></a>DNS Records</h3><p>一个DNS记录是如下的四元组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 域名，值，类型，存活时间（Time-to-live）</span></span><br><span class="line">(Name, Value, Type, TTL)</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="记录的类型"><a href="#记录的类型" class="headerlink" title="记录的类型"></a>记录的类型</h4><ul>
<li><p><strong>A记录</strong>：Name -&gt; hostname, Value -&gt; IP</p>
<p>例：(relay1.bar.foo.com, 145.37.93.126, A)</p>
</li>
<li><p><strong>NS记录</strong>：Name -&gt; ，则 Name 是个域 (如foo. com) ，而 Value 是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名</p>
<p>例：(foo.com, dns.foo.com, NS)</p>
</li>
<li><p><strong>CNAME记录</strong>：则 Value 是别名为 Name 的主机对应的规范主机名</p>
<p>例：（foo.com, relat1.var.foo.com, CNAME）</p>
</li>
<li><p><strong>MX记录</strong>：，则 Value 是个别名为 Name 的邮件服务器的规范主机名</p>
<p>例：（foo.com, mail.bar.foo.com, MX）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="Peer-to-peer-Applicaions（P2P应用程序）"><a href="#Peer-to-peer-Applicaions（P2P应用程序）" class="headerlink" title="Peer-to-peer Applicaions（P2P应用程序）"></a>Peer-to-peer Applicaions（P2P应用程序）</h2><ul>
<li>共享资源</li>
<li>节点间课直接通信</li>
<li>非集中式</li>
</ul>
</blockquote>
<ul>
<li><h3 id="C-S-架构中存在的问题"><a href="#C-S-架构中存在的问题" class="headerlink" title="C/S 架构中存在的问题"></a>C/S 架构中存在的问题</h3><ul>
<li>难于扩展（由于服务端负载有限额，当客户端达到一定额度之后，就很难在扩展了）</li>
<li>单点故障</li>
<li>需要超级节点作为管理者（服务器的性能要足够好）</li>
<li>网络边缘的资源未得到充分的利用</li>
</ul>
</li>
<li><h3 id="P2P-的特点"><a href="#P2P-的特点" class="headerlink" title="P2P 的特点"></a>P2P 的特点</h3><ul>
<li>资源利用率高</li>
<li>可扩展性好</li>
<li>可靠性/健壮性好（无单点故障，文件有多份拷贝）</li>
<li>不需要超级节点管理，节点自管理</li>
<li>隐私不可控（BT）</li>
<li>动态性更强</li>
<li>搭便车问题</li>
</ul>
</li>
<li><h3 id="Robustness（健壮性）"><a href="#Robustness（健壮性）" class="headerlink" title="Robustness（健壮性）"></a>Robustness（健壮性）</h3>系统受到干扰之后迅速恢复回原来状态的能力。</li>
<li><h3 id="Flooding（洪泛）"><a href="#Flooding（洪泛）" class="headerlink" title="Flooding（洪泛）"></a>Flooding（洪泛）</h3>每次受到邻居节点消息之后都无条件的转发给其它邻居，导致洪泛发生。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">建明 | Ming.J</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">58</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">建明 | Ming.J</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  



  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>



  
  







  
  
  <script id="ribbon" size="300" alpha="0.2" zindex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>





  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>

  
  <script src="/lib/three/three.min.js"></script>

  
  <script src="/lib/three/three-waves.min.js"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
<script>
if ($('body').find('pre.mermaid').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      mermaid.initialize({
        theme: 'forest',
        logLevel: 3,
        flowchart: { curve: 'linear' },
        gantt: { axisFormat: '%m/%d/%Y' },
        sequence: { actorMargin: 50 }
      });
    }
  });
}
</script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

</body>
</html>
