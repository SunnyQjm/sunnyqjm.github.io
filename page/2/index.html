<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="建明 | Ming.J">
<meta property="og:url" content="http://qjm253.cn/page/2/index.html">
<meta property="og:site_name" content="建明 | Ming.J">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="建明 | Ming.J">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://qjm253.cn/page/2/"/>





  <title>建明 | Ming.J</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">建明 | Ming.J</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">至清  至静</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2017/12/22/2017-12-22-软件工程复习（b）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-r.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/22/2017-12-22-软件工程复习（b）/" itemprop="url">软件工程复习（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-22T00:00:00+08:00">
                2017-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="可行性研究的任务"><a href="#可行性研究的任务" class="headerlink" title="可行性研究的任务"></a>可行性研究的任务</h2><p>不是解决问题，而是确定问题是否值得去解决。</p>
<ul>
<li>分析可能的解法</li>
<li>判定系统规模和目标是否能够实现</li>
<li>效益是否可观 <br></li>
</ul>
<p>较高层次的系统分析和设计过程</p>
</blockquote>
<ul>
<li>技术可行性：开发此系统是可行的，是有好处的</li>
<li>经济可行性：根据系统目标衡量所需技术是否具备</li>
<li>操作可行性：系统是否易于使用并能够创造价值</li>
<li>法律可行性：是否存在侵犯、妨碍和责任等问题</li>
</ul>
<blockquote>
<h2 id="可行性研究过程（understanding）"><a href="#可行性研究过程（understanding）" class="headerlink" title="可行性研究过程（understanding）"></a>可行性研究过程（understanding）</h2><p>了解就好</p>
</blockquote>
<ul>
<li><h3 id="复查系统规模和目标"><a href="#复查系统规模和目标" class="headerlink" title="复查系统规模和目标"></a>复查系统规模和目标</h3><ul>
<li>改正含糊或不确切的叙述</li>
<li>清晰地描述限制和约束</li>
<li>确保分析员解决正确的问题</li>
</ul>
</li>
<li><h3 id="研究目前正在使用的系统"><a href="#研究目前正在使用的系统" class="headerlink" title="研究目前正在使用的系统"></a>研究目前正在使用的系统</h3><ul>
<li>完成现有系统的基本功能分析</li>
<li>解决现有系统的问题</li>
<li>绘制高层系统数据流图</li>
<li>掌握与其他系统的接口</li>
</ul>
</li>
<li><h3 id="导出新系统的高层逻辑模型"><a href="#导出新系统的高层逻辑模型" class="headerlink" title="导出新系统的高层逻辑模型"></a>导出新系统的高层逻辑模型</h3><ul>
<li>现有物理系统 → 现有系统的逻辑模型 → 目标系统逻辑模型 → 新的目标系统</li>
<li>高层数据流图</li>
<li>初步的数据字典</li>
</ul>
</li>
<li><h3 id="进一步定义问题"><a href="#进一步定义问题" class="headerlink" title="进一步定义问题"></a>进一步定义问题</h3><ul>
<li>以数据流图和数据字典为基础</li>
<li>复查问题定义、工程规模和目标</li>
<li>分析员和用户</li>
<li>重复1~4步，直至提出的逻辑模型完全符合系统目标</li>
</ul>
</li>
<li><h3 id="导出和评价供选择的解法"><a href="#导出和评价供选择的解法" class="headerlink" title="导出和评价供选择的解法"></a>导出和评价供选择的解法</h3><ul>
<li>从技术角度出发，考虑解决问题的不同方案</li>
<li>技术可行性，排除不现实的系统</li>
<li>操作可行性，排除用户不能接受的方案</li>
<li>经济可行性，排除利润低的方案</li>
<li>制定进度表 (估算生命周期每个阶段的工作量)</li>
</ul>
</li>
<li><h3 id="推荐行动方针（是否做？）"><a href="#推荐行动方针（是否做？）" class="headerlink" title="推荐行动方针（是否做？）"></a>推荐行动方针（是否做？）</h3><ul>
<li>分析员：如果值得开发，则选择最好的解法</li>
<li>用户：成本/效益分析</li>
</ul>
</li>
<li><h3 id="草拟开发计划"><a href="#草拟开发计划" class="headerlink" title="草拟开发计划"></a>草拟开发计划</h3><ul>
<li>工程进度表</li>
<li>各类开发人员、各种资源需求情况</li>
<li>生命周期每个阶段的成本</li>
<li>下一个阶段详细进度表和成本估计</li>
</ul>
</li>
<li><h3 id="书写文档提交审查"><a href="#书写文档提交审查" class="headerlink" title="书写文档提交审查"></a>书写文档提交审查</h3><ul>
<li>用户、客户组织负责人、评审组审查</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="系统流程图-（understanding）"><a href="#系统流程图-（understanding）" class="headerlink" title="系统流程图 （understanding）"></a>系统流程图 （understanding）</h2><p>系统流程图概括描绘物理系统的传统工具用图形符号，以黑盒子形式描述组成系统的每个部件程序、文档、数据库、人工过程</p>
</blockquote>
<ul>
<li>符号：<img src="/img/se_09.jpg"></li>
<li>栗子：<img src="/img/se_10.jpg">
</li>
</ul>
<blockquote>
<h2 id="数据流图-master"><a href="#数据流图-master" class="headerlink" title="数据流图 (master)"></a>数据流图 (master)</h2><p>数据流图(DFD) 描绘信息流和数据从输入移动到输出的过程中所经受的变换。</p>
</blockquote>
<ul>
<li>数据流图的四种基本符号：<img src="/img/se_11.jpg"></li>
<li>加工中常见关系的符号表示：<img src="/img/se_12.jpg"></li>
<li>注意：<ul>
<li>信息的流动</li>
<li>信息流不能为动词</li>
<li>实体到实体的信息流动</li>
<li>处理要有输入输出</li>
<li>处理名不能为名词</li>
<li>确保层间的一致性（确保输入输出流的量是一致的）</li>
</ul>
</li>
<li><p>命名:</p>
<ul>
<li>数据流的名字应代表整个数据流(数据存储、处理)的内容，而不是仅仅某些成分。</li>
<li>不要使用空洞的、缺乏具体含义的名字(如“数据”、“信息”、“输入”之类)。</li>
<li>处理名字最好是一个具体的及物动词。</li>
</ul>
</li>
<li><p>示例：出入库管理系统</p>
<ul>
<li>0级数据流图<img src="/img/se_13.jpg"></li>
<li>1级数据流图<img src="/img/se_14.jpg"></li>
<li>2级数据流图<img src="/img/se_15.jpg">
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="数据字典-master"><a href="#数据字典-master" class="headerlink" title="数据字典 (master)"></a>数据字典 (master)</h2><ul>
<li>数据字典是关于数据的信息的集合，即对设计图中包含的元素的定义。</li>
<li>数据字典的用途是供人查阅不了解的条目的解释，提供分析设计过程中关于数据的描述。</li>
<li>只有设计图和对应的元素的精确定义放在一起，才能构成系统完整的规格说明。</li>
</ul>
</blockquote>
<ul>
<li><h3 id="定义数据的方法"><a href="#定义数据的方法" class="headerlink" title="定义数据的方法"></a>定义数据的方法</h3><ul>
<li>= : 意思是等价于(或定义为);</li>
<li>+ : 意思是和(即，连接两个分量);</li>
<li>[] : 意思是或(即，从方括弧内列出的若干个分量中选择一个)，用“｜”号分开供选择的分量;</li>
<li>{} : 意思是重复(即，重复花括弧内的分量);</li>
<li>() : 意思是可选(即，圆括弧里的分量可有可无);</li>
<li>使用上限和下限进一步注释表示重复的花括弧。<ul>
<li>左边用上角标和下角标分别表明重复的上限和下限</li>
<li>左侧标明重复的下限，在闭括弧的右侧标明上限</li>
<li>例如：<img src="/img/se_16.jpg"></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h4><ul>
<li>北京某高校可用的电话号码有以下几类:校内电话号码由4 位数字组成，第1位<br>数字不是0;校外电话又分为本市电话和外地电话两类,拨校外电话需先拨0,若是本市电<br>话则再接着拨8位数字(第1位不是0),若是外地电话则拨3位区码再拨8<br>位电话号码<br>(第1位不是0)。请用上述提到的定义数据的方法，定义上述的电话号码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">电话号码 = [ 校内电话号码 | 校外电话号码 ]</span><br><span class="line">校内电话号码 = 非零数字 + 3位数字</span><br><span class="line">校外电话号码 = [ 本市电话号码 | 外地电话号码]</span><br><span class="line">本市电话号码 = 数字零 + 8位数字</span><br><span class="line">外地电话号码 = 数字零 + 3位数字 + 8位数字</span><br><span class="line">非零数字 = [1|2|3|4|5|6|7|8|9]</span><br><span class="line">3位数字 = 3&#123;数字&#125;3</span><br><span class="line">数字零 = 0</span><br><span class="line">8位数字 = 非零数字 + 7位数字</span><br><span class="line">7位数字 = 7&#123;数字&#125;7</span><br><span class="line">数字 = [0|1|2|3|4|5|6|7|8|9]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="数字字典的实现"><a href="#数字字典的实现" class="headerlink" title="数字字典的实现"></a>数字字典的实现</h4><ul>
<li>CASE工具</li>
<li>人工卡片</li>
</ul>
<img src="/img/se_17.jpg">
</li>
</ul>
<blockquote>
<h2 id="成本效益分析（了解）"><a href="#成本效益分析（了解）" class="headerlink" title="成本效益分析（了解）"></a>成本效益分析（了解）</h2><p>成本/效益分析是客户从经济角度判断是否继续投资项目的主要依据。</p>
</blockquote>
<ul>
<li><h3 id="成本估计"><a href="#成本估计" class="headerlink" title="成本估计"></a>成本估计</h3><ul>
<li>代码行技术</li>
<li>任务分解技术</li>
</ul>
</li>
<li><h3 id="效益分析"><a href="#效益分析" class="headerlink" title="效益分析"></a>效益分析</h3><ul>
<li>货币的时间价值</li>
<li>投资回报期</li>
<li>纯收入</li>
<li>投资回报率（最重要的参考数据）</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2017/12/22/2017-12-22-软件工程复习（a）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-r.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/22/2017-12-22-软件工程复习（a）/" itemprop="url">软件工程复习（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-22T00:00:00+08:00">
                2017-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="软件危机（understanding）"><a href="#软件危机（understanding）" class="headerlink" title="软件危机（understanding）"></a>软件危机（understanding）</h2><p>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重的问题</p>
</blockquote>
<ul>
<li><h3 id="软件危机的表现"><a href="#软件危机的表现" class="headerlink" title="软件危机的表现"></a>软件危机的表现</h3><ul>
<li>对开发成本和进度的估计往往很不准确</li>
<li>用户对“已完成的”软件系统不满意的现象时常发生</li>
<li>软件质量差</li>
<li>软件通常难以维护</li>
<li>软件没有适当的文档资料</li>
<li>软件成本在计算机系统的总成本中所占的比例逐年上升（软件成本日益增长）</li>
<li>软件开发速度跟不上计算机发展速度</li>
</ul>
</li>
<li><h3 id="产生软件危机的原因"><a href="#产生软件危机的原因" class="headerlink" title="产生软件危机的原因"></a>产生软件危机的原因</h3><ul>
<li><h4 id="技术原因"><a href="#技术原因" class="headerlink" title="技术原因"></a>技术原因</h4><ul>
<li>软件规模越来越大</li>
<li>软件复杂度越来越高</li>
</ul>
</li>
<li><h4 id="管理原因"><a href="#管理原因" class="headerlink" title="管理原因"></a>管理原因</h4><ul>
<li>软件开发缺乏正确的理论指导，过分依赖个人技巧和创造性</li>
<li>对用户需求没有完整准确的认识，就匆忙着手编写程序</li>
</ul>
</li>
<li><h4 id="引入统一变动付出代价随时间变化的趋势"><a href="#引入统一变动付出代价随时间变化的趋势" class="headerlink" title="引入统一变动付出代价随时间变化的趋势"></a>引入统一变动付出代价随时间变化的趋势</h4><img src="/img/se_01.jpg">
<ul>
<li>上图展示的就是软件开发过程中，需求变化出现在开发过程的后期将会带来巨大的修改代价</li>
<li>所以应该在软件开发的早期，甚至是定义的时候就尽量的接近用户的真是需求</li>
<li>但通常，用户的牙膏不会一下子挤完（甚至一开始，大多数用户对自己的需求都不是很明确）<blockquote>
<p>如何克服软件危机？ ==&gt; <strong>软件工程</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="消除软件危机的途径"><a href="#消除软件危机的途径" class="headerlink" title="消除软件危机的途径"></a>消除软件危机的途径</h3><ul>
<li><h4 id="对计算机软件的正确认识"><a href="#对计算机软件的正确认识" class="headerlink" title="对计算机软件的正确认识"></a>对计算机软件的正确认识</h4><ul>
<li>1983年IEEE对软件的定义：计算机<strong>程序</strong>、<strong>方法</strong>、<strong>规则</strong>、相关的<strong>文档</strong>资料以及在计算机上运行程序时所必须的<strong>数据</strong></li>
<li>软件 ≠ 程序</li>
</ul>
</li>
<li><h4 id="软件工程三要素"><a href="#软件工程三要素" class="headerlink" title="软件工程三要素"></a>软件工程三要素</h4><ul>
<li>推广使用开发软件成功的技术和<strong>方法</strong>，并且研究探索更好有效的技术和方法</li>
<li>开发和使用更好的软件<strong>工具</strong></li>
<li>需要组织管理措施（<strong>过程</strong>）</li>
</ul>
</li>
<li><p>总之，为了解决软件危机，既要有<strong>技术措施</strong>（方法和工具），有要有必要的<strong>组织管理措施</strong>。</p>
<blockquote>
<p>无章法（个人英雄主义）=&gt; 工程项目管理模式（团队合作开发）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="软件工程-understanding"><a href="#软件工程-understanding" class="headerlink" title="软件工程(understanding)"></a>软件工程(understanding)</h2><p>1968第一届NATO会议：<br>软件工程称就是为了经济的获得可靠的且在实际机器上有效运行的软件，而建立和使用的完善的工程原理<br><br><br>1993年IEEE：</p>
<ol>
<li>把系统的、规范的、可度量的途径应用于软件开发、运行和维护的过程，也就是把工程应用于软件</li>
<li>研究1中提到的途径</li>
</ol>
</blockquote>
<ul>
<li><h3 id="主要目标：高效开发高质量软件"><a href="#主要目标：高效开发高质量软件" class="headerlink" title="主要目标：高效开发高质量软件"></a>主要目标：高效开发高质量软件</h3></li>
<li><h3 id="软件工程的基本原理"><a href="#软件工程的基本原理" class="headerlink" title="软件工程的基本原理"></a>软件工程的基本原理</h3><ol>
<li>用分阶段的生命周期计划严格管理</li>
<li>坚持进行阶段评审<ul>
<li>错误发现的越晚，所需付出的代价也越大</li>
<li>对每个已完成的阶段进行评审，以便尽早发现错误</li>
</ul>
</li>
<li>实行严格的产品控制<ul>
<li>软件开发过程中不应该随意改动需求，对修改意见需要经过严格的评审后才能实施</li>
</ul>
</li>
<li>采用现代化程序设计技术</li>
<li>结果应该能清楚的审查</li>
<li>开发小组的成员应该少而精</li>
<li>承认不断改进软件工程实践的必要性</li>
</ol>
</li>
<li><h3 id="软件工程方法学"><a href="#软件工程方法学" class="headerlink" title="软件工程方法学"></a>软件工程方法学</h3><blockquote>
<p>通常把在软件生命周期全部过程各种使用的一整套技术方法的集合称为<strong>方法学</strong>（methodology）<br>,也称为<strong>泛型</strong>（paradigm）</p>
</blockquote>
<ul>
<li><h4 id="软件工程方法学3要素"><a href="#软件工程方法学3要素" class="headerlink" title="软件工程方法学3要素"></a>软件工程方法学3要素</h4><ul>
<li>方法：“如何做？”</li>
<li>工具：“用什么做？”</li>
<li>过程：“如何控制、协调、保证质量？”</li>
</ul>
</li>
<li><h4 id="传统方法学（静态分析）"><a href="#传统方法学（静态分析）" class="headerlink" title="传统方法学（静态分析）"></a>传统方法学（静态分析）</h4><ul>
<li>传统方法学也称为<strong>生命周期方法学</strong>或<strong>结构化泛型</strong>，它采用<strong>结构化技术</strong></li>
<li>这种方法学把软件生命周期的全过程依次划分为若干阶段，然后顺序的完成每个阶段的任务</li>
<li>特点：<ul>
<li>生命周期模型</li>
<li>软件过程划分为若干个阶段</li>
<li>每个阶段有各自的任务</li>
<li>阶段之间有某种顺序性<img src="/img/se_02.jpg"></li>
</ul>
</li>
<li>局限：<ul>
<li>当软件规模较大，或对软件的需求是<strong>模糊</strong>的或随时间<strong>变化</strong>的时候，使用结构化泛型开发软件往往不成功</li>
<li>此外，使用传统方法学开发出的软件通常维护起来都很困难</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="面向对象方法学（动态分析）"><a href="#面向对象方法学（动态分析）" class="headerlink" title="面向对象方法学（动态分析）"></a>面向对象方法学（动态分析）</h4><ul>
<li>特点：<ul>
<li>面向对象方法学的出发点和基本原则，是<strong>尽可能模拟人类的思维方式</strong></li>
<li>用面向对象方法学开发软件的过程，是一个<strong>主动</strong>多次<strong>反复迭代</strong>演化的过程</li>
<li>概念和表示方法上的<strong>一致性，阶段间平滑（无缝）过度</strong></li>
<li>特殊到一般的<strong>归纳</strong>思维过程；一般到特殊的<strong>演绎</strong>思维过程（继承的思想）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="软件生命周期-重点"><a href="#软件生命周期-重点" class="headerlink" title="软件生命周期 (重点)"></a>软件生命周期 (重点)</h2><p>概括的说，软件生命周期由<strong>软件定义</strong>、<strong>软件开发</strong>和<strong>运行维护</strong>（也称为软件维护）3个过程</p>
</blockquote>
<ul>
<li><h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><blockquote>
<p>要解决什么问题？</p>
</blockquote>
</li>
<li><h3 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h3><blockquote>
<p>对上一阶段确定的问题是否有行之有效的解决方案？</p>
</blockquote>
</li>
<li><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><blockquote>
<p>目标系统必须做什么？<br><br>用正式的文档记录对目标系统的需求（<strong>规格说明</strong>）</p>
</blockquote>
</li>
<li><h3 id="总体设计（概要设计）"><a href="#总体设计（概要设计）" class="headerlink" title="总体设计（概要设计）"></a>总体设计（概要设计）</h3><blockquote>
<p>概括的说，应该怎样实现目标系统？（从此阶段开始设计实现和技术的细节）<br><br>又称为<strong>初步设计、逻辑设或、概要设计或高层设计</strong></p>
</blockquote>
</li>
<li><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><blockquote>
<p>把上阶段提出的解决方案具体化，回答“应该如何具体的实现这个系统？”<br><br>又称为<strong>模块设计、物理设计或低层设计</strong></p>
</blockquote>
</li>
<li><h3 id="编码和单元测试"><a href="#编码和单元测试" class="headerlink" title="编码和单元测试"></a>编码和单元测试</h3><blockquote>
<p>具体coding。写出正确的容易理解、容易维护的程序模块，并测试</p>
</blockquote>
</li>
<li><h3 id="综合测试"><a href="#综合测试" class="headerlink" title="综合测试"></a>综合测试</h3><blockquote>
<p>集成测试、验收测试、系统测试</p>
</blockquote>
</li>
<li><h3 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h3><blockquote>
<p>通过各种必要的维护活动使系统<strong>持久</strong>地满足用户的需要</p>
</blockquote>
<ul>
<li><h4 id="四类维护活动"><a href="#四类维护活动" class="headerlink" title="四类维护活动"></a>四类维护活动</h4><ul>
<li><strong>改正性维护</strong>：诊断和改正真在使用过程中发现的软件错误</li>
<li><strong>适应性维护</strong>：即修改软件以适应环境的变化</li>
<li><strong>完善性维护</strong>：即根据用户的要求改进或扩充软件使它更完善</li>
<li><strong>预防性维护</strong>：即修改软件为将过来的维护活动预先做准备</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="软件过程-（重点）"><a href="#软件过程-（重点）" class="headerlink" title="软件过程 （重点）"></a>软件过程 （重点）</h2><p>软件过程是为了获得赶工质量软件所需要完成的一些列的任务的框架，它规定了完成各项任务的<strong>工作步骤</strong></p>
</blockquote>
<ul>
<li><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><ul>
<li>阶段间具有顺序性和依赖性</li>
<li><p>推迟实现的观点</p>
<blockquote>
<p>清楚的区分逻辑设计与物理设计，尽可能推迟程序的物理实现</p>
</blockquote>
</li>
<li><p>质量保证的观点</p>
<ul>
<li>每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务</li>
<li>每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误<blockquote>
<p>瀑布模型的成功过在很大程度上由于它基本上是一种<strong>文档驱动的模型</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img src="/img/se_02.jpg">
<ul>
<li><strong>优点</strong>：<br>可强迫开发人员采用规范的方法（例如，结构化技术）； 严格地规定了每个阶段必须提交的文档；要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证</li>
<li><strong>缺点</strong>：<br>瀑布模型是由文档驱动的。由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要。</li>
<li><strong>适用范围</strong>：<br>应用需求明确的项目</li>
</ul>
</li>
</ul>
<ul>
<li><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><ul>
<li>快速建立起可以运行的程序，其功能往往是最终产品功能的<strong>子集</strong></li>
<li>通过将简单的模型给用户试用，<strong>以获取到用户更多更详细的需求</strong>（努力挤牙膏）</li>
<li>快速原型的本质是“<strong>快速</strong>”</li>
<li>原型的用途是获取用户的真正需求，一旦<strong>需求确定</strong>了，<strong>原型将被抛弃</strong>（原型通常没有严格的规范化，缺少文档，难以维护）。<img src="/img/se_03.jpg"></li>
<li>优点：软件产品的开发基本上是线性顺序进行的<ul>
<li>原型系统已经通过与用户交互而得到验证，据此产生的规格说明文档正确地描述了用户需求，，不会因为规格说明文档的错误而进行较大的返工。</li>
<li>开发人员通过建立原型系统已经学到了许多东西，在设计编码阶段发生错误的可能性比较小，自然减少了反馈。</li>
</ul>
</li>
<li>缺点：<ul>
<li>缺乏丰富而强有力的软件工具和开发环境。</li>
<li>缺乏有效的管理机制，还未建立起自己的开发标准。</li>
<li>对设计开发环境要求较高。</li>
<li>在多次重复改变原型的过程中，程序员会感到厌倦。</li>
<li>系统的易变性对测试有一定影响，难于做到彻底测试，更新文档较为困难。</li>
</ul>
</li>
<li>适用范围：有结构的系统或者需求不明确的系统</li>
</ul>
</li>
</ul>
<ul>
<li><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><ul>
<li>增量模型也称为渐增模型。把软件产品作为<strong>一系列增量构件</strong>来设计、编码、集成和测试</li>
<li>每个构件由多个相互作用的模块构成，并且能够完成特定的功能。</li>
<li>使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能。(滚雪球方式)</li>
<li>与瀑布模型相比：<ul>
<li>瀑布模型：力求一次性给用户完整的系统。</li>
<li>增量模型：逐步增加系统功能。</li>
</ul>
</li>
<li>增量模型：<img src="/img/se_04.jpg"></li>
<li><p>一种风险更大的增量模型</p>
<img src="/img/se_05.jpg">
</li>
<li><p>优点：</p>
<ul>
<li>能在较短时间内向用户提交可完成部分工作的产品</li>
<li>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</li>
</ul>
</li>
<li>缺点：待解决的问题必须允许有一个可递增的软件解决方案。如果需要的软件必须将所有的功能表现出来，那么递增的模型是不合适的。还有就是为了递增模型成功，必须找出整个系统的体系结构。</li>
<li><p>适用范围：不能在设定的期限内完成产品时，先推出核心产品</p>
</li>
<li><h4 id="使用这种方法将冒构件无法集成到一起的风险，除非密切地监控整个开过程"><a href="#使用这种方法将冒构件无法集成到一起的风险，除非密切地监控整个开过程" class="headerlink" title="使用这种方法将冒构件无法集成到一起的风险，除非密切地监控整个开过程"></a>使用这种方法将冒构件无法集成到一起的风险，除非密切地监控整个开过程</h4></li>
</ul>
</li>
<li><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><ul>
<li>螺旋模型的基本思想是使用原型及其他方法尽量<strong>降低风险</strong>。</li>
<li>简化的螺旋模型</li>
<li>可以在一定程度上降低风险，但对有些风险也是无能为力的</li>
<li>需要专业的风险评估人员<img src="/img/se_06.jpg"></li>
<li>完整的螺旋模型<img src="/img/se_07.jpg"></li>
<li>优点：<ul>
<li>对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标</li>
<li>减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险</li>
<li>在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别</li>
</ul>
</li>
<li>缺点：仅适用于内部项目，大型项目受限，需要风险分析专家。</li>
<li>适用范围：主要适用于内部开发的大规模软件项目。</li>
</ul>
</li>
</ul>
<ul>
<li><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><ul>
<li><strong>迭代</strong>是OO开发过程的主要特性。</li>
<li>喷泉模型是典型的面向对象生命周期模型。</li>
<li>“喷泉” 体现了面向对象软件开发过程<strong>迭代</strong>和<strong>无缝</strong>的特性。</li>
<li>为避免喷泉模型的过分无序，把一个线性过程作为总目标。</li>
<li>迭代：逐步求精</li>
<li>阶段间没有明显的界限－面向对象的思想保证了各个阶段开发的一致性。</li>
<li>喷泉模型：<img src="/img/se_08.jpg"></li>
</ul>
</li>
<li><h3 id="Rational统一过程"><a href="#Rational统一过程" class="headerlink" title="Rational统一过程"></a>Rational统一过程</h3></li>
<li><h3 id="敏捷过程与极限编程"><a href="#敏捷过程与极限编程" class="headerlink" title="敏捷过程与极限编程"></a>敏捷过程与极限编程</h3><ul>
<li>敏捷软件开发宣言<ul>
<li><strong>个体和交互胜过过程和工具</strong>（Individuals and interactions over processs and tools）</li>
<li><strong>可以工作的软件胜过面面俱到的文档</strong>（Working software over comprehensive socumentation）</li>
<li><strong>客户合作胜过合同谈判</strong>（Customer collaboration over  contract negotiation）</li>
<li><strong>响应变化胜过遵循计划</strong>（Responding to change over following a plan）</li>
</ul>
</li>
<li>敏捷软件开发的原理（The principles of agile methods）<ul>
<li>客户参与（Customer involvement）</li>
<li>增量交付（Incremental delivery）</li>
<li>People not process</li>
<li>拥抱变化（Embrace change）</li>
<li>保持简单（Maintain simplicity）</li>
</ul>
</li>
<li>极限编程有效实践（极限编程是敏捷过程中最富盛名的一个）<ul>
<li>Incremental planning</li>
<li>Small releases</li>
<li>Simple design</li>
<li>Test-first development</li>
<li>Refactoring</li>
<li>Pair programming</li>
<li>Collective ownership</li>
<li>Continuous integration</li>
<li>Sustainable pace</li>
<li>On-site customer</li>
</ul>
</li>
<li>适用范围：<ol>
<li>项目团队的人数不能太多</li>
<li>项目经常发生变更</li>
<li>高风险的项目实施</li>
<li>开发人员可以参与决策</li>
</ol>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2017/11/11/2017-11-11-数据库笔记（补充）——分解算法浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-r.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/11/2017-11-11-数据库笔记（补充）——分解算法浅析/" itemprop="url">数据库笔记（补充）——分解算法浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T00:00:00+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>写在前面：今天笔者将会对BCNF和3NF分解算法做简要的分析，不过实际上大多数的分解用肉眼即可，以下分解算法不依赖于过多的条件可以直接讲一个满足1NF的模式分解为3NF或BCNF</p>
<h2 id="BCNF-分解算法"><a href="#BCNF-分解算法" class="headerlink" title="BCNF 分解算法"></a>BCNF 分解算法</h2><ul>
<li>教材上关于BCNF分解算法的伪代码实现有部分印错（本科教学版）</li>
<li>该算法的结果是一个满足BCNF的无损分解，但可能不是保持依赖的（毕竟3NF是保持依赖并且可以满足无损分解的最高范式）</li>
</ul>
</blockquote>
<ul>
<li><h3 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h3><p>对满足1NF的模式R<u, f="">作如下处理可分解成满足BCNF范式的模式R<sub>1</sub>, R<sub>2</sub>, …, R<sub>n</sub></u,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result := &#123;R&#125;;</span><br><span class="line">        done := <span class="keyword">false</span>;</span><br><span class="line">        计算F+;</span><br><span class="line">        <span class="keyword">while</span>(not done) <span class="keyword">do</span></span><br><span class="line">              <span class="keyword">if</span>(result中存在模式Ri不属于BCNF)</span><br><span class="line">              then begin</span><br><span class="line">                      令 α→β 为一个在Ri上成立的非平凡函数依赖，满足 α→β ∈ F+， 并且 α∩β  = ∅;</span><br><span class="line">                      result := (result - Ri) ∪ (Ri - β) ∪ (α, β)</span><br><span class="line">              end</span><br><span class="line">              <span class="keyword">else</span> done := <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="先来分析一波上面的代码吧"><a href="#先来分析一波上面的代码吧" class="headerlink" title="先来分析一波上面的代码吧"></a>先来分析一波上面的代码吧</h3><ol>
<li>首先令reslut = {R}</li>
<li>接着计算一下F的函数闭包F<sup>+</sup>（计算函数闭包还是挺麻烦的，所以在下面判断的时候挑一个函数依赖，判断一下是否被F逻辑蕴含即可）</li>
<li>然后判断结果集result中是否还存在哪个模式不满足BCNF范式，如果都满足，则直接跳到步骤5，如果存在某个模式 R<sub>i</sub> ∈ result，不满足BCNF范式，则执行步骤4</li>
<li>选择一个在R<sub>i</sub>上成立的非平凡函数依赖 α→β，并且 α→β 属于 F<sup>+</sup>，并且α∩β=∅。然后将模式R<sub>i</sub>分解成两个模式，分别为 (R<sub>i</sub> - β) 和 (α, β)。并且将R<sub>i</sub>从result中移除，江新得到的两个模式添加到result中。接着回到步骤3继续判断</li>
<li>分解完成，输出结果</li>
</ol>
</li>
<li><h3 id="纸上学来终觉浅，让我们拿教材上的栗子出来刷一刷～～"><a href="#纸上学来终觉浅，让我们拿教材上的栗子出来刷一刷～～" class="headerlink" title="纸上学来终觉浅，让我们拿教材上的栗子出来刷一刷～～"></a>纸上学来终觉浅，让我们拿教材上的栗子出来刷一刷～～</h3><ul>
<li>有模式class<u, f="">, 通过上述算法，对其进行满足BCNF范式的分解<ul>
<li>U = {course_id, title, dept_name, credits. sec_id, semester, year, building, room_number, capticy, time_slot_id}</li>
<li>F = {<br>course_id → (title, dept_name, credits),<br>(building, room_number)→capaticy,<br>(course_id, sec_id, semester, year)→(building, room_number, time_slot_id)<br>}</li>
</ul>
</u,></li>
<li>首先还是看一下上面模式的候选码是什么吧（书上的栗子是直接给出来了，但是有些题可能不给，需要自己算）<ul>
<li>通过上一篇博客讲的<a href="http://www.jianshu.com/p/e3eb1dcac59d" target="_blank" rel="noopener">候选码求解算法</a>，容易求得模式class的候选码为{course_id, sec_id, semester, year}</li>
</ul>
</li>
<li>接着判断模式class是否满足BCNF范式<ul>
<li>模式R中存在依赖 course_id → (title, dept_name, credits), 但course_id并不是R的一个超码，故R不满足BCNF范式</li>
<li>对R做如下分解<ul>
<li>course(course_id, title, dept_name, credits)</li>
<li>class_1(course_id, credits. sec_id, semester, year, building, room_number, capticy, time_slot_id)</li>
</ul>
</li>
</ul>
</li>
<li>继续判断，易知course是满足BCNF范式的，而course_1同理不满足BCNF范式， 继续分解<ul>
<li>找到非平凡依赖(building, room_number)→capaticy， 且其属于F</li>
<li>对class_1分解如下<ul>
<li>classroom(building, room_number, capacity)</li>
<li>section(course_id, credits. sec_id, semester, year, building, room_number,  time_slot_id)</li>
</ul>
</li>
</ul>
</li>
<li>检测一下发现现在模式classroom和section也满足BCNF范式了</li>
<li>OK，原来的模式class现在分解为如下三个模式<ul>
<li>course(course_id, title, dept_name, credits)</li>
<li>classroom(building, room_number, capacity)</li>
<li>section(course_id, credits. sec_id, semester, year, building, room_number,  time_slot_id)</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="3NF分解算法"><a href="#3NF分解算法" class="headerlink" title="3NF分解算法"></a>3NF分解算法</h2><p>以下分解算法中用到了正则覆盖的概念，这个笔者在之前的博客中也提到过，<a href="http://www.jianshu.com/p/78d16f97ef0c" target="_blank" rel="noopener">点我传送</a></p>
<ul>
<li>该分解算法可以保持依赖，并且是无损分解</li>
</ul>
</blockquote>
<ul>
<li><h3 id="伪代码实现-1"><a href="#伪代码实现-1" class="headerlink" title="伪代码实现"></a>伪代码实现</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">令Fc为F的正则覆盖;</span><br><span class="line">i:= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> each Fc 中的函数依赖 α→β</span><br><span class="line">        i := i + <span class="number">1</span></span><br><span class="line">        Ri := αβ;</span><br><span class="line"><span class="keyword">if</span> 模式 Rj, j = <span class="number">1</span>, <span class="number">2</span>, ..., i 都不包含R的候选码</span><br><span class="line">then</span><br><span class="line">        i := i + <span class="number">1</span></span><br><span class="line">        Ri := R的任意候选码</span><br><span class="line"><span class="comment">/*(以下代码可选)用来移除冗余关系，如果没有冗余关系则可以不care*/</span></span><br><span class="line">repeat</span><br><span class="line">        <span class="keyword">if</span> 模式 Rj包含于另一个模式Rk中</span><br><span class="line">        then</span><br><span class="line">               <span class="comment">/*删除Rj*/</span></span><br><span class="line">               Rj := Ri</span><br><span class="line">                i := i - <span class="number">1</span></span><br><span class="line">until 不再有可以删除的Rj</span><br><span class="line"><span class="keyword">return</span> (R1, R2, ..., Ri)</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="老规矩，还是先分析一下上面的伪代码"><a href="#老规矩，还是先分析一下上面的伪代码" class="headerlink" title="老规矩，还是先分析一下上面的伪代码"></a>老规矩，还是先分析一下上面的伪代码</h3><ol>
<li>首先求出F的正则覆盖F<sub>c</sub>（实际上就是利用Amstrong公式化简原来的函数依赖集的过程）</li>
<li>接着将F<sub>c</sub>中的每一个函数依赖单独分解成一个模式，得到一个模式列表S = {R<sub>1</sub>, R<sub>2</sub>, …, R<sub>i</sub>}</li>
<li>如果上述模式列表S中的任意一个模式包含模式R的候选码，则跳到步骤5，否则执行步骤4</li>
<li>选取R的任意一个候选码，组成一个新的模式R’, 将R’添加到模式列表S中</li>
<li>（可选）如果模式列表中存在冗余（即某个模式被其他模式包含），则可以删除这个模式</li>
<li>输出S</li>
</ol>
</li>
<li><h3 id="讲真，3NF分解的步骤还是很简单的，主要还是计算一下F的正则覆盖，详细栗子就不举了，下面简单提一提"><a href="#讲真，3NF分解的步骤还是很简单的，主要还是计算一下F的正则覆盖，详细栗子就不举了，下面简单提一提" class="headerlink" title="讲真，3NF分解的步骤还是很简单的，主要还是计算一下F的正则覆盖，详细栗子就不举了，下面简单提一提"></a>讲真，3NF分解的步骤还是很简单的，主要还是计算一下F的正则覆盖，详细栗子就不举了，下面简单提一提</h3><ul>
<li>比如上面分析BCNF分解算法时用到的模式class， 利用上述算法分解之后可以得到和 利用BCNF算法分解一样的结果</li>
<li>所以，神奇的事情发生了，<strong>利用3NF分解算法得到的结果可能还会满足BCNF范式</strong></li>
<li><strong>实践中BCNF分解的另一种途径</strong>： 先用3NF算法分解，然后对结果中不满足BCNF范式的模式用BCNF分解算法分解，如果结果不保持依赖，则回退回3NF</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2017/11/10/2017-11-10-数据库笔记（补充）——候选码的确定方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-r.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/10/2017-11-10-数据库笔记（补充）——候选码的确定方法/" itemprop="url">数据库笔记（补充）——候选码的确定方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-10T00:00:00+08:00">
                2017-11-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>写在前面：前面一堆都了解了解，重点在后面一个关于求候选码的算法（<strong><em>要是题里面没有给主属性，就要通过这个方法求哪些是主属性，哪些不是了，所以还是挺实用的</em></strong>）</p>
<p> <strong>候选码</strong>定义:  设K为关系模式R<u, f="">的属性(组)，若K→<sup>F</sup>U，则称K为R的 <strong>候选码</strong>。</u,></p>
<ul>
<li>主码：若R<u ,="" f="">有多个候选码，则可以从中选定一个作为R的主码。</u></li>
<li>主属性：包含在任一个候选码中的属性，称作主属性。</li>
<li>非主属性：不包含在任一个候选码中的属性，称作非主属性(或非码属性)。</li>
<li>全码：关系模式的码由全部属性构成。</li>
</ul>
</blockquote>
<p>注: <strong>码或者是某一函数依赖的左部, 或是一个属性组</strong>。</p>
<blockquote>
<p>引例：求出关系模式R<u, f="">的所有候选码：<br>U={ A , B , C , D , E }<br>F={AB→C, B→D, C→E, EC→B, AC→B }</u,></p>
</blockquote>
<p>解： 验证AB是否码, 须证明  AB→<sup>F</sup>ABCDE是否成立?<br>∵AB→C(已知), 而AB→AB(自反), ∴AB → ABC(合并)<br>∵B→D(已知), ∴AB→AD(增广), ∴AB → ABCD(合并)<br>∵C→E(已知),  AB→C(已知),  ∴AB → E(传递)<br>   于是 AB → ABCDE(合并)</p>
<p>同理可证：AC也是一个候选码</p>
<h3 id="上述例题实际上就是利用Amstrong公式，最后得到一个属性集可以推出U（关系模式的全集）"><a href="#上述例题实际上就是利用Amstrong公式，最后得到一个属性集可以推出U（关系模式的全集）" class="headerlink" title="上述例题实际上就是利用Amstrong公式，最后得到一个属性集可以推出U（关系模式的全集）"></a>上述例题实际上就是利用Amstrong公式，最后得到一个属性集可以推出U（关系模式的全集）</h3><blockquote>
<p>练习： 根据码的定义，求关系模式R<u, f="">的所有候选码。<br>U={ A , B , C , D }， F={A→ B, C→B }</u,></p>
</blockquote>
<p>答：ACD</p>
<blockquote>
<p>关于2NF的结论</p>
<ol>
<li>不存在非主属性的关系模式属于2NF。 （没有非主属性）</li>
<li>全码关系模式属于2NF。 （没有非主属性）</li>
<li>码只由一个属性组成的关系模式属于2NF。（不会有部分依赖）</li>
<li>二目关系模式属于2NF。 （码或是一个属性，或是全码）</li>
<li>若R属于1NF，但R不一定属于2NF。<br>例如,  关系模式 S(S#, SN, SD, DEAN, C#, G)</li>
</ol>
<p>关于3NF的结论</p>
<ol>
<li>不存在非主属性的关系模式属于3NF。 （没有非主属性）</li>
<li>全码关系模式属于3NF。 （没有非主属性）</li>
<li>二目关系模式属于3NF。 （不会存在传递依赖）</li>
<li>若R属于3NF，那么R也属于2NF。<br>（可证明，反证）</li>
<li>若R属于2NF，但R不一定属于3NF。<br>例如，关系模式 S_SD(S#, SN, SD, DEAN)</li>
</ol>
<p><strong>BCNF</strong>定义：关系模式R<u, f=""> ∈1NF，对于属性组X和Y，若X→Y且Y ∉ X时X必含有码，则R<u, f=""> ∈BCNF</u,></u,></p>
<ul>
<li>由BCNF的定义，对于非平凡的函数依赖:  X  →  Y<ul>
<li>X包含码，或者X本身就是码（换句话说，X是一个超码）</li>
</ul>
</li>
<li>所有非主属性对每一个码都是完全函数依赖，<br> 即, 若R∈BCNF, 则R∈2NF。</li>
<li>所有的主属性对每一个不包含它的码也是完全函数依赖。</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性。</li>
<li>若R∈BCNF, 则必有R∈3NF; 反之不一定成立</li>
</ul>
<h3 id="铛铛铛！！！敲黑板，候选码的求解算法"><a href="#铛铛铛！！！敲黑板，候选码的求解算法" class="headerlink" title="铛铛铛！！！敲黑板，候选码的求解算法"></a>铛铛铛！！！敲黑板，候选码的求解算法</h3><p>以下算法会涉及到求属性集的闭包，<a href="http://www.jianshu.com/p/78d16f97ef0c" target="_blank" rel="noopener">函数依赖集和属性集闭包传送阵</a></p>
</blockquote>
<h4 id="设关系模式R"><a href="#设关系模式R" class="headerlink" title="设关系模式R"></a>设关系模式R<u, f=""></u,></h4><ol>
<li>将R的所有属性<strong>分为 L、 R、N和 LR四类</strong>，并令<strong>X代表L、N两类</strong>，<strong>Y代表LR类</strong>。<ul>
<li>L类: <strong>仅</strong>出现在F的函数依赖<strong>左</strong>部的属性；</li>
<li>R类: <strong>仅</strong>出现在F的函数依赖<strong>右</strong>部的属性；</li>
<li>N类: 在F的函数依赖<strong>左右</strong>两边<strong>都不出现</strong>的属性；</li>
<li>LR类:在F的函数依赖<strong>左右</strong>两边<strong>都出现</strong>的属性 。</li>
</ul>
</li>
<li><strong>求属性集闭包</strong>X<sup>+</sup>，若 X<sup>+</sup>包含了R的全部属性则X即为R的唯一候选码, <strong>转5</strong>;</li>
<li>否则, <strong>在Y中取一属性A</strong>，求属性集闭包(XA)+，若(XA)+包含了R的全部属性，则<strong>转4</strong>；否则，调换一属性反复进行这一过程，直到试完所有Y中的属性。</li>
<li>如果已找出了所有的候选码，则转(5)；否则在Y中依次取2个、3个、…属性，求X与它们的属性集闭包，直到其闭包包含R的全部属性。</li>
<li>停止，输出结果。</li>
</ol>
<ul>
<li>例1： 设关系模式R(A, B, C, D), 其函数依赖集：<pre><code>F={D→B, B→D, AD→B, AC→D}，求R的所有候选码。
</code></pre>解: L类: A, C<br>   R类:<br>   N类:<br>   LR类: B, D<br>因为(AC)<sub>F</sub><sup>+</sup>=ACDB，所以AC是R的唯一候选码</li>
</ul>
<ul>
<li>例2：设关系模式R(A, B, C, D, E, P), 其函数依赖集：<pre><code>F={A→D, E→D, D→B, BC→D, DC→A}，求R的所有候选码。
</code></pre>解:  L类: C, E<br>R类:<br>N类: P<br>LR类: A, B, D<br>因为(CEP)F+=CEPDBA，所以CEP是R的唯一候选码。</li>
</ul>
<ul>
<li>例3： 设关系模式R(S, D, I, B, O, Q), 其函数依赖集:<pre><code>F = { S→D, I→B, B→O, O→Q, Q→I }，求R的所有候选码。
</code></pre>解: L类(S);  R类(D)  ; N类(无) ;  LR类(I, B, O, Q)<pre><code>因为S+=SD, 所以S不是R的候选码；
因为(SI)+=SIDBOQ，所以SI是一个候选码；
因为(SB)+=SBDOQI，所以SB也是一个候选码；
因为(SO)+=SODQIB，所以SO也是一个候选码；
因为(SQ)+=SQDIBO，所以SQ也是一个候选码。
</code></pre></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2017/11/08/2017-11-08-数据库笔记（补充）——数据库设计和E——R模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-r.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/08/2017-11-08-数据库笔记（补充）——数据库设计和E——R模型/" itemprop="url">数据库笔记（补充）——数据库设计和E——R模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-08T00:00:00+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="实体—联系模型"><a href="#实体—联系模型" class="headerlink" title="实体—联系模型"></a>实体—联系模型</h2></blockquote>
<ul>
<li><h3 id="实体集"><a href="#实体集" class="headerlink" title="实体集"></a>实体集</h3><ul>
<li>实体（entity）：现实世界中一个可以区别于其他对象的一个“事物”或对象</li>
<li>实体集（entity set）：相同类型（<strong><em>即具有相同性质/属性</em></strong>）的实体的集合</li>
<li>外延（extension）：属于实体集的实体的实际集合<blockquote>
<p>ps: 实体集和外延的关系类似于之前讲的<a href="http://www.jianshu.com/p/c7f7d50edfa3" target="_blank" rel="noopener">模式和实例的关系</a></p>
</blockquote>
</li>
<li>属性（attribute）：实体集中每个成员所具有的描述性性质</li>
<li>值（value）：每个实体的每个属性都有一个<strong>值</strong></li>
</ul>
</li>
<li><h3 id="联系集"><a href="#联系集" class="headerlink" title="联系集"></a>联系集</h3><ul>
<li><p>联系（relationship）：多个实体间的相互关联</p>
</li>
<li><p>联系集（relationship set）： 相同类型联系的集合</p>
</li>
<li>实体集之间的关联称之为参与：实体集E<sub>1</sub>, E<sub>2</sub>, E<sub>3</sub> <strong>参与</strong> 联系集R</li>
<li>联系也可以具有 <strong>描述性属性</strong></li>
<li>实体在联系中扮演的功能称为<strong>角色</strong></li>
<li>参与联系集的实体集的数目称为<strong>联系集的度</strong>， 二元联系集的度为2</li>
</ul>
</li>
<li><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>域（domain）/ 值集：每个 <strong>属性</strong> 都有一个 <strong>可取值的集合</strong> ，称为该属性的 <strong>域</strong> 或 <strong>值集</strong></p>
</li>
<li><p>简单（simple） 和复合（composite）属性</p>
<ul>
<li>简单属性不可以再分成更小的部分，而复合属性可以(例如下面的name即为复合属性)<br><img src="http://upload-images.jianshu.io/upload_images/7222676-401cb7a8533ae4c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></li>
</ul>
</li>
<li>单值（single-value）和多值（multivalued）属性<ul>
<li>单值：一个实体在的单值属性只对应一个值</li>
<li>多值：一个实体的多值属性可以对应多个值（如，phone_number）</li>
</ul>
</li>
<li><h4 id="派生（derived）属性"><a href="#派生（derived）属性" class="headerlink" title="派生（derived）属性"></a>派生（derived）属性</h4><ul>
<li><p>派生属性的值可以从别的相关属性或实体派生出来</p>
<ul>
<li>eg.:银行账户的余额可以从账户的存取款明细中计算出来</li>
</ul>
</li>
<li><p>派生属性在原则上是不用保存的，但是有时候保存派生属性可以节约计算时间（空间换时间）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul>
<li><h4 id="映射基数约束"><a href="#映射基数约束" class="headerlink" title="映射基数约束"></a>映射基数约束</h4><ul>
<li>一对一（one-to-one）</li>
<li>一对多（one-to-many）</li>
<li>多对一（many-to-one）</li>
<li>多对多（many-to-many）</li>
</ul>
</li>
<li><h4 id="参与约束"><a href="#参与约束" class="headerlink" title="参与约束"></a>参与约束</h4><ul>
<li><p>全部参与：实体集E的每一个实体都参与到联系集R的至少一个联系中</p>
</li>
<li><p>部分参与：实体集E中只有部分实体参与到联系集R的联系中</p>
</li>
</ul>
</li>
<li><h4 id="码"><a href="#码" class="headerlink" title="码"></a>码</h4><ul>
<li>超码</li>
<li>候选码</li>
<li>主码</li>
</ul>
</li>
<li><p>####　从实体集中删除冗余属性</p>
<ul>
<li>要点： <strong>删除其他实体的主键</strong></li>
<li>其他实体的主键相当于外建的存在，一般属于联系集的属性</li>
<li><p>举个栗子：</p>
<ul>
<li><p>instructor(ID, name, dept_name, salary)，其中ID为主键</p>
</li>
<li><p>department(dept_name, building, budget)，其中dept_name为主键</p>
</li>
<li>属性dept_name在两个表中都出现了，所以它属于冗余属性，他又是department的主键，故应该将其从instructor表中移除（实际数据库实现的时候instructor表中是有一个dept_name属性的，他作为一个外建存在，实际上是两者的联系集是简单的1对多的关系，便没有单独成表，而是采用外键相联系）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="实体——联系图"><a href="#实体——联系图" class="headerlink" title="实体——联系图"></a>实体——联系图</h2></blockquote>
<ul>
<li><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ul>
<li><h4 id="分成两部分的矩形-代表-实体集"><a href="#分成两部分的矩形-代表-实体集" class="headerlink" title="分成两部分的矩形 代表 实体集"></a><strong>分成两部分的矩形</strong> 代表 <strong>实体集</strong></h4><p><img src="http://upload-images.jianshu.io/upload_images/7222676-3efdb480d2cbdab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p>
</li>
<li><p><strong>菱形</strong> 代表 <strong>联系集</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7222676-8326ccc00ed7b43e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
</li>
<li><p><strong>未分割的矩形</strong> 代表 <strong>联系集的属性</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/7222676-46db5dae213b6bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p>
</li>
<li><p><strong>线段</strong> 将实体集连接到联系集</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7222676-1c38fc5cfb403d5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p>
</li>
<li><p><strong>虚线</strong> 将联系集属性连接到联系集</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7222676-2cd9d60543960ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"></p>
</li>
<li><strong>双线</strong> 显示实体在联系集中的参与度(用双线与联系集相连表示全部参与)</li>
<li><strong>双菱形</strong> 代表连接到弱实体集的 <strong>标志性实体集</strong></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/7222676-783c1d6c2b081798.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"></p>
</li>
<li><h3 id="映射基数"><a href="#映射基数" class="headerlink" title="映射基数"></a>映射基数</h3><ul>
<li>一对一</li>
<li>一对多</li>
<li>多对一</li>
<li>多对多</li>
</ul>
</li>
<li><h3 id="balabala，图画起来太麻烦了，其他的直接看书，下面聊一聊弱实体集"><a href="#balabala，图画起来太麻烦了，其他的直接看书，下面聊一聊弱实体集" class="headerlink" title="balabala，图画起来太麻烦了，其他的直接看书，下面聊一聊弱实体集"></a>balabala，图画起来太麻烦了，其他的直接看书，下面聊一聊弱实体集</h3></li>
<li><h3 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a>弱实体集</h3><ul>
<li><p>定义：没有足够的属性以形成主码的实体集称之为 <strong>弱实体集（weak entity set）</strong></p>
</li>
<li><p>先举个栗子：(由于简书不支持下划线的写法，所以下面表中所有的主码都用斜体表示)</p>
<ul>
<li><strong>course</strong> (<strong><em>course_id</em></strong>, titles, credits)</li>
<li><strong>section</strong> (<strong><em>sec_id</em></strong>, <strong><em>semester</em></strong>, <strong><em>year</em></strong>)</li>
<li><p>对于上面的两个实体集，参与如下联系集</p>
<ul>
<li>sec_course(course_id, sec_id, semester, year)</li>
</ul>
</li>
<li><p>上面的section实体集实际上就是一个弱联系集</p>
<ul>
<li>一个section实体如果不与一个course对相关联是毫无意义的，并且只有sec_id, semester, year三个属性也是决定不了一个section的</li>
</ul>
</li>
</ul>
</li>
<li>弱实体集必须于另一个称作标识（identifying）或属主和实体集（owner entity set）的实体集相关联才有意义</li>
<li>虽然弱实体集没有主码，但是本身仍要有在依赖于强实体集的基础上的进一步区分的方法，<strong>弱实体集的分辨符/部分码</strong>（discriminator）便可以用来做进一步的区分<ul>
<li>上述例子中的sec_id, semester, year便组成了section的分辨符</li>
<li>在画ER图的时候，组成分辨符的属性底下画虚线（可参见教材 图7-5）</li>
</ul>
</li>
<li>弱实体集的主码由 <strong>标识实体集的主码</strong> 加上 <strong>该弱实体集的分辨符</strong> 构成</li>
<li><h4 id="ER图中的表示"><a href="#ER图中的表示" class="headerlink" title="ER图中的表示"></a>ER图中的表示</h4><ul>
<li>组成分辨符的属性底下画虚线，而不是实线</li>
<li>关联弱实体集和标识性强实体集的联系集以双菱形表示</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="接着，只需要把教材图7-15的图看懂理解，ER图的绘制基本上就没有毛病了"><a href="#接着，只需要把教材图7-15的图看懂理解，ER图的绘制基本上就没有毛病了" class="headerlink" title="接着，只需要把教材图7-15的图看懂理解，ER图的绘制基本上就没有毛病了"></a>接着，只需要把教材图7-15的图看懂理解，ER图的绘制基本上就没有毛病了</h3></li>
</ul>
<blockquote>
<h2 id="ER图转换为关系模式"><a href="#ER图转换为关系模式" class="headerlink" title="ER图转换为关系模式"></a>ER图转换为关系模式</h2><p>这个不难下面简单列几点注意事项</p>
</blockquote>
<ul>
<li><strong>复合属性</strong><ul>
<li>将每个子属性单独作为一个属性来处理</li>
</ul>
</li>
<li><strong>派生属性</strong><ul>
<li>不显示表示出来</li>
</ul>
</li>
<li><strong>多值属性</strong><ul>
<li>单独成表</li>
</ul>
</li>
<li><strong>弱实体集转换</strong><ul>
<li>对于从弱实体集转换而来的模式，该模式的主码由其所依赖的强实体集的主码与弱实体集的分辨符组成</li>
</ul>
</li>
<li><strong>联系集</strong><ul>
<li>多对多的情况一定单独成表</li>
<li>联系集拥有描述性属性的情况单独成表</li>
<li>其它情况下均可不单独成表<ul>
<li>一对一情况下讲任意实体集的主键作为另一个实体集的外建均可</li>
<li>一对多和多对一的情况下，将“一”端的主键作为”多”端的外建</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2017/11/01/2017-11-01-数据库笔记（十二）——函数依赖理论和分解算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-r.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/2017-11-01-数据库笔记（十二）——函数依赖理论和分解算法/" itemprop="url">数据库笔记（十二）——函数依赖理论和分解算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T00:00:00+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="函数依赖理论"><a href="#函数依赖理论" class="headerlink" title="函数依赖理论"></a>函数依赖理论</h2></blockquote>
<ul>
<li><h3 id="逻辑蕴涵"><a href="#逻辑蕴涵" class="headerlink" title="逻辑蕴涵"></a>逻辑蕴涵</h3><ul>
<li><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul>
<li>存在如下条件<ul>
<li>关系模式：r(R)</li>
<li>依赖集：F （由一个或多个依赖组成）</li>
<li>依赖：f</li>
</ul>
</li>
<li><strong>若r(R)满足F</strong> ==&gt; <strong>r(R)满足f</strong></li>
<li>我们称 <strong>F 逻辑蕴涵 f</strong><blockquote>
<p>ps: 其中f可由F通过Armstrong公理推得</p>
</blockquote>
</li>
</ul>
</li>
<li><p>举个栗子：</p>
<ul>
<li><p>给定关系模式 r(A, B, C, G, H, I)</p>
</li>
<li><p>F包含如下依赖</p>
<ul>
<li>A &rarr; B</li>
<li>A &rarr; C</li>
<li>CG &rarr; H</li>
<li>CG &rarr; I</li>
<li>B &rarr; H</li>
</ul>
</li>
<li>函数依赖f : A &rarr; H</li>
<li>其中 f 被 F 逻辑蕴涵<ul>
<li>由Amstrong传递公理可知：A &rarr; B, B &rarr; H ==&gt; A &rarr; H</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="函数依赖集的闭包"><a href="#函数依赖集的闭包" class="headerlink" title="函数依赖集的闭包"></a>函数依赖集的闭包</h3><ul>
<li>令 F 为一个函数依赖集。则 <strong>F的闭包</strong> 是 <strong>被 F 逻辑蕴涵的所有函数依赖的集合</strong></li>
<li>记作：F<sup>+</sup></li>
</ul>
</li>
<li><h3 id="Armstrong公理（Armstrong’s-axiom）"><a href="#Armstrong公理（Armstrong’s-axiom）" class="headerlink" title="Armstrong公理（Armstrong’s axiom）"></a>Armstrong公理（Armstrong’s axiom）</h3><blockquote>
<p>公理是科学的客观规律，不需要自己证明，直接用就行</p>
</blockquote>
<ul>
<li><h4 id="Armstrong-公理"><a href="#Armstrong-公理" class="headerlink" title="Armstrong 公理"></a>Armstrong 公理</h4><ul>
<li>自反律（reflexivity rule）。若α为一个属性集，且β⊆α， 则α&rarr;β<ul>
<li>举个栗子：(A, B)&rarr;A</li>
</ul>
</li>
<li>增补律（augmentation rule）。若α&rarr;β成立且γ为一属性集，则γα&rarr;γβ<ul>
<li>举个栗子：(A, B)&rarr;C ==&gt; (A, B, D, E)&rarr;(C, D, E)</li>
</ul>
</li>
<li>传递律（transitivity rule）。若α&rarr;β和β&rarr;γ成立，则 α&rarr;γ 成立<ul>
<li>举个栗子：A&rarr;B, B&rarr;C ==&gt; A&rarr;C</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="Armstrong公理是完备的，对于一个给定的函数依赖集F，通过Armstrong公理可以产生全部的F"><a href="#Armstrong公理是完备的，对于一个给定的函数依赖集F，通过Armstrong公理可以产生全部的F" class="headerlink" title="Armstrong公理是完备的，对于一个给定的函数依赖集F，通过Armstrong公理可以产生全部的F+"></a>Armstrong公理是完备的，对于一个给定的函数依赖集F，通过Armstrong公理可以产生全部的F<sup>+</sup></h4></li>
<li><h4 id="Armstrong公理的一些推论"><a href="#Armstrong公理的一些推论" class="headerlink" title="Armstrong公理的一些推论"></a>Armstrong公理的一些推论</h4><blockquote>
<p>可由Armstrong公理直接推得，也可以当做公理使用</p>
</blockquote>
<ul>
<li>合并律（union rule）。若α&rarr;β和α&rarr;γ成立，则α&rarr;βγ<ul>
<li>举个栗子：A&rarr;B, A&rarr;C ==&gt; A&rarr;(B, C)</li>
</ul>
</li>
<li>分解律（decomposition rule）。若α&rarr;βγ成立，则α&rarr;β和α&rarr;γ成立<ul>
<li>举个栗子：A&rarr;(B, C) ==&gt; A&rarr;B, A&rarr;C</li>
</ul>
</li>
<li>伪传递律（pseudotransitivity rule）。若α&rarr;β和γβ&rarr;δ成立，则αγ&rarr;δ成立<ul>
<li>举个栗子：A&rarr;B, (B, C)&rarr;D ==&gt; (A, C)&rarr;D</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h3><ul>
<li>令α为一个属性集，我们将函数依赖集 F 下被α 函数确定的所有属性的额集合为称为F下α的闭包</li>
<li>记作：α<sup>+</sup></li>
<li>伪代码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result := α</span><br><span class="line">  repeat</span><br><span class="line">    <span class="keyword">for</span> each 函数依赖 β→γ in F <span class="keyword">do</span></span><br><span class="line">      begin</span><br><span class="line">        <span class="keyword">if</span> β ⊆ result then result := result ∪ γ</span><br><span class="line">      end</span><br><span class="line">  until(result 不变)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h3 id="正则覆盖（极小函数依赖集）"><a href="#正则覆盖（极小函数依赖集）" class="headerlink" title="正则覆盖（极小函数依赖集）"></a>正则覆盖（极小函数依赖集）</h3><ul>
<li>如果<strong>去除函数依赖中的一个属性不改变函数依赖集的闭包</strong>，则称<strong>该属性是无关的</strong></li>
<li>F的<strong>正则覆盖</strong> F<sub>c</sub> 是一个依赖集，使得F逻辑蕴涵F<sub>c</sub> 中的所有依赖，并且F<sub>c</sub> 逻辑蕴涵F中的所有依赖。此外，F<sub>c</sub> 必须具有如下性质 ：<ul>
<li>F<sub>c</sub> 中任何函数依赖都不含无关属性</li>
<li>F<sub>c</sub> 中函数依赖的左半部都是唯一的。即F<sub>c</sub> 中不存在两个依赖α<sub>1</sub>&rarr;β<sub>1</sub>和α<sub>2</sub>&rarr;β<sub>2</sub>， 满足α<sub>1</sub>=α<sub>2</sub></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="无损分解"><a href="#无损分解" class="headerlink" title="无损分解"></a>无损分解</h3><ul>
<li>如果用两个关系模式r<sub>1</sub>(R)和r<sub>2</sub>(R)替代r(R)时没有信息损失，则我们称该分解时无损分解（lossless decomposition）</li>
<li><p>SQL 表示</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 下面查询的结果与r具有相同结果的元组集</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> r1 <span class="keyword">natural</span> <span class="keyword">join</span> r2</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系代数表示：</p>
<ul>
<li>∏<sub>R<sub>1</sub></sub>(r) ⋈ ∏<sub>R<sub>2</sub></sub>(r) = r</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="分解算法（下回分解）"><a href="#分解算法（下回分解）" class="headerlink" title="分解算法（下回分解）"></a>分解算法（下回分解）</h2></blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2017/11/01/2017-11-01-数据库笔记（十一）—— 范式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-r.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/2017-11-01-数据库笔记（十一）—— 范式/" itemprop="url">数据库笔记（十一）—— 范式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T00:00:00+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>一般而言，关系数据库的设计目标是生成一组关系模式，使我们存储信息时<strong>避免不必要的冗余</strong>，并且让我们可以方便地获取信息。这是通过<strong>设计满足适当范式（normal form）的模式来实现</strong>的。</p>
<h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2></blockquote>
<ul>
<li><h3 id="首先有如下两个模式"><a href="#首先有如下两个模式" class="headerlink" title="首先有如下两个模式"></a>首先有如下两个模式</h3><ul>
<li>instructor( <u>ID</u>, name, dept_name, salary )</li>
<li>department( <u>dept_name</u>, building, budget )</li>
</ul>
</li>
<li><h3 id="若将上面两个模式合并成一个大的模式"><a href="#若将上面两个模式合并成一个大的模式" class="headerlink" title="若将上面两个模式合并成一个大的模式"></a>若将上面两个模式合并成一个大的模式</h3><ul>
<li><p>inst_dept(ID, name, salary, dept_name, building, budget)</p>
</li>
<li><p>存在数据冗余（building和budget被存储了多份，实际上每个系的楼和预算只要存一次就好了）</p>
</li>
<li>存在插入、删除和更新异常</li>
</ul>
</li>
<li><h3 id="需要分解成更小的模式"><a href="#需要分解成更小的模式" class="headerlink" title="需要分解成更小的模式"></a>需要分解成更小的模式</h3></li>
<li><h3 id="并不是所有模式的分解都是有益的"><a href="#并不是所有模式的分解都是有益的" class="headerlink" title="并不是所有模式的分解都是有益的"></a>并不是所有模式的分解都是有益的</h3><ul>
<li><p>employee(ID, name, street, city, salary)</p>
</li>
<li><p>分解成下面两个模式</p>
<ul>
<li>employee1(ID, name)</li>
<li>employee2(name, street, city, salary)</li>
</ul>
</li>
<li><p>由于可能存在同名的可能，所以分解以后导致了数据的丢失</p>
<ul>
<li>比如有两个叫Sunny的人，我们用其中一个Sunny的ID去查询他的地址信息的时候，因为存在两份信息相互混淆，导致得不到正确的结果，但是在分解之前通过ID是可以得到唯一的地址的</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="有损分解和无损分解"><a href="#有损分解和无损分解" class="headerlink" title="有损分解和无损分解"></a>有损分解和无损分解</h3><ul>
<li>像上面的例子中，分解以后导致信息丢失的分解称之为有损分解（在实际进行分解时要避免这种分解）</li>
<li>反之则称之为无损分解（无损分解在重新合并后可以得到和分解之前一致的状态）</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2></blockquote>
<ul>
<li><h3 id="什么是函数依赖？"><a href="#什么是函数依赖？" class="headerlink" title="什么是函数依赖？"></a>什么是函数依赖？</h3><ul>
<li>有如下模式<ul>
<li>U = {Sno, Sname, Cno, Sdept, Mname, Grade} (分别代表学号、学生姓名、课程号、系、系主任、分数)</li>
</ul>
</li>
<li>Sname = f(Sno) ==&gt;学生的姓名<strong>函数依赖</strong>于学号<ul>
<li>记作：Sno→Sname</li>
<li>读作：Sno推出Sname</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="非平凡函数依赖和平凡函数依赖"><a href="#非平凡函数依赖和平凡函数依赖" class="headerlink" title="非平凡函数依赖和平凡函数依赖"></a>非平凡函数依赖和平凡函数依赖</h3><ul>
<li>X 和 Y 为模式U中一个或多个属性的集合</li>
<li>非平凡函数依赖<ul>
<li>X→Y，但Y∉X</li>
</ul>
</li>
<li>平凡函数依赖（包含冗余）<ul>
<li>X→Y，且Y∈X</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="完全函数依赖和部分函数依赖"><a href="#完全函数依赖和部分函数依赖" class="headerlink" title="完全函数依赖和部分函数依赖"></a>完全函数依赖和部分函数依赖</h3><blockquote>
<p>写函数依赖时，完全函数依赖和部分函数依赖的写法中，P和F是写在箭头的正上方的，由于Markdown不能很好的展现，就标在了箭头的右上角<br>所以用下面的表示法：</p>
<ul>
<li>&rarr;<sup>F</sup> ：完全依赖</li>
<li>&rarr;<sup>P</sup> ：部分依赖</li>
</ul>
</blockquote>
<ul>
<li>完全函数依赖<ul>
<li>在模式R(U)中X→Y，但是对于任意X的真子集X<sup>’</sup>， 都没有X<sup>‘</sup>→Y, 则称Y完全函数依赖于X，记作<strong>X&rarr;<sup>F</sup>Y</strong></li>
<li>X实际上就是能推出Y的最小集</li>
<li>例如：(Sno, Cno)→Grade</li>
</ul>
</li>
<li>部分函数依赖<ul>
<li>在模式R(U)中X→Y，存在某个X的真子集X<sup>’</sup>， 有X<sup>‘</sup>→Y, 则称Y部分函数依赖于X，记作<strong>X&rarr;<sup>P</sup>Y</strong></li>
<li>例如：(Sno, Cno)→Sdept</li>
<li>而实际上：Sno→Sdept 也是可行的，上面的依赖关系中，Cno是冗余的</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><ul>
<li>X→Y, Y→Z ==&gt; X→Z</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2></blockquote>
<ul>
<li><h3 id="超码、候选码和主码"><a href="#超码、候选码和主码" class="headerlink" title="超码、候选码和主码"></a>超码、候选码和主码</h3><ul>
<li>可以沿用SQL中码的概念</li>
<li>超码是可以唯一标识一个元组的属性集（可以有多个）</li>
<li>候选码是每个超码中去除不必要属性但是仍然能够标识一个元素的最精简属性集（可以有多个）</li>
<li>主码只有一个，在候选码中选一个当做主码</li>
</ul>
</li>
<li><h3 id="用函数依赖来定义"><a href="#用函数依赖来定义" class="headerlink" title="用函数依赖来定义"></a>用函数依赖来定义</h3><ul>
<li>K为R&lt; U, F &gt;中的属性或属性组合，若K→U(→上面有一个F)(<strong><em>即U完全依赖于K</em></strong>)，则称K为R的候选码，若候选码多与一个，则选择其中一个作为主码</li>
</ul>
</li>
<li><h3 id="主属性与非主属性"><a href="#主属性与非主属性" class="headerlink" title="主属性与非主属性"></a>主属性与非主属性</h3><ul>
<li>主属性：包含于某个候选码的属性</li>
<li>非主属性：不被任何候选码包含的属性</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2></blockquote>
<ul>
<li><h3 id="首先还是构造一个例子"><a href="#首先还是构造一个例子" class="headerlink" title="首先还是构造一个例子"></a>首先还是构造一个例子</h3><ul>
<li>R&lt; U, F&gt;</li>
<li>U = {Sno, Sdept, Sloc, Cno, Grade} (分别代表学号、系、系所在楼、课程号、分数)</li>
<li><p>F = {(Sno, Cno)&rarr;<sup>F</sup> Grade, Sno&rarr;Sdept, (Sno, Cno)&rarr;<sup>P</sup> Sdept, Sno&rarr;Sloc, (Sno, Cno)&rarr;<sup>P</sup>Sloc}</p>
</li>
<li><p>主属性：Sno, Cno</p>
</li>
<li>非主属性：Sdept, Sloc, Grade</li>
<li><p>上面的依赖关系可以用下面的图示表示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7222676-4983fb95c40be836.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p>
</li>
</ul>
</li>
<li><h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><ul>
<li><p>一个域是<strong>原子的(atomic)</strong>，则该域的元素被认为是不可分的单元</p>
<ul>
<li>比如name属性就可以不是原子的，name(first_name, middle_name, last_name)</li>
</ul>
</li>
<li><p>一个关系模式<strong>R属于第一范式（1NF）</strong>==&gt;<strong>R上的所有属性都是原子的</strong></p>
</li>
<li><strong>上述例子中的每个属性都是原子的，所以满足第一范式</strong></li>
</ul>
</li>
<li><h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><ul>
<li><h4 id="R-∈-1NF，并且每一个非主属性完全依赖于码（实际上就是在1NF的基础上，去除了非主属性对码的部分函数依赖）"><a href="#R-∈-1NF，并且每一个非主属性完全依赖于码（实际上就是在1NF的基础上，去除了非主属性对码的部分函数依赖）" class="headerlink" title="R ∈ 1NF，并且每一个非主属性完全依赖于码（实际上就是在1NF的基础上，去除了非主属性对码的部分函数依赖）"></a>R ∈ 1NF，并且每一个非主属性完全依赖于码（<strong><em>实际上就是在1NF的基础上，去除了非主属性对码的部分函数依赖</em></strong>）</h4></li>
<li><p>上述例子中存在非主属性对码的部分函数依赖，故不满足2NF</p>
</li>
<li><p>对上述例子作出如下分解</p>
<ul>
<li><p>R1&lt; {Sno, Cno, Grade}, {(Sno, Cno)&rarr;<sup>F</sup>Grade} &gt;</p>
</li>
<li><p>R2&lt; {Sno, Sdept, Sloc}, {Sno&rarr;Sdept, Sdept&rarr;Sloc}&gt;</p>
<ul>
<li>ps:其中R2隐含了Sno&rarr;Sloc (由之后即将学习的AmStrong公理可以推算出来)</li>
</ul>
</li>
<li><p>上面的依赖关系可以用下面的图示表示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7222676-efda4ba5034ec45d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p>
</li>
</ul>
</li>
<li>经过上面的分解之后，每一个非主属性都完全依赖于码了，所以<strong>分解之后的模式满足2NF</strong></li>
</ul>
</li>
<li><h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><ul>
<li><h4 id="R∈2NF-并且不存在非主属性对码的传递依赖（实际上就是在2NF的基础上去除了非主属性对码的传递依赖）"><a href="#R∈2NF-并且不存在非主属性对码的传递依赖（实际上就是在2NF的基础上去除了非主属性对码的传递依赖）" class="headerlink" title="R∈2NF, 并且不存在非主属性对码的传递依赖（实际上就是在2NF的基础上去除了非主属性对码的传递依赖）"></a>R∈2NF, 并且不存在非主属性对码的传递依赖（<strong><em>实际上就是在2NF的基础上去除了非主属性对码的传递依赖</em></strong>）</h4></li>
<li><p>上述经过分解以后的模式中存在非主属性对码的传递依赖，故不满足3NF</p>
<ul>
<li>Sno&rarr;Sdept, Sdept&rarr;Sloc ==&gt; Sno&rarr;Sloc</li>
</ul>
</li>
<li><p>对上面的模式进行进一步的分解</p>
<ul>
<li><p>R1&lt; {Sno, Cno, Grade}, {(Sno, Cno)&rarr;<sup>F</sup>Grade} &gt;</p>
</li>
<li><p>R2&lt; {Sno, Sdept}, {Sno&rarr;Sdept} &gt;</p>
</li>
<li>R3&lt; {Sdept, Sloc}, {Sdept&rarr;Sloc} &gt;</li>
<li><p>上面的依赖关系可以用下面的图示表示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7222676-e2d5ff6d23d6b5a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>经过上面的进一步分解之后，就不存在非主属性对码的传递依赖了，故<strong>进一步分解之后的模式满足3NF</strong><blockquote>
<p>2NF和3NF中的约束都是针对于非主属性的。在日常开发的时候只要ER图设计好，一般都是满足到3NF的，<strong>3NF也是可以保证无损分解的最高范式</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><h3 id="Boyce-Codd范式（BCNF）"><a href="#Boyce-Codd范式（BCNF）" class="headerlink" title="Boyce-Codd范式（BCNF）"></a>Boyce-Codd范式（BCNF）</h3><ul>
<li><h4 id="R-∈-3NF，-并且不存在主属性间的部分函数依赖和传递函数依赖-（实际上就是在3NF的基础上，去除了主属性的部分函数依赖和传递函数依赖）"><a href="#R-∈-3NF，-并且不存在主属性间的部分函数依赖和传递函数依赖-（实际上就是在3NF的基础上，去除了主属性的部分函数依赖和传递函数依赖）" class="headerlink" title="R ∈ 3NF， 并且不存在主属性间的部分函数依赖和传递函数依赖 （实际上就是在3NF的基础上，去除了主属性的部分函数依赖和传递函数依赖）"></a>R ∈ 3NF， 并且不存在主属性间的部分函数依赖和传递函数依赖 （<strong><em>实际上就是在3NF的基础上，去除了主属性的部分函数依赖和传递函数依赖</em></strong>）</h4></li>
<li><p>举个栗子</p>
<ul>
<li>R&lt; U, F &gt;</li>
<li>U = {S, T, J}</li>
<li>F = { (S, J)&rarr;T, (S, T)&rarr;J, T&rarr;J }</li>
<li><p>从上面的函数依赖易判断出：S、T、J都是主属性</p>
<ul>
<li><p>因为{S, J}， {S, T} 都是候选码</p>
</li>
<li><p>因为不存在非主属性，所以该模式已经满足到3NF</p>
</li>
</ul>
</li>
<li><p>上面模式的依赖可以用下面的图示表示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7222676-abbf68932886ee82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p>
</li>
</ul>
</li>
<li>上面的栗子中的模式主属性中存在部分函数依赖，所以不满足BCNF</li>
<li><p>作出如下分解</p>
<ul>
<li>R1&lt; {S, T, J}, { (S, J)&rarr;T, (S, T)&rarr;J } &gt;</li>
<li>R2&lt; {T, J}, { T&rarr;J } &gt;</li>
<li><p>上面的依赖关系可以用下图表示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7222676-5c5e044e2092782d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p>
</li>
</ul>
</li>
<li><p>经过分解之后的模式就不存在主属性间的部分函数依赖和传递函数依赖， 故满足BCNF</p>
<blockquote>
<p>当我们分解不属于BCNF的模式的时候，产生的模式中可能有一个或多个不属于BCNF。在这种情况中，需要进一步分解，其最终结果是一个BCNF的模式集合</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>更高的范式还有第四范式和第五范式，但是应用较少，且考纲不要求，这里就不再赘述了</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2017/10/24/2017-10-24-2017级Android第一次例会/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-r.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/2017-10-24-2017级Android第一次例会/" itemprop="url">2017级Android第一次例会</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-24T00:00:00+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="Android-前世今生"><a href="#Android-前世今生" class="headerlink" title="Android 前世今生"></a>Android 前世今生</h2><table>
<thead>
<tr>
<th style="text-align:center">版本名称</th>
<th style="text-align:center">版本号</th>
<th style="text-align:center">发布时间</th>
<th style="text-align:center">API版本</th>
<th style="text-align:center">官方支持状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Android (Alpha)</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">September 23, 2008</td>
<td style="text-align:center">1</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">Beta (Internally known as “Petit Four”)</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">February 9, 2009</td>
<td style="text-align:center">2</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">Cupcake（纸杯蛋糕）</td>
<td style="text-align:center">1.5</td>
<td style="text-align:center">April 27, 2009</td>
<td style="text-align:center">3</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">Donut（甜甜圈）</td>
<td style="text-align:center">1.6</td>
<td style="text-align:center">September 15, 2009</td>
<td style="text-align:center">4</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">Eclair（闪电泡芙）</td>
<td style="text-align:center">2.0 – 2.1</td>
<td style="text-align:center">October 26, 2009</td>
<td style="text-align:center">5 – 7</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">Froyo（冻酸奶）</td>
<td style="text-align:center">2.2 – 2.2.3</td>
<td style="text-align:center">May 20, 2010</td>
<td style="text-align:center">8</td>
<td style="text-align:center">不支持</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">Gingerbread（姜饼）</td>
<td style="text-align:center">2.3 – 2.3.7</td>
<td style="text-align:center">December 6, 2010</td>
<td style="text-align:center">9 – 10</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">Honeycomb（蜂巢）</td>
<td style="text-align:center">3.0 – 3.2.6</td>
<td style="text-align:center">February 22, 2011</td>
<td style="text-align:center">11 – 13</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">Ice Cream Sandwich（冰淇淋三明治）</td>
<td style="text-align:center">4.0 – 4.0.4</td>
<td style="text-align:center">October 18, 2011</td>
<td style="text-align:center">14 – 15</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">Jelly Bean（果冻豆）</td>
<td style="text-align:center">4.1 – 4.3.1</td>
<td style="text-align:center">July 9, 2012</td>
<td style="text-align:center">16 – 18</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">KitKat（奇巧巧克力棒）</td>
<td style="text-align:center">4.4 – 4.4.4</td>
<td style="text-align:center">October 31, 2013</td>
<td style="text-align:center">19</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">Lollipop（棒棒糖）</td>
<td style="text-align:center">5.0 – 5.1.1</td>
<td style="text-align:center">November 12, 2014</td>
<td style="text-align:center">21 – 22</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">Marshmallow（棉花糖）</td>
<td style="text-align:center">6.0 – 6.0.1</td>
<td style="text-align:center">October 5, 2015</td>
<td style="text-align:center">23</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">Nougat（牛轧糖）</td>
<td style="text-align:center">7.0 – 7.1.2</td>
<td style="text-align:center">August 22, 2016</td>
<td style="text-align:center">24 – 25</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">O/Oreo（奥利奥）</td>
<td style="text-align:center">8.0</td>
<td style="text-align:center">August 22, 2017</td>
<td style="text-align:center">26</td>
<td style="text-align:center">支持</td>
</tr>
</tbody>
</table>
<h2 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h2><p>组里主要以Java语言为主，同时会介绍一些Kotlin开发Android。<br>90% Java + 10% Kotlin</p>
<ul>
<li>Java</li>
<li>Kotlin</li>
<li>C++</li>
<li>…<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2></li>
<li>Eclipse（拒绝）</li>
<li>Visual Studio</li>
<li>Android Studio(推荐)<ul>
<li>2.3（稳定版）==&gt;不支持Kotlin</li>
<li>3.0（pre）==&gt;支持Kotlin，对Java8有较好的支持<h2 id="Java-环境配置："><a href="#Java-环境配置：" class="headerlink" title="Java 环境配置："></a>Java 环境配置：</h2>Kotlin 可以基于JVM，不需要额外配置，IDEA中可直接创建Kotlin项目</li>
</ul>
</li>
<li><a href="http://www.jianshu.com/p/21abe20aadf2" target="_blank" rel="noopener">点此传送进行Java环境配置</a>（<a href="http://www.jianshu.com/p/21abe20aadf2）" target="_blank" rel="noopener">http://www.jianshu.com/p/21abe20aadf2）</a><ul>
<li>最好是下专业版IDEA（专业版需要注册码，可以用学校邮箱注册学生账号，可免费一年，过期需要手动再次激活）</li>
</ul>
</li>
<li>Java书籍推荐<ul>
<li>入门：《Java核心技术 卷Ⅰ》、《疯狂Java讲义》</li>
<li>进阶：《Java编程思想》、《Java核心技术 卷Ⅱ》</li>
<li>强烈安利：《Effective Java》（这本书建议对Java有一定的熟悉程度，并有一定开发经验之后再看，会受益匪浅）</li>
</ul>
</li>
<li>电子书资源：<ul>
<li><a href="http://pan.baidu.com/s/1boXCxbT" target="_blank" rel="noopener">点我下载</a>（<a href="http://pan.baidu.com/s/1boXCxbT）" target="_blank" rel="noopener">http://pan.baidu.com/s/1boXCxbT）</a><h2 id="Android环境配置"><a href="#Android环境配置" class="headerlink" title="Android环境配置"></a>Android环境配置</h2></li>
</ul>
</li>
<li><a href="https://developers.google.cn/" target="_blank" rel="noopener">Google Developer </a>（<a href="https://developers.google.cn/）" target="_blank" rel="noopener">https://developers.google.cn/）</a><ul>
<li><a href="https://developer.android.google.cn/index.html" target="_blank" rel="noopener">Google Android Developer</a></li>
</ul>
</li>
<li>IDE 下载：<ul>
<li>建议下载最新的Android Studio3.0预览版（稳定版和预览版可以共存，所以你也可以2.3和3.0都装）</li>
<li><a href="https://developer.android.google.cn/studio/archive.html" target="_blank" rel="noopener">官网下载 </a></li>
<li><a href="http://www.android-studio.org/" target="_blank" rel="noopener">Android中文社区，可下载2.3.3和3.0预览版稳定版AS</a>（<a href="http://www.android-studio.org/）" target="_blank" rel="noopener">http://www.android-studio.org/）</a></li>
</ul>
</li>
<li>环境配置<ul>
<li><a href="http://blog.csdn.net/siwuxie095/article/details/53431818" target="_blank" rel="noopener">CSDN教程</a></li>
<li><a href="http://www.jikexueyuan.com/course/636.html" target="_blank" rel="noopener">极客学院视频教程</a></li>
</ul>
</li>
<li><a href="http://ke.jikexueyuan.com/zhiye/android/" target="_blank" rel="noopener">极客学院视频</a></li>
<li><a href="http://pan.baidu.com/s/1gfozi4z" target="_blank" rel="noopener">极客学院离线视频资源</a></li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2017/10/17/2017-10-17-数据库笔记（十）——关系代数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-r.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/17/2017-10-17-数据库笔记（十）——关系代数/" itemprop="url">数据库笔记（十）——关系代数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-17T00:00:00+08:00">
                2017-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>每一种基本运算的结果都是一个新的关系，可以用这个关系继续参与运算，借此便可进行复杂的运算</p>
</blockquote>
<ul>
<li><h3 id="选择运算（select）-gt-相当于SQL语句中的WHERE子句的职能"><a href="#选择运算（select）-gt-相当于SQL语句中的WHERE子句的职能" class="headerlink" title="选择运算（select）==&gt;相当于SQL语句中的WHERE子句的职能"></a>选择运算（select）==&gt;相当于SQL语句中的WHERE子句的职能</h3><ul>
<li><h4 id="格式：σ选择谓词-关系"><a href="#格式：σ选择谓词-关系" class="headerlink" title="格式：σ选择谓词(关系)"></a>格式：σ<sub>选择谓词</sub>(关系)</h4></li>
<li><p>举个栗子：</p>
<ul>
<li><p>σ<sub>SAL&gt;1000</sub>(EMP)</p>
</li>
<li><p>上式表示取出查询工资大于1000的所有员工的信息</p>
</li>
<li>等价于下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> SAL &gt; <span class="number">1000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>选择谓词的分类</p>
<ul>
<li>比较：=、≠、&lt;、≤、&gt;和≥</li>
<li>连词：and(∧)、or(∨)和not(¬)==&gt;可以将多个谓词合并成一个大的谓词</li>
<li>可以包括两个属性（字段的比较）：σ<sub>COMM&gt;SAL</sub>(EMP)表示抽成大于工资的人</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="投影运算（project）-gt-相当于SQL语句中的SELECT子句的职能"><a href="#投影运算（project）-gt-相当于SQL语句中的SELECT子句的职能" class="headerlink" title="投影运算（project）==&gt;相当于SQL语句中的SELECT子句的职能"></a>投影运算（project）==&gt;相当于SQL语句中的SELECT子句的职能</h3><ul>
<li><h4 id="格式：∏字段序列-关系"><a href="#格式：∏字段序列-关系" class="headerlink" title="格式：∏字段序列(关系)"></a>格式：∏<sub>字段序列</sub>(关系)</h4></li>
<li><p>举个栗子</p>
<ul>
<li><p>∏<sub>ENAME,SAL</sub>(EMP)</p>
</li>
<li><p>上式表示查看所有员工的姓名和工资</p>
</li>
<li>等价于下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ENAME, SAL</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="关系的组合运算-gt-就像SQL中select、where子句那样的组合效果"><a href="#关系的组合运算-gt-就像SQL中select、where子句那样的组合效果" class="headerlink" title="关系的组合运算==&gt;就像SQL中select、where子句那样的组合效果"></a>关系的组合运算==&gt;就像SQL中select、where子句那样的组合效果</h3><ul>
<li><p>举个栗子</p>
<ul>
<li><p>∏<sub>ENAME,SAL</sub>(σ<sub>SAL&gt;1000</sub>(EMP))</p>
</li>
<li><p>上面的式子求出了所有工资大于1000的员工的名字和工资(实际上就是将<strong>σ<sub>SAL&gt;1000</sub>(EMP)</strong>执行的结果当做一个临时的关系，参与了投影运算得到的)</p>
</li>
<li>等价于下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ENAME, SAL</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> SAL &gt; <span class="number">1000</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>事实关系的组合运算就是那么简单，分析的时候把每个简单运算的结果当做一个新的关系参与后面的运算，这样一层层剥开来，再复杂的语句也变得容易分析</p>
</li>
</ul>
</li>
<li><h3 id="并运算（union）-gt-相当于SQL中UNION关键字的职能"><a href="#并运算（union）-gt-相当于SQL中UNION关键字的职能" class="headerlink" title="并运算（union）==&gt;相当于SQL中UNION关键字的职能"></a>并运算（union）==&gt;相当于SQL中UNION关键字的职能</h3><ul>
<li><h4 id="格式：（关系r）∪（关系s）"><a href="#格式：（关系r）∪（关系s）" class="headerlink" title="格式：（关系r）∪（关系s）"></a>格式：（关系r）∪（关系s）</h4></li>
<li><p>举个栗子</p>
<ul>
<li><p>∏<sub>ENAME,SAL</sub>(σ<sub>SAL&gt;1000</sub>(EMP)) ∪ ∏<sub>ENAME,SAL</sub>(σ<sub>COMM&gt;300</sub>(EMP))</p>
</li>
<li><p>上面的式子求出了所有工资大于1000或抽成大于300的员工的姓名和工资，等价于下面的SQL语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ENAME, SAL</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> SAL &gt; <span class="number">1000</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> ENAME, SAL</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> COMM &gt; <span class="number">300</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>几点需要额外注意的</strong>：</p>
<ul>
<li><p>此处的并运算是集合运算，所以结果是去重的，结果集中不存在重复的元组（<strong><em>而在SQL语句中，指定UNION ALL是可以保留重复的</em></strong>）</p>
</li>
<li><p>关系r与关系s必须是同元的，即它们的属性的数目要求必须相同（这就和SQL语句中UNION使用的时候要求上下两个语句的字段数相同是一样的意思）</p>
</li>
<li>关系r和关系s对应位置的属性域应该是类型兼容的（同样和SQL中UNION使用时，每个对应位置字段类型兼容是一样的意思）</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="集合的差运算（set-defference）-gt-相当于SQL语句中的EXCEPT"><a href="#集合的差运算（set-defference）-gt-相当于SQL语句中的EXCEPT" class="headerlink" title="集合的差运算（set-defference）==&gt;相当于SQL语句中的EXCEPT"></a>集合的差运算（set-defference）==&gt;相当于SQL语句中的EXCEPT</h3><ul>
<li><h4 id="格式：-关系r-关系s"><a href="#格式：-关系r-关系s" class="headerlink" title="格式：(关系r)-(关系s)"></a>格式：(关系r)-(关系s)</h4></li>
<li><p>举个栗子</p>
<ul>
<li>∏<sub>ENAME,SAL</sub>(σ<sub>SAL&gt;1000</sub>(EMP)) - ∏<sub>ENAME,SAL</sub>(σ<sub>COMM&gt;300</sub>(EMP))</li>
<li>上面的式子表示工资大于1000但抽成不大于300的员工的姓名和工资，等价于下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ENAME, SAL</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> SAL &gt; <span class="number">1000</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> ENAME, SAL</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> COMM &gt; <span class="number">300</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>几点需要额外注意的</strong>：</p>
<ul>
<li>此处的注意同上面的并运算的注意事项</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="笛卡尔积运算（Cartesian-product）-gt-等价于SQL语句中两个表进行笛卡尔积（全匹配）得到的结果，即SQL中进行多表连接时不指定连接条件的情况"><a href="#笛卡尔积运算（Cartesian-product）-gt-等价于SQL语句中两个表进行笛卡尔积（全匹配）得到的结果，即SQL中进行多表连接时不指定连接条件的情况" class="headerlink" title="笛卡尔积运算（Cartesian-product）==&gt;等价于SQL语句中两个表进行笛卡尔积（全匹配）得到的结果，即SQL中进行多表连接时不指定连接条件的情况"></a>笛卡尔积运算（Cartesian-product）==&gt;等价于SQL语句中两个表进行笛卡尔积（全匹配）得到的结果，即SQL中进行多表连接时不指定连接条件的情况</h3><ul>
<li><h4 id="格式：-关系r-×-关系"><a href="#格式：-关系r-×-关系" class="headerlink" title="格式：(关系r)×(关系)"></a>格式：(关系r)×(关系)</h4></li>
<li><p>举个栗子：</p>
<ul>
<li>EMP × DEPT</li>
<li>上面的式子表示两个表进行全匹配，等价于下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> EMP, DEPT</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>下面两个式子是等价的</p>
<ul>
<li><strong>∏<sub>ENAME,DNAME</sub>(σ<sub>EMP.DEPTNO=DEPT.DEPTNO</sub>(σ<sub>JOB=”MANAGER”</sub>(EMP×DEPT)))</strong></li>
<li><strong>∏<sub>ENAME,DNAME</sub>(σ<sub>EMP.DEPTNO=DEPT.DEPTNO</sub>((σ<sub>JOB=”MANAGER”</sub>(EMP))×DEPT)</strong></li>
<li>下面是对这两个式子的SQL转化，转化之后就一目了然了<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对应第一个式子</span></span><br><span class="line"><span class="keyword">SELECT</span> ENAME, DNAME</span><br><span class="line"><span class="keyword">FROM</span> EMP <span class="keyword">JOIN</span> DEPT <span class="keyword">ON</span> EMP.DEPTNO = DEPT.DEPTNO</span><br><span class="line"><span class="keyword">WHERE</span> JOB = <span class="string">'MANAGER'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对应第二个式子</span></span><br><span class="line"><span class="keyword">SELECT</span> ENAME, DNAME</span><br><span class="line"><span class="keyword">FROM</span> DEPT <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> *</span><br><span class="line">                <span class="keyword">FROM</span> EMP</span><br><span class="line">                <span class="keyword">WHERE</span> JOB = <span class="string">'MANAGER'</span>)</span><br><span class="line">          <span class="keyword">ON</span> EMP.DEPTNO = DEPT.DEPTNO</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="更名运算（rename）-gt-等价于SQL语句中as的职能"><a href="#更名运算（rename）-gt-等价于SQL语句中as的职能" class="headerlink" title="更名运算（rename）==&gt;等价于SQL语句中as的职能"></a>更名运算（rename）==&gt;等价于SQL语句中as的职能</h3><ul>
<li><h4 id="格式：ρX-A1-A2-…-An-E-gt-表示的是将关系E更名为X，Ai表示的是给E的第i个字段指定别名"><a href="#格式：ρX-A1-A2-…-An-E-gt-表示的是将关系E更名为X，Ai表示的是给E的第i个字段指定别名" class="headerlink" title="格式：ρX(A1,A2,…,An)(E)==&gt;表示的是将关系E更名为X，Ai表示的是给E的第i个字段指定别名"></a>格式：ρ<sub>X(A<sub>1</sub>,A<sub>2</sub>,…,A<sub>n</sub>)</sub>(E)==&gt;表示的是将关系E更名为X，A<sub>i</sub>表示的是给E的第i个字段指定别名</h4></li>
<li>举个栗子<ul>
<li>∏<sub>ENAME,DNAME</sub>(σ<sub>e.DEPTNO=d.DEPTNO</sub>(σ<sub>JOB=”MANAGER”</sub>(ρ<sub>e</sub>(EMP)×ρ<sub>d</sub>(DEPT))))</li>
<li>上面式子含义就不解释了，是上面举的栗子，只是引入了更名运算符，它等价于下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ENAME, DNAME</span><br><span class="line"><span class="keyword">FROM</span> EMP e <span class="keyword">JOIN</span> DEPT d <span class="keyword">ON</span> e.DEPTNO = d.DEPTNO</span><br><span class="line"><span class="keyword">WHERE</span> JOB = <span class="string">'MANAGER'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="来，学习完上面的基本运算，来做个实际的栗子，要求找到员工表中的最高工资（因为目前还没有介绍类似SQL中组函数的操作，后面会介绍。所以通过以下方式来实现）"><a href="#来，学习完上面的基本运算，来做个实际的栗子，要求找到员工表中的最高工资（因为目前还没有介绍类似SQL中组函数的操作，后面会介绍。所以通过以下方式来实现）" class="headerlink" title="来，学习完上面的基本运算，来做个实际的栗子，要求找到员工表中的最高工资（因为目前还没有介绍类似SQL中组函数的操作，后面会介绍。所以通过以下方式来实现）"></a>来，学习完上面的基本运算，来做个实际的栗子，要求找到员工表中的最高工资（因为目前还没有介绍类似SQL中组函数的操作，后面会介绍。所以通过以下方式来实现）</h3><ul>
<li>step1: 找到所有不是最高工资的人<ul>
<li><strong>∏<sub>e1.SAL</sub>(σ<sub>e<sub>1</sub>.sal &lt; e<sub>2</sub>.sal</sub>(ρ<sub>e<sub>1</sub></sub>(EMP)×ρ<sub>e<sub>2</sub></sub>(EMP)))</strong></li>
</ul>
</li>
<li>step2: 用所有的员工减去上面的员工，即得到最高工资<ul>
<li><strong>∏<sub>SAL</sub>(EMP) - ∏<sub>e1.SAL</sub>(σ<sub>e<sub>1</sub>.sal &lt; e<sub>2</sub>.sal</sub>(ρ<sub>e<sub>1</sub></sub>(EMP)×ρ<sub>e<sub>2</sub></sub>(EMP)))</strong></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="在书写关系运算表达式的时候可以用序列号代替字段名（但是不直观，不常用，一般不用）"><a href="#在书写关系运算表达式的时候可以用序列号代替字段名（但是不直观，不常用，一般不用）" class="headerlink" title="在书写关系运算表达式的时候可以用序列号代替字段名（但是不直观，不常用，一般不用）"></a>在书写关系运算表达式的时候可以用序列号代替字段名（但是不直观，不常用，一般不用）</h3><ul>
<li>举个栗子<ul>
<li>∏<sub>$6</sub>(σ<sub>$6 &lt; $14</sub>(EMP×EMP))</li>
<li>等价于下面的运算</li>
<li>∏<sub>e1.SAL</sub>(σ<sub>e<sub>1</sub>.sal &lt; e<sub>2</sub>.sal</sub>(ρ<sub>e<sub>1</sub></sub>(EMP)×ρ<sub>e<sub>2</sub></sub>(EMP)))</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="附加运算"><a href="#附加运算" class="headerlink" title="附加运算"></a>附加运算</h2><p>附加运算是由基本运算组成的，不能增强基本运算的运算能力，但是能简化运算</p>
</blockquote>
<ul>
<li><h3 id="集合交运算（intersection）-gt-相当于SQL语句中INTERSECT关键字的职能"><a href="#集合交运算（intersection）-gt-相当于SQL语句中INTERSECT关键字的职能" class="headerlink" title="集合交运算（intersection）==&gt;相当于SQL语句中INTERSECT关键字的职能"></a>集合交运算（intersection）==&gt;相当于SQL语句中INTERSECT关键字的职能</h3><ul>
<li><h4 id="格式：-关系r-∩-关系s"><a href="#格式：-关系r-∩-关系s" class="headerlink" title="格式：(关系r)∩(关系s)"></a>格式：(关系r)∩(关系s)</h4></li>
<li>因为集合交运算是可以由前面的基本运算组合产生的，所以把它归到附加运算<ul>
<li>A ∩ B &lt;=&gt; A - (A - B)</li>
</ul>
</li>
<li>举个栗子<ul>
<li>∏<sub>ENAME,SAL</sub>(σ<sub>SAL&gt;1000</sub>(EMP)) ∩ ∏<sub>ENAME,SAL</sub>(σ<sub>COMM&gt;300</sub>(EMP))</li>
<li>上面的式子表示工资大于1000并且抽成大于300的员工的姓名和工资，等价于下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ENAME, SAL</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> SAL &gt; <span class="number">1000</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> ENAME, SAL</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> COMM &gt; <span class="number">300</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="自然连接（natural-join）-gt-相当于SQL语句中的NATURAL-JOIN"><a href="#自然连接（natural-join）-gt-相当于SQL语句中的NATURAL-JOIN" class="headerlink" title="自然连接（natural join）==&gt; 相当于SQL语句中的NATURAL JOIN"></a>自然连接（natural join）==&gt; 相当于SQL语句中的NATURAL JOIN</h3><ul>
<li><h4 id="格式：-关系-⋈-关系"><a href="#格式：-关系-⋈-关系" class="headerlink" title="格式：(关系)⋈(关系)"></a>格式：(关系)⋈(关系)</h4></li>
<li><h4 id="自然连接的形式化定义"><a href="#自然连接的形式化定义" class="headerlink" title="自然连接的形式化定义"></a>自然连接的形式化定义</h4><ul>
<li>r,s是两个关系</li>
<li>R，S是上面两个关系对应的关系模式（其实就是上述两个关系各自的属性列表）</li>
<li>R ∩ S 表示r和s的同名属性列表</li>
<li>R ∪ S 表示出现在r或s上的属性名列表(是一个集合，不包同名属性，存在同名属性会去重)</li>
<li>R - S 表示出现在R上，但不出现在S上的属性名列表</li>
<li>则可做如下定义</li>
<li>r⋈s = ∏<sub>R∪S</sub>(σ<sub>r.A<sub>1</sub>=s.A<sub>1</sub> ∧ r.A<sub>2</sub>=s.A<sub>2</sub> ∧ … ∧ r.A<sub>n</sub>=s.A<sub>n</sub></sub>(r×s)) ，其中 R∩S={A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>}</li>
</ul>
</li>
<li>举个栗子<ul>
<li>∏<sub>name, course_id</sub>(instructor ⋈ teaches)</li>
<li>上面的式子列出了所有老师的名字以及其所授课程的id，等价于下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, course_id</span><br><span class="line"><span class="keyword">FROM</span> intructor <span class="keyword">natural</span> <span class="keyword">join</span> teaches</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>ps: 两个关系模式执行自然连接以后属性的排布顺序：</p>
<ul>
<li>排在最前面的是两个关系模式相同的属性</li>
<li>其次是只属于第一个关系模式的属性</li>
<li>最后是只属于第二个关系模式的属性<h4 id="！！！所以所两个关系模式进行自然连接以后，总的属性的个数是减少了，具体减少的个数等于同名属性的个数"><a href="#！！！所以所两个关系模式进行自然连接以后，总的属性的个数是减少了，具体减少的个数等于同名属性的个数" class="headerlink" title="！！！所以所两个关系模式进行自然连接以后，总的属性的个数是减少了，具体减少的个数等于同名属性的个数"></a>！！！所以所两个关系模式进行自然连接以后，总的属性的个数是减少了，具体减少的个数等于同名属性的个数</h4></li>
</ul>
</blockquote>
</li>
<li><h3 id="theta连接-gt-是自然连接的扩展，相当于SQL中的join-on"><a href="#theta连接-gt-是自然连接的扩展，相当于SQL中的join-on" class="headerlink" title="theta连接==&gt;是自然连接的扩展，相当于SQL中的join on"></a>theta连接==&gt;是自然连接的扩展，相当于SQL中的join on</h3><ul>
<li><h4 id="格式：-关系-⋈Θ-关系"><a href="#格式：-关系-⋈Θ-关系" class="headerlink" title="格式：(关系)⋈Θ(关系)"></a>格式：(关系)⋈<sub>Θ</sub>(关系)</h4></li>
<li>形式化定义：<ul>
<li>r ⋈<sub>Θ</sub> s = σ<sub>Θ</sub>(r × s)</li>
</ul>
</li>
<li>举个栗子<ul>
<li>∏<sub>name, course_id</sub>(instructor ⋈<sub>intructor.SAL &gt; 5000 </sub> teaches)</li>
<li>上面的式子表示列出所有工资高于5000的老师的名字以及其所授课程的id， 等价于下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, course_id</span><br><span class="line"><span class="keyword">FROM</span> instructor <span class="keyword">join</span> teaches <span class="keyword">on</span> instructor.ID = teaches.ID</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="除运算（division）"><a href="#除运算（division）" class="headerlink" title="除运算（division）"></a>除运算（division）</h3><blockquote>
<p>这个在书上没讲，是老师上课的时候补充的</p>
</blockquote>
<ul>
<li><h4 id="格式：-关系-÷-关系"><a href="#格式：-关系-÷-关系" class="headerlink" title="格式：(关系)÷(关系)"></a>格式：(关系)÷(关系)</h4></li>
<li>形式化定义：<br>R÷S = ∏<sub>R∪S</sub>( ( ∏<sub>R-S</sub>(r) × S ) - ∏<sub>R-S, S</sub>(r) )</li>
<li>解释起来挺麻烦的，这边给出一个博客链接：<a href="http://blog.csdn.net/qq_22627687/article/details/53789362" target="_blank" rel="noopener">点我</a></li>
</ul>
</li>
<li><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><blockquote>
<p>就是将一个关系表达式的结果赋值取一个临时的名字，就相当于定义了一个临时关系。这个操作就相当于SQL中with语句的职能</p>
</blockquote>
<ul>
<li><h4 id="格式：-temp-name-←-关系表达式"><a href="#格式：-temp-name-←-关系表达式" class="headerlink" title="格式： temp_name ← 关系表达式"></a>格式： temp_name ← 关系表达式</h4></li>
<li>举个栗子：<br>temp1 ← R × S<br>temp2 ← σ<sub>r.A<sub>1</sub>=s.A<sub>1</sub> ∧ r.A<sub>2</sub>=s.A<sub>2</sub> ∧ … ∧ r.A<sub>n</sub>=s.A<sub>n</sub></sub>(temp1)<br>result = ∏<sub>R∪S</sub>(temp2)</li>
<li>上面的式子等价于： result = r⋈s</li>
</ul>
</li>
<li><h3 id="外连接运算"><a href="#外连接运算" class="headerlink" title="外连接运算"></a>外连接运算</h3><ul>
<li>左外连：⟕</li>
<li>右外连：⟖</li>
<li>全外连：⟗</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="扩展运算"><a href="#扩展运算" class="headerlink" title="扩展运算"></a>扩展运算</h2><p>扩展运算是不能用基本的关系代数运算来实现的一类查询，可以满足复杂的查询需求</p>
</blockquote>
<ul>
<li><h3 id="广义投影（Generalized-projection）"><a href="#广义投影（Generalized-projection）" class="headerlink" title="广义投影（Generalized-projection）"></a>广义投影（Generalized-projection）</h3><blockquote>
<p>与基本运算中的投影运算相比，就是多了允许在选择列表中出现表达式（在基本运算中的投影的选择列表中只能出现字段）</p>
</blockquote>
<ul>
<li><h4 id="格式：∏F1-F2-…-Fn-E"><a href="#格式：∏F1-F2-…-Fn-E" class="headerlink" title="格式：∏F1, F2, … , Fn(E)"></a>格式：∏<sub>F<sub>1</sub>, F<sub>2</sub>, … , F<sub>n</sub></sub>(E)</h4><ul>
<li>其中F<sub>1</sub>, F<sub>2</sub>, … , F<sub>n</sub>可以是字段或者是表达式</li>
<li>E代表一个关系</li>
</ul>
</li>
<li><p>举个栗子：</p>
<ul>
<li><p>∏<sub>name, sal * 1.2</sub>(instructor)</p>
</li>
<li><p>上面的式子表示查出所有老师的名字，以及涨了20%以后的工资，等价于下面的SQL语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, sal * <span class="number">1.2</span></span><br><span class="line"><span class="keyword">FROM</span> instructor</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="聚集函数（Aggregation-function）"><a href="#聚集函数（Aggregation-function）" class="headerlink" title="聚集函数（Aggregation function）"></a>聚集函数（Aggregation function）</h3><blockquote>
<p>聚集函数的符号表示是用书写体G，这边就直接用G指代了</p>
<p><strong>聚集函数是输入值的一个汇聚，以多个值作为输入，将一个单一的值作为返回结果</strong></p>
<p>多重集：使用聚集函数对其进行操作的汇集中，一个值可以出现多次，值出现的顺序是无关紧要的。这样的汇集称为<strong>多重集</strong>（就比方说统计一个员工表中员工的数量，然后我们通过统计员工的名字来统计，即便是同名的员工我们也是计算的）</p>
</blockquote>
<ul>
<li><h4 id="格式：-G1-G2-…-GnGF1-A1-F2-A2-…-Fn-An-E"><a href="#格式：-G1-G2-…-GnGF1-A1-F2-A2-…-Fn-An-E" class="headerlink" title="格式： G1, G2, … , GnGF1(A1), F2(A2), …, Fn(An)(E)"></a>格式： <sub>G<sub>1</sub>, G<sub>2</sub>, … , G<sub>n</sub></sub>G<sub>F<sub>1</sub>(A<sub>1</sub>), F<sub>2</sub>(A<sub>2</sub>), …, F<sub>n</sub>(A<sub>n</sub>)</sub>(E)</h4><ul>
<li>其中前面的G<sub>1</sub>, G<sub>2</sub>, … , G<sub>n</sub>表示的是分组条件</li>
<li>后面的F<sub>1</sub>(A<sub>1</sub>), F<sub>2</sub>(A<sub>2</sub>), …, F<sub>n</sub>(A<sub>n</sub>)是聚集函数表达式列表</li>
<li>F<sub>i</sub>(i = 1, 2, …, n)表示聚集函数：sum、count、average、max、min</li>
<li>A<sub>1</sub>, A<sub>2</sub>, … , A<sub>n</sub>代表字段</li>
</ul>
</li>
<li><p>举个栗子：</p>
<ul>
<li><sub>A<sub>1</sub>, A<sub>2</sub></sub>G<sub>sum(A<sub>3</sub>)</sub>(∏<sub>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub></sub>(σ<sub>P</sub>(r<sub>1</sub>×r<sub>2</sub>×…×r<sub>m</sub>)) )</li>
<li>等价于下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A1, A2, <span class="keyword">sum</span>(A3)</span><br><span class="line"><span class="keyword">FROM</span> r1, r2, ..., rm</span><br><span class="line"><span class="keyword">WHERE</span> P</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> A1, A2</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>上面的聚集函数在进行计算的时候采用的都是多重集，也就是相同的值可以多次重复计算（也就是在执行聚集函数的时候是不去重计算），如果要去重计算的话就要采用下面的几个函数写法</p>
<ul>
<li>sum_distinct</li>
<li>count_distinct</li>
<li>averag_distinct</li>
<li>max_distinct</li>
<li>min_distinct</li>
</ul>
</li>
<li>举个栗子：<ul>
<li><sub>A<sub>1</sub>, A<sub>2</sub></sub>G<sub>sum_distinct(A<sub>3</sub>)</sub>(∏<sub>A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub></sub>(σ<sub>P</sub>(r<sub>1</sub>×r<sub>2</sub>×…×r<sub>m</sub>)) )</li>
<li>上面的式子等价于下面的SQL语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A1, A2, <span class="keyword">sum</span>(<span class="keyword">distinct</span> A3)</span><br><span class="line"><span class="keyword">FROM</span> r1, r2, ..., rm</span><br><span class="line"><span class="keyword">WHERE</span> P</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> A1, A2</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qjm253.cn/2017/10/15/2017-10-15-数据库笔记（九）——对违反约束的处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="建明 | Ming.J">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar-r.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="建明 | Ming.J">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/15/2017-10-15-数据库笔记（九）——对违反约束的处理/" itemprop="url">数据库笔记（九）——对违反约束的处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-15T00:00:00+08:00">
                2017-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章的一些尾巴，然后开始讲第六章的关系代数<br><strong><em>笔者接下来的代码示例会主要在SQL Server数据库中测试</em></strong></p>
</blockquote>
<hr>
<blockquote>
<p>在开始今天的摸鱼大业之前，让我们构造一些简单表</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行下面的语句构造表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> country(</span><br><span class="line">  country_id <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  country_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person(</span><br><span class="line">  person_id <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  country_id <span class="built_in">INTEGER</span> FOREIGN <span class="keyword">KEY</span> <span class="keyword">REFERENCES</span> country(country_id)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">1</span>, <span class="string">'China'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">2</span>, <span class="string">'English'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">3</span>, <span class="string">'America'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">1</span>, <span class="string">'Sunny'</span>, <span class="number">1</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">2</span>, <span class="string">'Robbin'</span>, <span class="number">2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">3</span>, <span class="string">'Jane'</span>, <span class="number">3</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h2><p>在指定外键以后，由于存在完整性约束，所以在执行删除或更新的时候由于语句可能会破坏完整性约束而执行失败。因此可以在定义外键的时候声明为级联删除和级联更新(<strong>是一种对违反参照完整性约束时的处理方式</strong>)</p>
</blockquote>
<ul>
<li><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">table</span> 表名(</span><br><span class="line">  ...</span><br><span class="line">  FOREGIN <span class="keyword">KEY</span> (字段序列) <span class="keyword">REFERENCES</span> 表名(字段序列)</span><br><span class="line">      <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">      <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="级联删除（ON-DELETE-CASCADE）"><a href="#级联删除（ON-DELETE-CASCADE）" class="headerlink" title="级联删除（ON DELETE CASCADE）"></a>级联删除（ON DELETE CASCADE）</h3><ul>
<li>级联删除是在定义外键时指定的，但是却会在执行删除语句时产生影响</li>
<li><p>举个栗子</p>
<ul>
<li><p>我们先不指定级联</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> person;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> country;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> country(</span><br><span class="line">  country_id <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  country_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person(</span><br><span class="line">  person_id <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  country_id <span class="built_in">INTEGER</span> FOREIGN <span class="keyword">KEY</span> <span class="keyword">REFERENCES</span> country(country_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">1</span>, <span class="string">'China'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">2</span>, <span class="string">'English'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">3</span>, <span class="string">'America'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">1</span>, <span class="string">'Sunny'</span>, <span class="number">1</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">2</span>, <span class="string">'Robbin'</span>, <span class="number">2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">3</span>, <span class="string">'Jane'</span>, <span class="number">3</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后执行下面的删除操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 下面我们试图删除中国的信息，但是在person表里有一条数据引用了中国，所以因为参照完整性约束的存在，所以这条语句会执行失败</span></span><br><span class="line"><span class="keyword">DELETE</span> country</span><br><span class="line"><span class="keyword">WHERE</span> country_id = <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来我们重新构造一遍（当然直接用DDL语句更新也是可以的）–并在构造person表时指定了级联删除</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> person;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> country;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> country(</span><br><span class="line">  country_id <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  country_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person(</span><br><span class="line">  person_id <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  country_id <span class="built_in">INTEGER</span> FOREIGN <span class="keyword">KEY</span> <span class="keyword">REFERENCES</span> country(country_id)</span><br><span class="line">      <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">1</span>, <span class="string">'China'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">2</span>, <span class="string">'English'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">3</span>, <span class="string">'America'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">1</span>, <span class="string">'Sunny'</span>, <span class="number">1</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">2</span>, <span class="string">'Robbin'</span>, <span class="number">2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">3</span>, <span class="string">'Jane'</span>, <span class="number">3</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后再次执行下面的删除操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此时执行会发现语句成功执行了，不但删除了中国的信息，连带person表中引用了中国信息的所有数据都被删除了</span></span><br><span class="line"><span class="keyword">DELETE</span> country</span><br><span class="line"><span class="keyword">WHERE</span> country_id = <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>上面的例子便很好的说明了级联删除的作用。如果我们视图删除外键参照键所在表（此处为country表）的某条数据A（此处是中国的信息），而这条数据又被外键所在表的一条或多条数据B所关联（此处person表中Sunny的country_id关联了country表中中国的id）。在指定了级联删除的情况下，删除A会连带着删除所有满足条件的B</p>
</li>
<li>当然在实际使用的时候用的还是比较少的，因为参照完整性约束在一定程度上可以防止数据的误删除，对数据库的完整性起了一定的保护作用，如果指定了级联删除，这层保护就失效了。所以还是视情况而用</li>
</ul>
</li>
<li><h3 id="级联更新（ON-UPDATE-CASCADE）"><a href="#级联更新（ON-UPDATE-CASCADE）" class="headerlink" title="级联更新（ON UPDATE CASCADE）"></a>级联更新（ON UPDATE CASCADE）</h3><ul>
<li>类似的，级联更新和级联删除一样，如果我们更新时违反了完整性约束，同样更新操作不被拒绝，而是级联更新</li>
<li><p>举个栗子（我们在上面操作的基础上执行，上面构造时指定了级联删除，但是没指定级联更新）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们试图执行下面的更新操作，我们把修改English的country_id， 但是由于person表中还有数据的country_id=2,如果下面的更新成功执行，则会导致person表中存在country_id=2的数据，而country中却没有对应数了，违反参照完整性约束，故下面的语句执行失败</span></span><br><span class="line"><span class="keyword">UPDATE</span> country</span><br><span class="line"><span class="keyword">SET</span> country_id = <span class="number">4</span></span><br><span class="line"><span class="keyword">WHERE</span> country_id = <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同样的，我们重新构造一下，此时指定级联更新</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> person;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> country;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> country(</span><br><span class="line">  country_id <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  country_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person(</span><br><span class="line">  person_id <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  country_id <span class="built_in">INTEGER</span> FOREIGN <span class="keyword">KEY</span> <span class="keyword">REFERENCES</span> country(country_id)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">1</span>, <span class="string">'China'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">2</span>, <span class="string">'English'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">3</span>, <span class="string">'America'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">1</span>, <span class="string">'Sunny'</span>, <span class="number">1</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">2</span>, <span class="string">'Robbin'</span>, <span class="number">2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">3</span>, <span class="string">'Jane'</span>, <span class="number">3</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时再执行一下上面的更新语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 由于指定了级联更新，所以会发现下面的语句执行成功了，不但更改了country表中的数据，连带着person表中的数据也一并更新了</span></span><br><span class="line"><span class="keyword">UPDATE</span> country</span><br><span class="line"><span class="keyword">SET</span> country_id = <span class="number">4</span></span><br><span class="line"><span class="keyword">WHERE</span> country_id = <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面就是级联更新的效果</p>
</li>
</ul>
</li>
<li><h3 id="另一类对违反完整性约束的处理"><a href="#另一类对违反完整性约束的处理" class="headerlink" title="另一类对违反完整性约束的处理"></a>另一类对违反完整性约束的处理</h3><ul>
<li>SET DEFAULT<ul>
<li>一旦违反完整性约束，就将参照域（此处为country_id）设置为默认值</li>
</ul>
</li>
<li>SET NULL<ul>
<li>一旦违反完整性约束，就将参照域（此处为country_id）设置为NULL</li>
</ul>
</li>
<li><p>举个栗子</p>
<ul>
<li><p>执行下面的构造</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> person;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> country;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> country(</span><br><span class="line">  country_id <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  country_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person(</span><br><span class="line">  person_id <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  country_id <span class="built_in">INTEGER</span> FOREIGN <span class="keyword">KEY</span> <span class="keyword">REFERENCES</span> country(country_id)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">1</span>, <span class="string">'China'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">2</span>, <span class="string">'English'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">3</span>, <span class="string">'America'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">1</span>, <span class="string">'Sunny'</span>, <span class="number">1</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">2</span>, <span class="string">'Robbin'</span>, <span class="number">2</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">3</span>, <span class="string">'Jane'</span>, <span class="number">3</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后执行下面的删除操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 下面的删除操作成功执行，但不是级联删除，而是把person表中原来country_id=1的数据的country_id都设成了NULL</span></span><br><span class="line"><span class="keyword">DELETE</span> country</span><br><span class="line"><span class="keyword">WHERE</span> country_id = <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="延迟检查"><a href="#延迟检查" class="headerlink" title="延迟检查"></a>延迟检查</h2><p>这是由于数据库默认是在执行每一条SQL语句的时候都进行完整性约束的检查，导致有些操作无法进行。延迟操作就将完整性约束的检查延迟到了事务结束的时候检查（大多数数据库不支持，比如SQL Server， 但Oracle数据支持）</p>
</blockquote>
<ul>
<li><p>由于不常用，SQL Server也不支持，这里就讲一下概念，不举实际的栗子了。</p>
</li>
<li><p>假设上面的例子表中没有指定延迟检查</p>
<ul>
<li>执行下面的语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行下面两条语句是会出错的，因为插入第一条数据的时候，由于完整性约束的存在，要求country表中要有country_id=4的数据，但是这个数据目前还不存在（所以只要先执行第二条语句，这两个语句才能成功执行）</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">4</span>, <span class="string">'Jerry'</span>, <span class="number">4</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">4</span>, <span class="string">'France'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>而如果指定了延迟检查呢</p>
<ul>
<li>执行下面语句（下面两个语句处于同一个事务中）<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 由于是延迟检查，所以两条数据都插入完，执行commit，事务结束时才进行完整性约束的检查，此时就不会出错，可以正常插入</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> person (person_id, <span class="keyword">name</span>, country_id) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">4</span>, <span class="string">'Jerry'</span>, <span class="number">4</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> country (country_id, country_name) <span class="keyword">VALUES</span> (</span><br><span class="line">    <span class="number">4</span>, <span class="string">'France'</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>虽然SQL标准中有这个概念，但是大多数数据库没有提供支持，并且不常用</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar-r.jpg"
                alt="建明 | Ming.J" />
            
              <p class="site-author-name" itemprop="name">建明 | Ming.J</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">建明 | Ming.J</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
