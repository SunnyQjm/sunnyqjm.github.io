<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2F2018%2F06%2F27%2Fos_02%2F</url>
    <content type="text"><![CDATA[线程 线程是CPU使用的基本单元，它由线程ID、程序计数器，寄存器集合和栈组成。它与属于同一个进程的其它线程共享代码段、数据段和其它操作系统资源，如打开文件和信号。 线程的优点 响应度高：交互式应用程序采用多线程实现的话，可以一部分线程处理用户I/O等耗时操作，而一部分用来响应用户的操作。这就不会出现用户一次交互之后系统由于等待I/O而卡住的情况，可交互性大大提升。 资源共享：同一个进程的线程间共享进程的内存和资源，线程之间的交互也比进程间交互要容易的多 经济：创建一个线程所需要的开销远比创建一个进程的开销要小，所以相对于创建进程来说，创建一个线程是更为经济的。 多处理器体系结构的应用：对于单线程进程，即便硬件有多个处理器，一个进程同一时刻只能在一个处理器上运行。而对于一个多线程进程，可以将线程同时运行在多个处理器上，这样就充分的发挥了多处理器的好处，加强了并发功能 用户线程和内核线程 参考：线程的3种实现方式–内核级线程, 用户级线程和混合型线程 用户线程 用户线程存在于用户空间，由线程库统一管理，对内核透明（也就是说内核并不知道有用户线程的存在） 用户线程的创建和销毁均在用户空间由线程库实现，无需内核干预，不需要调用系统调用，也就不会有用户态与内核态相互切换的开销 用户线程不具有自己的上下文，不能直接参与CPU的竞争，必须关联一个内核线程，由内核线程去竞争CPU资源（操作系统是以内核线程为最基本的单位，分配CPU资源的） 内核线程 内核线程存在于内核空间，由操作系统管理。 内核线程的创建和销毁都是通过系统调用来完成的 内核线程是操作系统分配CPU资源的最小单位（也就是说内核线程是直接参与CPU竞争的）=&gt; 每次调度器选择一个内核级线程，为其分配CPU的使用权（比如说可以是时间片） 多线程模型 多对一模型 一对一模型 多对一模型 多对一模型一个进程的所有用户线程都映射到同一个内核线程上，线程的管理交由线程库 就内核的视角来看，进程仍然是一个单线程进程，用户线程对内核是透明的 因为都映射到同一个内核线程，所以同一时刻只有一个线程能访问内核，也就是说同一时刻只能有一个线程可以调用系统调用（如果此时某个线程执行了一个阻塞的系统调用，那么同进程的其它线程都将被阻塞） 因为线程的管理都是由线程库在用户空间完成的，不涉及系统调用，所以效率会比较高 一对一模型每个用户线程都映射一个内核线程。 由于每个用户线程各自映射一个内核线程，所以当一个线程执行阻塞系统调用的时候，同进程的其它线程并不受其影响。=&gt; 提供了比较好的并发功能 允许同进程的多个线程运行在多个处理器上 唯一的缺点就是，内核线程的创建是开销比较大的，过多的创建会影响系统的性能，所以导致所能创建的线程数量也是大受限制。 多对多模型多对多模型 克服了多对一模型并发性不行以及一对一模型所能创建线程数量受限的问题。 开发人员可以创建任意多的用户线程，并且相应的内核线程能在多处理系统上并发执行。 当一个线程执行阻塞系统调用的时候，内核能调度另一个线程来执行 二级模型是上述一对一模型和多对多模型的变种。 线程库线程库为程序员提供创建和管理线程的API 用户级线程库和内核级线程库 用户级线程库用户级线程库的实现是在用户空间中提供一个没有内核支持的库，此库的所有代码和数据结构都存在于用户空间当中。调用库中的一个函数只是导致用户空间一个本地函数的调用，而不是系统调用。 内核级线程库内核级线程库的实现方法是执行一个由操作系统直接支持的内核级的库，库的代码和数据结构存在于内核空间当中。调用一个库的API函数通常会导致对内核的系统调用。 常用线程库 POSIX Pthread扩展自POSIX标准，可以提供用户级或内核级的库 Win32适用于Windows操作系统的内核级线程库 JavaJava线程API通常采用宿主系统上的线程库来实现。意味着在Windows系统上，Java线程通常采用Win32 API实现，而在Unix和LInux系统上采用Pthread。 多线程相关问题 系统调用fork()和exec()通常，如果在调用fork之后立即调用exec函数，那么只复制当前线程（因为新的程序会替换掉整个进程）；如果在调用fork函数之后不调用exec函数，那么应复制所有线程 fork()通常在线程内执行fork函数时，系统有两种选择。一种是复制当前进程的所有线程到新进程；另一种是只复制调用fork()的那个线程。 exec()如果一个线程调用了exec()系统调用，那么exec()所启动的新的程序会替换当前的整个进程，包括所有的线程 线程取消线程取消（thread cancellation）指的是在线程完成之前终止线程的任务 异步取消（asynchronous cancellation）：一个线程立即终止目标线程 延迟取消（deferred cancellation）：目标线程不断自检是否应该终止，这允许线程有机会以有序的方式来终止自己。 信号处理信号 在Unix中用来 通知进程某个特定事件发生了 信号的共同特征 信号是由特定事件的发生所产生的 产生的信号要发送到进程 一旦发送，信号必须加以处理 同步信号和异步信号 同步信号：同步信号由正在运行的进程产生并发送给自己处理 异步信号：异步信号通常是由运行进程之外的其它进程产生，发送给本进程处理。 对于多线程程序，信号发给谁？ 发送信号到信号所应用的线程 发送信号到进程内的每个线程 发送信号到进程内的某些固定线程 规定一个特定线程以接收进程的所有信号 通常，对于Unix系统，允许线程描述它会接收或者拒绝哪些信号。因此，有时一个异步的信号只能发送给那些不拒绝它的线程。 信号的处理？ 每个信号都有一个默认信号处理程序（default signal handler），如果不作额外的处理，每当信号来临，就会执行信号对应的默认处理程序。 当然，这种默认动作也可以通过用户自定义一个信号处理程序来覆盖默认行为。一旦定义了某个信号的处理程序来覆盖默认响应，信号来临时就会执行用户定义的行为，而不是信号的默认行为。 线程池线程池（thread pool）的主要思想是在进程开始的时候创建一定数量的线程，并放入到池中以等待工作。当服务器收到请求时，它会唤醒池中的一个线程（如果有可用线程的话），并将请求交由该线程处理。处理完 请求之后，再让线程返回池中等待下一个任务。如果池中没有可用线程，则服务器会一直等待，直到有空线程为止。 线程特定数据线程特定数据（thread-specific data），也就是线程局部数据，为每一个线程所私有而不与其他线程共享。 调度程序激活调度程序激活机制 实际上是一种内核与线程库进行通信的机制。目的是 模拟内核线程的功能，但是同时又保留线程库在用户空间中实现拥有更佳的性能以及灵活性的优点。 轻量级进程（Light-weight process，LWP）轻量级进程是在内核线程与用户线程之间设置的一个中间的数据结构。对于线程库，LWP表现为一种虚拟处理器，线程库可以调度用户线程运行在这些虚拟处理器上。（也就是说线程库在调度用户线程的时候，就把LPW当做处理器来看待，用户线程要运行就必须竞争LPW的使用权，而线程库调度就是负责分派LPW的使用权给适当的用户线程） 上行调用（upcall）上行调用（upcall）可以认为是内核给用户空间的进程的运行时系统发送的一个信号，进程的运行时系统根据收到的信号对应的作出处理。 调度程序激活机制 每个内核线程会关联一个LWP，应用程序可以调度一个用户线程到一个可用的LWP上执行，而内核线程则会被调度到真实的物理处理器上执行。 内核通过upcall告知应用程序一些特定的事件，比如一个用户线程A运行在LWP①上，它调用了一个阻塞的系统调用，那么内核将会发一个 upcallA 告知应用程序，让其阻塞并标识这个用户线程A。接着内核会分配一个新的LWP（记作LWP②）给应用程序，应用程序会在LWP②上处理刚才的upcallA，标记用户线程A为阻塞，解除其与LWP① 的关联，然后在应用程序通过调度，在就绪队列里面找到一个等待执行的 用户线程B，将其与LWP②关联，让其运行在LWP② 上。当 用户线程A 所等待的阻塞事件结束的时候，内核会发送另一个 upcallB，通知应用程序先前阻塞的 用户线程A 又可以运行了，然后应用程序根据情况进行调度（选择是否为其分配一个LWP让其执行，或是将其放到就绪队里当中）。]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程]]></title>
    <url>%2F2018%2F06%2F26%2Fos_01%2F</url>
    <content type="text"><![CDATA[进程 进程是程序在特定输入下的一次执行 是现代分时系统的工作单元，是系统进行资源分配和调度的基本单位 进程 是执行中的程序，不只是程序代码 ( 程序代码也称为文本段/代码段 )，还包括： 当前的活动：通过 程序计数器的值 以及 寄存器的内容 表示 =&gt; 当前正在执行哪一条指令处理什么数据 堆栈端：包括临时数据。如函数参数、返回地址和局部变量 数据段：包括全局变量 堆：进程运行期间动态分配的内存 进程状态 new (新建状态): 进程正在被创建 ready (就绪状态): 进程等待被分配CPU running (运行状态): 指令正在被执行 waiting (等待状态): 进程等待某个事件的发生（如I/O完成或收到信号） terminated (终止状态): 进程完成执行 进程控制块 (PCB) PCB是操作系统用来管理进程的唯一控制数据结构 每一个进程在操作系统内都用一个PCB数据结构表示 PCB : Process Control Block 进程调度进程调度选择一个可用的进程（可能从多个可用进程集合中选择）到CPU上执行 为何要进行进程调度？在多道程序设计当中，由 多个进程竞争使用有限的CPU资源，如何合理的分配CPU资源便是进程调度要解决的问题。进程调度的目标是 =&gt; 使得CPU的利用率最大化 调度队列 作业队列该队列包含系统中所有的进程（包括在内存中的、被交换到外存的以及在外存缓冲池当中的进程） 就绪队列该队列保存有驻留在内存中的就绪的、等待被分配CPU的进程 设备队列等待特定I/O设备的进程列表称为 设备队列，每个设备都有自己的设备队列。 调度程序进程在其生命周期中会在各种调度队列之间迁移，而操作系统通过执行调度程序来选择队列中的进程进行相应的迁移。 参考：https://blog.csdn.net/u013007900/article/details/50550415 长期调度程序（long-term scheduler）长期调度 又称为 作业调度 或 高级调度，这种调度将已进入系统并处于后备状态的作业按某种算法选择一个或一批装载入内存准备执行。 长期调度程序执行的并 不频繁 常用于批处理系统，在分时系统和实时系统中通常不需要长期调度 通过长期调度程序可以控制多道程序度 （内存中的进程数量）=&gt; 在合适的时机从外存装载进内存（比如可以在一个进程执行完时），从而使得 创建进程的平均速度等于进程离开系统的平均速度，使得多道程序度达到稳定状态 在进行长期调度的时候，应该选择一个合理的包含I/O为主的和CPU为主的组合进程。（如果都是以I/O为主，那么可能就绪队列几乎为空，都在等待队列中等待I/O的结束，这使得短期调度无进程可调，CPU也没有得到充分的利用） 短期调度程序（short-term scheduler） CPU调度算法：后续补充 短期调度 又称为 CPU调度 或 低级调度，它的主要任务是在就绪队列中选择一个进程，为其分配CPU，让其进入运行态开始执行。 短期调度程序执行的 非常频繁 常说的进程调度指的就是短期调度，其可分为 抢占式和非抢占式 中期调度程序（medium-term scheduler）中期调度 又称为 交换调度，其核心思想是 将进程从内存（或从CPU竞争）中移出，从而降低多道程序度 进程被移出内存后，在CPU相对空闲时又能被重新调入内存，并从中断处继续执行。这种方案称之为 交换（swapping） 为了改善进程组合，或者因内存要求的改变引起了内存的过度使用而需要释放内存，就有必要使用交换。 上下文切换将CPU切换到另一个进程需要 保存当前进程的状态并回复另一个进程的状态，这一任务称为 上下文切换（context switch） 当发生上下文切换时，内核会将旧进程的状态保存在其PCB中，然后装入经调度要执行的并已保存的新进程的上下文 上下文切换时间是额外的开销 上下文切换发生的时机：正在运行的进程被中断、进程运行结束、时间片到期等 进程操作本小结介绍进程的创建和如何终止进程，代码示例则以Unix平台为例 进程创建在进程执行的过程当中，可以通过 调用创建进程的系统调用 创建多个进程。创建进程称为 父进程，新创建的进程称为子进程。每个新进程又可以再创建其它进程，从而形成进程树。 进程标识符 (pid, process identifier)大多数操作系统根据一个 pid 来 唯一标识一个进程，pid通常是一个整数值。 创建子进程后，父进程的行为 父进程与子进并发执行 父进程等待，直到某个或全部子进程执行完毕 新创建进程的地址空间也有两种可能 子进程是父进程的复制品 =&gt; 具有与父进程完全相同的程序和数据 子进程装入另一个新程序 Unix创建进程相关的命令 fork =&gt; 创建一个新进程，详细介绍可参考我的另一篇博客 exec =&gt; 实际上代表的是一个函数族，共有六个函数，主要用于在进程中调用其它的可执行程序。详细介绍可参考我的另一篇博客 wait =&gt; wait函数可用于等待子进程的结束（其主要功能还是用于清理僵死进程），详细接收可参考我的另一篇博客 举个创建子进程的栗子 如果子进程创建成功，则fork函数会返回两次，在子进程中返回0，在父进程中返回子进程id 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;sys/unistd.h&gt;#include &lt;sys/types.h&gt;int main()&#123; pid_t pid; //创建一个新进程 pid = fork(); if(pid &lt; 0) &#123; //error occurred fprintf(stderr, "Fork failed"); exit(-1); &#125; else if(pid == 0) &#123; //child process execlp("/bin/ls", "ls", NULL); &#125; else &#123; //parent process //parent will wait for the child to complete wait(NULL); printf("Child Completed\n"); exit(0); &#125; return 0;&#125; 9 : 创建一个进程并记录fork()函数的返回值 11-13: 如果pid &lt; 0 表示创建进程失败，打印出错误提示并退出程序 14-15: pid == 0，表示当前进程是子进程，执行一个exec函数调用系统的ls命令查看当前文件夹的信息 16-20: pid &gt; 0，表示当前进程是父进程，调用wait等待子进程执行结束，接着打印子进程结束信息，退出程序。 进程终止进程可以在执行的过程中，调用 exit 系统调用来要求操作系统终止自身。当然，通过适当的系统调用，一个进程也可以终止另一个进程（比如Unix中常用kill命令杀死其它进程） 父进程终止子进程的原因 子进程使用了超过它所分配到的一些资源。（为了判定是否发生这种情况，要求父进程有一个检查子进程状态的机制） 分配给子进程的任务已不再需要 父进程退出，操作系统不允许子进程继续（对有些操作系统而言） 父进程退出时子进程如何处置？ 有些操作系统，包括VMS，不允许子进程在父进程已终止的情况下存在。对于这类操作系统，如果一个进程终止，那么它的所有子进程都将终止。这种现象称之为 级联终止（cascading termination） 而对于常见的一些操作系统，如Unix，如果一个进程终止，则其所有的子进程并不终止，而是将其托管给init进程，init进程便是它的新父进程。 进程间通信如果一个进程不被其他进程影响，也不影响其它进程，则称这个进程是独立的；如果一个进程能影响其他进程或被其它进程影响，则称该进程是协作的。=&gt;进程间进行协作需要一种进程间通信机制（interprocess communication, IPC） 为什么进程间要进行协作？ 信息共享（information sharing）=&gt; 多个进程可以并发的访问同一块数据 提高运算速度（computation speedup）=&gt; 将一个任务分为若干个子任务交由多个进程执行，可以提高运算速度 模块化（modularity）=&gt; 一个系统可能被设计为多个模块，而每个模块各自在一个进程中运行，那么这些模块间肯定需要进行协同，这就要求进程间要能够进行通信。 方便（convenience） 进程间通信的方式 共享内存建立一块共享内存区域，对于需要访问共享内存区域的两个或多个进程需要打破操作系统对一个进程不能访问另一个进程的内存空间的限制。 可用来解决生产者消费者问题 可以采用有限缓冲和无限缓冲两种模式 只有在建立共享内存区域的时候需要内核干预，在具体通信的时候都是对内存的访问，可以不需要内核干预。可以以较大的速率进行同行。 消息传递进程间通过互相发送消息来直接或间接的通信。 直接通信或间接通信 直接通信：通信进程之间直接建立通信线路，互相发送消息来进行通信 间接通信：需要一个邮箱作为中转，进程均直接与邮箱进行通信，向邮箱发送消息或者从邮箱接收消息 同步或异步通信 同步通信：消息的发送和接收是阻塞执行的。直到发送的消息被成功接收或者成功接收到消息，才会继续执行之后的操作 异步通信：消息发送和接收是异步的。对于发送操作，消息发出后不关心是否被接收，直接执行之后的操作；对于接收操作，每次接收，均一个有效的消息或者是一个空消息，然后继续执行之后的操作。 缓冲不管通信是直接的还是间接的，通信进程所交换的消息都驻留在临时队列当中。简单讲，队列有以下三种实现方式： 零容量：缓冲队列为0 有限容量：缓冲队列为n 无线容量：缓冲队列无限大 零容量的情况称为没有缓冲的系统，其它情况称为自动缓冲]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uva- 201 - Squares]]></title>
    <url>%2F2018%2F06%2F08%2Fc%2B%2BUva201%2F</url>
    <content type="text"><![CDATA[正方形（Squares, ACM/ICPC World Finals 1990, UVa201）原题地址：Uva201 有n行n列（2≤n≤9）的小黑点，还有m条线段连接其中的一些黑点。统计这些线段连成了多少个正方形（每种边长分别统计）。 行从上到下编号为1～n，列从左到右编号为1～n。边用H i j和V i j表示，分别代表边(i,j)-(i,j+1)和(i,j)-(i+1,j)。如图4-5所示最左边的线段用V 1 1表示。图中包含两个边长为1的正方形和一个边长为2的正方形。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;array&gt;using namespace std;const int MAX_LEN = 10;bool checkV(const array&lt;array&lt;int, 10&gt;, 10&gt; &amp;arr, int i, int j) &#123; return arr[i][j] &gt;= 2;&#125;bool checkH(const array&lt;array&lt;int, 10&gt;, 10&gt; &amp;arr, int i, int j) &#123; return arr[i][j] == 1 || arr[i][j] == 3;&#125;/** * 检查以（i, j）为左上顶点是否能组成一个边长为len的正方形 * @param arr * @param i * @param j * @param len */bool checkBuildSquare(const array&lt;array&lt;int, 10&gt;, 10&gt; &amp;arr, int i, int j, int len) &#123; for (int s = i; s &lt; i + len; s++) &#123; if (!checkV(arr, s, j) || !checkV(arr, s, j + len)) return false; &#125; for (int s = j; s &lt; j + len; s++) &#123; if (!checkH(arr, i, s) || !checkH(arr, i + len, s)) return false; &#125; return true;&#125;void check(const array&lt;array&lt;int, MAX_LEN&gt;, MAX_LEN&gt; &amp;arr, int n) &#123; static array&lt;int, MAX_LEN&gt; squares&#123;&#125;; squares.fill(0); int maxLen; for (int i = 1; i &lt; n; i++) for (int j = 1; j &lt; n; j++) &#123; if (arr[i][j] != 3) //一个点→或者↓没有变则不会是某个正方形的左上端点 continue; maxLen = min(n - i, n - j); for (int k = 1; k &lt;= maxLen; k++) &#123; if (checkBuildSquare(arr, i, j, k)) ++squares[k]; &#125; &#125; bool hasSquare = false; for (int i = 1; i &lt; MAX_LEN; i++) &#123; if (squares[i] == 0) continue; hasSquare = true; cout &lt;&lt; squares[i] &lt;&lt; " square (s) of size " &lt;&lt; i &lt;&lt; endl; &#125; if (!hasSquare) &#123; cout &lt;&lt; "No completed squares can be found." &lt;&lt; endl; &#125;&#125;int main() &#123; /** * 1 -&gt; H * 2 -&gt; V * 3 -&gt; HV */ array&lt;array&lt;int, MAX_LEN&gt;, MAX_LEN&gt; sides&#123;&#125;; int n, sideNum; char c; unsigned int i, j; int tern = 0; bool first = true; while (cin &gt;&gt; n &gt;&gt; sideNum) &#123; ++tern; if(first)&#123; first = false; &#125; else &#123; cout &lt;&lt; endl &lt;&lt; "**********************************" &lt;&lt; endl &lt;&lt; endl; &#125; for (auto &amp;s : sides) s.fill(0); for (int k = 0; k &lt; sideNum; k++) &#123; cin &gt;&gt; c &gt;&gt; i &gt;&gt; j; if (c == 'H') sides[i][j] += 1; else if (c == 'V') sides[j][i] += 2; &#125; cout &lt;&lt; "Problem #" &lt;&lt; tern &lt;&lt; endl &lt;&lt; endl; check(sides, n); &#125;&#125;]]></content>
      <tags>
        <tag>c++语言</tag>
        <tag>ACM</tag>
        <tag>Uva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uva- 1589 - Xiangqi]]></title>
    <url>%2F2018%2F06%2F08%2Fc%2B%2BUva1589%2F</url>
    <content type="text"><![CDATA[象棋（Xiangqi, ACM/ICPC Fuzhou 2011, UVa1589）原题地址：Uva1589 考虑一个象棋残局，其中红方有n（2≤n≤7）个棋子，黑方只有一个将。红方除了有一个帅（G）之外还有3种可能的棋子：车（R），马（H），炮（C），并且需要考虑“蹩马腿”（如图4-4所示）与将和帅不能照面（将、帅如果同在一条直线上，中间又不隔着任何棋子的情况下，走子的一方获胜）的规则。 输入所有棋子的位置，保证局面合法并且红方已经将军。你的任务是判断红方是否已经把黑方将死。关于中国象棋的相关规则请参见原题。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * 1589 - Xiangqi */#include &lt;iostream&gt;#include &lt;array&gt;using namespace std;struct Point &#123; int x, y; char type;&#125;;int hasPartition(const array&lt;Point, 7&gt; &amp;reds, const Point &amp;p1, const Point &amp;p2, int redNum)&#123; int partitionNum = 0; if(p1.x != p2.x &amp;&amp; p1.y != p2.y) //都不在同一条线上，肯定没有分隔子 return 0; else if(p1.x == p2.x)&#123; int spanY = p1.y - p2.y; for(int i = 0; i &lt; redNum; i++)&#123; if(reds[i].x == p1.x &amp;&amp; ((spanY &gt; 0 &amp;&amp; reds[i].y &gt; p2.y &amp;&amp; reds[i].y &lt; p1.y) || (spanY &lt; 0 &amp;&amp; reds[i].y &gt; p1.y &amp;&amp; reds[i].y &lt; p2.y))) ++partitionNum; &#125; &#125; else &#123; int spanX = p1.x - p2.x; for(int i = 0; i &lt; redNum; i++)&#123; if(reds[i].y == p1.y &amp;&amp; ((spanX &gt; 0&amp;&amp; reds[i].x &gt; p2.x &amp;&amp; reds[i].x &lt; p1.x) || (spanX &lt; 0 &amp;&amp; reds[i].x &gt; p1.x &amp;&amp; reds[i].x &lt; p2.x))) ++partitionNum; &#125; &#125; return partitionNum;&#125;bool judgeG(const array&lt;Point, 7&gt; &amp;reds, const Point &amp;blackG, int redNum, int pos) &#123; if(reds[pos].y != blackG.y) return false; return hasPartition(reds, blackG, reds[pos], redNum) == 0;&#125;bool judgeR(const array&lt;Point, 7&gt; &amp;reds, const Point &amp;blackG, int redNum, int pos) &#123; if(reds[pos].x != blackG.x &amp;&amp; reds[pos].y != blackG.y) return false; return hasPartition(reds, reds[pos], blackG, redNum) == 0;&#125;bool judgeC(const array&lt;Point, 7&gt; &amp;reds, const Point &amp;blackG, int redNum, int pos) &#123; if(reds[pos].x != blackG.x &amp;&amp; reds[pos].y != blackG.y) return false; return hasPartition(reds, reds[pos], blackG, redNum) == 1;&#125;bool judgeH(const array&lt;Point, 7&gt; &amp;reds, const Point &amp;blackG, int redNum, int pos) &#123; int subX = blackG.x - reds[pos].x; int subY = blackG.y - reds[pos].y; if(subX == 0 || subY == 0) return false; if(abs(subX) + abs(subY) != 3) //在不考虑绊马脚的情况下是否可达 return false; if(abs(subX) == 2)&#123; for(int i = 0; i &lt; redNum; i++)&#123; if(reds[i].x == reds[pos].x + (subX / 2) &amp;&amp; reds[i].y == reds[pos].y) //检查是否绊马脚 return false; &#125; &#125; else &#123; for(int i = 0; i &lt; redNum; i++)&#123; if(reds[i].y == reds[pos].y + (subY / 2) &amp;&amp; reds[i].x == reds[pos].x) //检查是否绊马脚 return false; &#125; &#125; return true;&#125;bool judge(const array&lt;Point, 7&gt; &amp;reds, const Point &amp;blackG, int redNum) &#123; for (int i = 0; i &lt; redNum; i++) &#123; if(reds[i].x == blackG.x &amp;&amp; reds[i].y == blackG.y) //被吃掉的子 continue; switch (reds[i].type) &#123; case 'G': //将 if (judgeG(reds, blackG, redNum, i)) return true; break; case 'C': //炮 if (judgeC(reds, blackG, redNum, i)) return true; break; case 'H': //马 if (judgeH(reds, blackG, redNum, i)) return true; break; case 'R': //车 if (judgeR(reds, blackG, redNum, i)) return true; break; default: break; &#125; &#125; return false;&#125;bool isInBound(const array&lt;Point, 7&gt; &amp;reds, Point &amp;blackG, int redNum)&#123; return blackG.y &gt;= 4 &amp;&amp; blackG.y &lt;= 6 &amp;&amp; blackG.x &gt;= 1 &amp;&amp; blackG.x &lt;= 3;&#125;bool doJudge(const array&lt;Point, 7&gt; &amp;reds, const Point &amp;blackG, int redNum)&#123; Point a&#123;&#125;; a = blackG; if(!judge(reds, a, redNum)) return false; a.x += 1; if(isInBound(reds, a, redNum) &amp;&amp; !judge(reds, a, redNum)) return false; a.x -= 2; if(isInBound(reds, a, redNum) &amp;&amp; !judge(reds, a, redNum)) return false; a.x += 1; a.y += 1; if(isInBound(reds, a, redNum) &amp;&amp; !judge(reds, a, redNum)) return false; a.y -= 2; return !(isInBound(reds, a, redNum) &amp;&amp; !judge(reds, a, redNum));&#125;int main() &#123; int redNum; Point blackG&#123;&#125;; array&lt;Point, 7&gt; reds&#123;&#125;; while (cin &gt;&gt; redNum &gt;&gt; blackG.x &gt;&gt; blackG.y) &#123; if (redNum == 0) break; for (int i = 0; i &lt; redNum; i++) cin &gt;&gt; reds[i].type &gt;&gt; reds[i].x &gt;&gt; reds[i].y; cout &lt;&lt; (doJudge(reds, blackG, redNum) ? "YES" : "NO") &lt;&lt; endl; &#125;&#125;]]></content>
      <tags>
        <tag>c++语言</tag>
        <tag>ACM</tag>
        <tag>Uva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uva- 489 - Hangman Judge]]></title>
    <url>%2F2018%2F06%2F08%2Fc%2B%2BUva489%2F</url>
    <content type="text"><![CDATA[刽子手游戏（Hangman Judge, UVa 489）原题地址：Uva489 刽子手游戏其实是一款猜单词游戏，如图4-1所示。游戏规则是这样的：计算机想一个单词让你猜，你每次可以猜一个字母。如果单词里有那个字母，所有该字母会显示出来；如果没有那个字母，则计算机会在一幅“刽子手”画上填一笔。这幅画一共需要7笔就能完成，因此你最多只能错6次。注意，猜一个已经猜过的字母也算错。 在本题中，你的任务是编写一个“裁判”程序，输入单词和玩家的猜测，判断玩家赢了（You win.）、输了（You lose.）还是放弃了（You chickened out.）。每组数据包含3行，第1行是游戏编号（-1为输入结束标记），第2行是计算机想的单词，第3行是玩家的猜测。后两行保证只含小写字母。 样例输入：123456789101cheesechese2cheeseabcdefg3cheeseabcdefgij-1 样例输出: 123456Round 1You win.Round 2You chickened out.Round 3You lose. 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * UVa489 */#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int ERROR_TORRENT = 7;/** * * @param s * @param guess * @return 1 -&gt; success 2 -&gt; fail 0 -&gt; give up */int doGuess(string &amp;s, string &amp;guess)&#123; int errorTime = 0; set&lt;char&gt; errorSet; bool isMatch; bool isFinish; for(auto g : guess)&#123; isMatch = false; isFinish = true; if(errorSet.find(g) != errorSet.end()) //猜错一次后就不再猜了 continue; errorSet.insert(g); for(auto &amp;c : s)&#123; if(c == ' ') continue; isFinish = false; if(g == c) &#123; c = ' '; isMatch = true; &#125; &#125; if(isFinish) return 1; if(!isMatch) &#123; ++errorTime; &#125; if(errorTime &gt;= ERROR_TORRENT) return 2; &#125; for(auto &amp;g : s)&#123; if(g != ' ') return 0; &#125; return 1;&#125;int main()&#123; int round; string target; string guess; while(cin &gt;&gt; round)&#123; if(round == -1) break; cin &gt;&gt; target &gt;&gt; guess; cout &lt;&lt; "Round " &lt;&lt; round &lt;&lt; endl; switch (doGuess(target, guess))&#123; case 0: cout &lt;&lt; "You chickened out." &lt;&lt; endl; break; case 1: cout &lt;&lt; "You win." &lt;&lt; endl; break; case 2: cout &lt;&lt; "You lose." &lt;&lt; endl; break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>c++语言</tag>
        <tag>ACM</tag>
        <tag>Uva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求root(N, k) 快速幂取模的应用]]></title>
    <url>%2F2018%2F06%2F03%2Fc%2B%2B03%2F</url>
    <content type="text"><![CDATA[问题描述 N&lt;k时，root(N,k) = N，否则，root(N,k) = root(N’,k)。N’为N的k进制表示的各位数字之和。输入x,y,k，输出root(x^y,k)的值 (这里^为乘方，不是异或)，2=&lt;k&lt;=16，0&lt;x,y&lt;2000000000，有一半的测试点里 x^y 会溢出int的范围(&gt;=2000000000) 输入描述 每组测试数据包括一行，x(0&lt;x&lt;2000000000), y(0&lt;y&lt;2000000000), k(2&lt;=k&lt;=16) 输出描述 输入可能有多组数据，对于每一组数据，root(x^y, k)的值 示例 输入 14 4 10 输出 14 分析推导 首先将 N用k进制表示 展开： N = a0 + a1 * k + a2 * k2 + ··· + a0 * kn 则，N’ 表示如下： N’ = a0 + a1 + a2 + ··· + an 则 N - N’ 表示如下： N - N’ = a1 * (k - 1) + a2 * (k2 - 1) + ··· + an * (kn - 1) 证明 (N - N’) % (k - 1) = 0 由等比数列求和公式有: 1 + k + k2 + ··· + kn - 1 = (1 - kn) / (1 - k) ∴ kn - 1 = (k - 1) * (1 + k + k2 + ··· + kn - 1) ∴ (kn - 1) % (k - 1) = 0 又∵ N - N’ = a1 * (k - 1) + a2 * (k2 - 1) + ··· + an * (kn - 1) ∴ (N - N’) % (k - 1) = 0 递推归纳 令 N’ = N1, N” = N2, ··· 则有： &nbsp;&nbsp;&nbsp;&nbsp;(N - N1) % (k - 1) = 0 &nbsp;&nbsp;&nbsp;&nbsp;(N1 - N2) % (k - 1) = 0 &nbsp;&nbsp;&nbsp;&nbsp;… &nbsp;&nbsp;&nbsp;&nbsp;(Nr - 1 - Nr) % (k - 1) = 0 &nbsp;&nbsp;&nbsp;&nbsp;其中 Nr 为我们要求的结果 将上面的各个递推公式相加得到： &nbsp;&nbsp;&nbsp;&nbsp;(N - Nr) % (k - 1) = 0 ∴ Nr = N % (k - 1) 得出结论 root(N, k) = N % (k - 1) 快速幂取模算法点我查看 算法实现此算法实现基于上面数学推得到的结论，以及快速幂取模算法 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;long root(long x, long y, int k)&#123; long ans = 1; k -= 1; x %= k; while(y != 0)&#123; if(y &amp; 1) ans = (ans * x) % k; y &gt;&gt;= 1; x = (x * x) %k; &#125; return ans == 0 ? k : ans;&#125;int main()&#123; long x, y; int k; while(cin &gt;&gt; x &gt;&gt; y &gt;&gt; k) cout &lt;&lt; root(x, y, k);&#125;]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>c++语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂取模算法]]></title>
    <url>%2F2018%2F06%2F03%2Fc%2B%2B02%2F</url>
    <content type="text"><![CDATA[问题需求 求 ab % c, 其中a，b的值可能很大，导致 ab 的值long long都存不下 预备知识 模运算的性质：(a · b) mod c = [ (a mod c) · (b mod c) ] mod c · =&gt; 点乘，在这里就是指普通乘法云算法 实现思路 对于 ab % c 首先我们将b分解成如下表示 b = b0 + b1 * 21 + ··· + bn * 2n (其中的 b0, b1, ···, bn 指的是对应b的二进制表示法中对应位置的取值，1或者0) =&gt; 比如：6 —&gt; 110 =&gt; b0 = 0, b1 = 1, b2 = 1 则 ab 可以表示成下面的形式 ab = ab0 * ab1 * 21 * ··· * abn * 2n =&gt; 令 ai = abi * 2i =&gt; 则：ab = a0 * a1 * ··· * an 运用上面提到的关于幂运算的性质 -&gt; (a · b) mod c = [ (a mod c) · (b mod c) ] mod c 则 ab % c = ( (a0 % c) * (a1 % c) * ··· * (an % c ) ) % c 算法实现 1234567891011int quickMod(int a, int b, int c)&#123; int ans = 1; a = a % c; //所有项里面都有a，提取出来可统一先取模一下，减少计算量, 也可不加 while(b != 0)&#123; if(b &amp; 1) ans = (ans * a) % c; b &gt;&gt;= 1; a = (a * a) % c; &#125; return ans;&#125;]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>c++语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ unsigned int 和 int 混用的问题]]></title>
    <url>%2F2018%2F05%2F23%2Fc%2B%2B01%2F</url>
    <content type="text"><![CDATA[问题引入且看下面一段诡异的代码 123456789#include &lt;iostream&gt;using namespace std;int main()&#123; unsigned int a = 5; if(a &lt; -6)&#123; //下面的输出语句会执行 cout &lt;&lt; "unsigned 5 &lt; -6" &lt;&lt; endl; &#125;&#125; 执行上面的代码，会输出 “unsigned 5 &lt; -6” 这看起来一点都不科学 _(:з」∠)_ 敲黑板，讲重点！！！在c++里面，如果一个表达式里面同时有 unsigned int 和 int ，执行的时候会尝试把 int 转成 unsigned int。 这个时候如果int的值是非负的，执行的结果当然和预期一样 但是如果int的值是负数，它的值就变成 int的最大值 + 原值 =&gt; 其实是C++类型转换的锅，如果是int转unsigned，就会用int的最大值对原值取模 验证一下 int 转 unsigned int 的时候编译器怎么处理的12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; unsigned int a = -1; unsigned int b = -2; cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl; return 0;&#125; 执行上面的代码输出为 14294967295 4294967294 其中 232 - 1 = 4294967295 举几个栗子加深理解1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; //Example 1 u_int a = -5; int b = 4; if(a + b &gt; 0)&#123; cout &lt;&lt; "(unsigned)-5 + 4 &gt; 0 =&gt; and the value is: " &lt;&lt; a + b &lt;&lt; endl; &#125; //Example 2; string s; if(s.size() &lt; -1)&#123; cout &lt;&lt; "s.size() &lt; -1" &lt;&lt; endl; &#125;&#125; 以上代码的输出为 12(unsigned)-5 + 4 &gt; 0 =&gt; and the value is: 4294967295s.size() &lt; -1 其中Example 1很好理解，执行 a + b 的时候，b被转成了unsigned int，变成了一个很大的正数 而Example 2中，string对象的size()函数返回的也是一个无符号整数，所以也存在unsigned int 和 int 在同一个表达式里混用的问题。 不解释 =&gt; u_int &lt;=&gt; unsigned int]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>c++语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter 5 The Data Link Layer]]></title>
    <url>%2F2018%2F05%2F21%2Fcomputer_networking_05%2F</url>
    <content type="text"><![CDATA[Link Layer: Introduction and Services 链路层实现相邻节点间的可靠数据传输 nodes(节点) =&gt; 主机/端系统 和 路由器 links(链路) =&gt; 连接两相邻节点间的通信频道 The Services Provided by the Link Layer（链路层所提供的服务）链路层 所提供的 最基本的服务 就是 在两个相邻节点见得单个通信链路上转移datagram 成帧（Framing） 在 发送端 将构造数据帧，将datagram放入数据域，加头加尾（尾部是用来检测及纠错的），打包成帧 在 接收端解开 收到的 数据帧，将datagram传递给上层 链路接入（Link access） MAC (Medium access control, 介质访问控制) 协议详细规定了数据帧何时如何发送到链路上 MAC协议还用于当多个节点共享同一链路的时候，协调多个节点如何传递数据帧 可靠数据传输（Relilable delivery）数据链路层可提供两相邻节点间的可靠数据传输（但不是必须的，大多数无线协议是不提供可靠数据传输的） 流量控制（flow control）调节接收端发包的速率，防止接收端缓存溢出 差错检测（Error detection）通过添加错误检测位，在接收端可以对收到的数据帧进行错误检测 差错纠正（Error correction） 半双工和全双工（Half-duplex and full-duplex） 链路层的实现 数据链路层的实现是：硬件 + 软件 大部分功能在硬件（网卡）中实现：framing, link access, flow control, err dectection 等等 部分功能由运行在CPU上的软件完成：发送端从网络层接收datagram，以及接收端将解开frame得到的datagram传递给网络层等 硬件实现的效率高，可以做纠错等比较复杂的操作而不太影响性能 现今很多人致力于将网络层甚至传输层的一部分工作，比如Checksum放到网卡中用硬件来实现，虽然这于网络协议栈分层的思想相悖，但是确实可以提高网络性能 Error-Detection and Correction Techniques 奇偶校验（Parity checking） 校验和（Checksum） 循环冗余校验（Cyclic Redundancy Check） 奇偶校验（Parity checking） 奇校验和偶校验 奇校验：数据位上1的个数个校验位上1的个数之和为奇数 偶校验：数据位上1的个数个校验位上1的个数之和为偶数 One-bit even parity（单比特位偶校验） 存在的问题：当有偶数个bit为发送错误的时候，这种方式无法检测 可以用来检错，但是准确率不高 Two-dimensional even parity（二位偶校验） 即使偶数位比特位发送错误，也能检测出来 通过二维校验位的定位，可以精确到哪一个bit位发生错误，进而改正这个错误（接收端如果能自行改正错误将降低网络的整体时延，提升网络的性能） 可以检错，也可以纠错 校验和（Checksum）通常发送端用校验和算法将让整个数据包的所有bit位参与计算，得到一个校验和（最简单的实现方式是将其看做一系列的数值，直接相加），在接收端再次计算这个校验和，并与收到的校验和逐bit比对 循环冗余校验（Cyclic Redundancy Check） 数据格式说明 前d位为数据域 后r位为CRC码 生成多项式G 生成多项式 G 共有 r + 1位 （其中R位CRC码的长度） 可能直接以 二进制的形式 给出 也可能以 多项式的形式 给出（需要先转成二进制形式） Eg.: G = x4 + x3 + x ==&gt; G : 11010 举个栗子 在data后面加上r位0用与计算 其中里面每一步处理的时候执行的是 异或运算 若最后的结果位数不够r为，则要在前面补上足够的0 Multiple Access Protocols（多路访问协议） 网络的两种链路类型 point-to-point link (点对点链路) =&gt; 只有一个发送端和接收端 brodcast link (广播链路) =&gt; 可能同时存在多个发送端和接收端在同一个链路上通信 Introduction 多路访问问题（multiple access problem）当在同一个通信链路上同时存在多个发送端和接收端的时候，他们之间要进行通信，由于同一时刻必然只有一个接收端和发送端，如何确保并协调这些节点的通信就是 多路访问问题 =&gt; 多路访问协议（Multiple Access Protocol）就是致力于解决这个问题 碰撞的发生及处理在广播链路中，通常一个节点发送数据，该链路连接的所有节点都会收到一份copy，如果同一时刻有两个发送端在发送数据，则接收端无法解析这些数据，这就发送了 碰撞（collide） =&gt; 通常一旦碰撞发生，接收端就会选择丢弃这些包，这就相当于丢包发送了。这一段时间，两个发送端发送数据都不会被成功接收，链路并没有成功传输数据，浪费了带宽资源。而且通常不作处理的话，接入的节点越多，发生碰撞的几率越高，带宽就被大量的浪费 多路访问协议分类 信道分隔协议（channel partitioning protocols） 随机访问协议（random access protocols） 轮询协议（taking-turns protocols） Channel Partitioning Protocols 采用固定的资源分配方式，资源独占独享 资源利用率低 不会发生冲突 TDM 和 FDM Random Access Protocols 使用随机访问协议时，一个 正在传输的节点 总是可以 享用所有的带宽。当 发生碰撞 时，所有 参与碰撞的节点 都会 重传数据包。但并不是立即重传，而是 随机等待一段时间之后再重传（It waits a random delay before retransmitting th frame）。而且每个参与碰撞的节点产生时延都是独立且随机的，这样就可以保证一部分节点可以错开其它节点，不发生冲突而成功传送数据包。 Sloted ALOHA （分时隙的ALOHA协议） 假设 所有数据帧的长度都为L比特（All frames consist of exactly L bits） 每个时隙的大小为L/R秒，也就是说一个在 一个时隙内刚好可以传输一个数据帧 （Time is divided int oslots of size L/R seconds, that is, a slot equals the time to transmit one frame） 节点只在时隙开始的时候传递数据包（Nodes start to transmit framges only at the beginings of slots） =&gt; 也就是说在时隙内不会有其它未在传输的节点试图传递数据 所有节点都是同步的，这样所有节点都能知道时隙什么时候开始（The nodes are synchronized so that each node knows when the slots begin）=&gt; 前面的是书上的原话，同步和异步的定义在不同的场景下的定义可能不一样。这里所说的同步应该是对时间轴进行同步，所有实现的时候，只要时隙一开始，所有节点都能知道，并单独决定是否发送数据帧。 一旦两个或更多的数据帧在同一时隙内发生了 冲突（collide），所有的节点都能在时隙结束前知道发生了冲突。（If two or more frames collide in a slot, then all the nodes detect the collission event before the slot ends） 每个节点所执行的操作 当节点 有一个新的数据帧要发送 时，它会 等待下一个时隙的开始，并试图 在下一个时隙内发送整个数据帧 （When the node has a fresh frame to send, it waits until the begining of the next slot and transmit the entire frame in the slot.） 如果 没有发送冲突 ，则节点 认为数据包已成功传输且不用考虑重传，如果还有数据帧未发的话，这个时候节点就可以准备发送下一个数据帧。（If there isn’t collision, the node has successfully transmited its frame and thus need not consider restransmitting the frame. The node can prepare a new frame for transimission, if it has one） 如果 发生了冲突，节点能够在时隙结束前获悉，节点会在接下来的连续时隙内以概率p重传数据帧，直到这个数据帧被成功发送且没有发送冲突。（If there is a collision, the node detects the collision before the end of the slot. The node restransmits its frame in each subsequent slot with probability p until the frame is transimited without a collision） 以概率p发送数据帧这是在发送冲突以后，节点会重传因为冲突而未传输成功的数据帧。但是为了避免下一时隙的大概率冲突，Slotted ALOHA协议选择让每个节点以概率p重传，也就是说发送冲突的每个节点在下一时隙有概率p的可能重传数据包，有 (1 - p) 的可能选择等待（值得注意的是，选择等待的节点在没有重传成功之前，都会在下一时隙开始时以概率p重传发送冲突的数据包） 。而且每个节点在未重传成功之前，都会每次以概率p发送，且是各自独立的，这也就实现了随机访问协议中 当冲突发生的时候，每个节点会独立的随机等待一段时间 的特性 举个栗子 上面假设三个节点各有一个数据包需要发送 1时刻，3个节点都试图发送数据，发送冲突 2时刻，3个节点都有需要重传的数据包，但是选择等待 3时刻node3选择等待，但是另外连个节点选择发送，发送冲突 4时刻只有node2选择发送，发送成功（至此，node2已经没有需要发送的数据帧） 5时刻node1和node3都选择等待 6时刻只有node1选择发送，发送成功（至此，node1已经没有需要发送的数据帧） 7时刻，node3成功发送数据帧 可以看出，发送3个数据帧，却用了7个时隙，浪费了带宽 Slotted ALOHA 协议的优点 单节点的瞬时带宽可达到最大带宽 时隙的分配高度分散，只给需要传输数据的节点分配时隙（当系统中每个时隙只有一个节点需要发送数据的时候，该协议可以工作的很好） 实现简单 缺点 有可能发生碰撞进而浪费时隙（而且参与的节点越多，发生碰撞的可能性越大） 需要严格的时钟同步 当有 大量的节点参与 的时候，时隙（带宽）的最大利用率 大概只有 1 / e ≈ 37% Aloha (pure ALOHA) 纯的ALOHA协议没有时钟同步。当有一个数据帧要发送的时候就立即发送，当发生冲突的时候就立即以概率p重传，以概率（1 - p）等待传输一个数据帧所需要的时间。=&gt; 冲突发生的概率更大了，当有 大量的节点参与 的时候，带宽的最大利用率 大概只有 1 / 2e ≈ 18.5% Carrier Sense Multiple Access (CSMA, 载波侦听多路访问) 文明交流所必备的两个素质 Listen before speaking ：如果别人在啊讲话，则等别人说完再发表言论。在网络世界中，就是当你有一个数据帧需要发送的时候，而这个时候其它节点正在发送数据帧，则当前节点等待一段时间后再看是否还有节点在传输，仍有则继续等待，直到信道空闲的时候，发送数据。=&gt; 载波侦听（carrier sensing） If someone else begins talking at the same time, stop talking ：如果在发送数据的过程中，发现其它节点也在发送数据，则停止发送数据。=&gt; 冲突检测（collision dection） CSMA的大致原理发送数据帧之前先侦听信道，如果信道为忙则等待一段时间后再尝试发送，如果为闲，则立即发送。 CSMA仍然存在冲突当 一个节点A发送数据到信道中，到另一个节点B可以侦听到节点A正在发送数据之间存在一段时延，如果在这短时间内，节点B刚好有数据发送，那么由于它还没有检测到A正在发送数据，就会认为当前信道是空闲的，接着B就开始发送数据，这样冲突就出现了。 不侦听信道，冲突发生时不处理 侦听信道，冲突发生时停止发送 Nonpersistent CSMA =&gt; 不持续侦听信道 当节点有数据需要发送的时候，信道为闲则发 信道为忙，则等待一段时间后在尝试发送 1-persistent CSMA 信道为闲，则发 信道为忙，则持续侦听信道，知道信道为闲，然后以概率1发数据（当两个节点同时侦听到信道闲，并都以概率1发数据，就发生了冲突） p-persistent CSMA 信道为闲，则发 信道为忙，则持续侦听信道，知道信道为闲，然后以概率p发数据 CSMA with collision detection (CSMA/CD, 带冲突检测的载波侦听多路访问协议) 要求节点必须全双工工作（发送数据包的同时也尝试接收数据包），当检测到冲突时（如果发送数据包的时候收到其他节点发送的数据包就表示发送了冲突），立即停止发送数据包 =&gt; 可以把冲突带来损失降低 目前为止，所有的无线传输都是半双工的，故不能采用CSMA/CD CSMA with collistion avoid (CSMA/CA, 带冲突避免的载波侦听多路访问协议)因为无线传输时半双工的，无法再发包的同时检测冲突，故一旦冲突发生，发包也不会停止，故应该尽量避免冲突 Taking-Turns Protocols（轮流协议） polling protocol (轮询协议)主节点对每个节点进行轮询，只要当被询问时才可以发送数据 优点：没有冲突，没有空时隙 缺点：会有询问延时，需要主节点，会有单点故障 token-passing protocol（令牌传递协议）一个特殊的帧被作为令牌，在节点之间按特定的顺序传递，只有持有令牌的节点才可以发送数据（且每次发送的数据有上限） 优点：不需要主节点，没有冲突，没有空时隙 缺点：可能有些节点中途宕机，导致令牌无法传递，或者持有令牌后宕机，导致令牌丢失等等 Local Area Networks (LANs, 本地局域网) Link-Layer Address （链路层寻址） MAC Address MAC地址是 数据链路层的地址，同时也是数据链路层所采用的编址方式 长度为48 bits，常用12个16进制的数字表示（2个一组，6组） 每个网络适配器上有一个网路地址，网卡出厂的时候的MAC地址是全球唯一的（是由IEEE统一管理的），但是现在可以用软件修改网络适配器的MAC地址，这里仍然假设它是唯一且不变的。 Address Resolution Protocol (ARP, 地址解析协议) ARP 协议实现的是IP地址到MAC地址的映射 当 一个节点发送一个frame 时，实际上所有在 同一个子网内的节点都会收到 一个copy，只是在链路层做了一层判断，若 该frame的目的MAC地址与本节点的MAC地址匹配则解包，传递给上层，否则直接丢弃。 每一个 藉由网络适配器在局域网内通信的 节点都会在内存中维护一张 ARP table（地址映射表），保存了 当前局域网内所有已知主机的IP地址与MAC地址的映关系。（且映射表中的每一个表项都有一个TTL，一旦过期便会移除该表项） 当欲发送的frame的目标IP在本地ARP table中 找不到对应的映射时 ，节点 发送一个APR query package，目的MAC地址为全1，作为广播，只有与目的IP匹配的设备会返回一个正常的数据帧，节点再记录下IP地址与返回消息中包含的目标节点的MAC地址的映射。 ARP协议是即插即用的 MAC地址只在本局域网内有效 =&gt; 数据帧在穿越路由器的时候链路层首部的源MAC地址和目的MAC地址都要修改 Ethernet (以太网) 它是互联网中有线网络通信的事实标准 所采用的MAC (Multiple Access Control, 多路访问控制) 协议为 1-persistent CSMA/CD (Carrier Sense Multiple Access with Collide Detection, 带冲突检测的载波侦听多路访问协议) 以太网相较于其他有线局域网最大的优势：实现简单，价格便宜 Ethernet Frame Structure (以太网帧结构) Preamble (8 bytes) : 前序/序文，不算在以太网帧长度里面 Dest. address (6 bytes) : 目的端MAC地址节点A向B发一个数据包，在数据包到达B之前，B恰好要想A发一个数据包，此时因未收到A发的包，故认为信道空闲，B向A发一个包。在B收到A的包后，意识到发送了冲突，停止发送数据包。** Source address (6 bytes) : 源端MAC地址 Type : 标识使用的是哪个网络层协议 Data : 数据域 CRC : 冗余校验码 =&gt; 以太网frame的长度范围：64 bytes ~ 1518 bytes (其中最大是因为协议规定了MTU，需要有最小长度的原因稍后会解释) CSMA/CD: Thernet’s Multiple Access Protocol 信道空闲时，立即发送，若信道为忙，则持续侦听信道 =&gt; 持续侦听 信道侦听过程中，一旦信道再次空闲，则以概率1发送数据包 =&gt; 1-persistent 在边发送数据的同时，边接收数据 =&gt; 发送数据过程中如果收到数据包则表示发送了冲突 一旦发生冲突，立即停止发送数据包，并广播一个信号（告知其它用户发送冲突了），同时等待一段时间（具体等待的时间由 “二进制退避算法” 求得） * 二进制退避算法{0， 1， 2， ···， 2m - 1} 其中m是发生冲突的次数 随机选择一个元素 x 512 bits times bit times: 在当前网络环境下传输1 bit所需要的时间 冲突10次以后集合不在扩大，即集合最大为1024个元素。冲突16次以后直接丢弃该包，不再传输 为什么以太网帧的长度最小为64 bits？ 数据帧长度不够长所引发的问题 节点A向B发一个数据包，在数据包到达B之前，B恰好要想A发一个数据包，此时因未收到A发的包，故认为信道空闲，B向A发一个包。在B收到A的包后，意识到发送了冲突，停止发送数据包。如果A在B发的包到达A之前就已经将数据包发送完毕了，即A发的数据包不够长的情况下，A可能以为数据包发送成功了吗，而实际上是发送冲突了 为什么是64个字节 CSMA/CD efficiency 当dprop -&gt; 0，或dtrans -&gt; ∞，效率 -&gt; 1 数据包长度越长，节点间距离越短，效率越高 节点数据↑，发送冲突的可能性↑，效率↓ 不同的以太网标准 T开头的都是双绞线 所有非T开头的都是光纤 同轴电缆的格式：10Base2 =&gt; 以太网负载在30%以内的时候性能很好，基本不丢包，但超过30%就会发生一系列的问题 Link-layer Switches (链路层交换机) 几种常见网络设备区别 中继器（repeter）：物理层设备 =&gt; 将信号放大后转发 集线器（hubs）：物理层设备 =&gt; 不能隔离冲突域（集线器是一种特殊的中继器） 网桥（Bridge）：二层网络设备 =&gt; 可隔离冲突域 交换机（Switches）：二层网络设备 =&gt; 可隔离冲突域 路由器（Router）：3层网络设备 =&gt; 可隔离广播域 =&gt; 网桥和交换机的功能基本一致，不过 网桥是二段口的，而交换机是多端口 的，同时 交换机还兼备“自学习” 等功能 冲突域和广播域 冲突域：在同一个冲突域的两个设备同时通信会导致冲突 广播域：在同一个广播域中的设备可以互相广播 交换机（Switches） 是 链路层设备，比Hub更智能，其重要作用 =&gt; 存储转发以太网帧 对主机透明 即插即用 自学习 允许多路同步传输 =&gt; 交换机隔离了冲突域 Switch table and self-learn 交换机通过自学习填充交换表 self-learn（自学习）交换机通过自学习可以在 Switch table中记录下从哪个端口可以到达哪个主机（下面建立交换表的过程中会详细讲述自学习） Switch table 交换表初始时为空 当收到一个frame时，记录下发送端的MAC地址以及从哪个端口进来的，并去查询交换表中有无到目的主机MAC地址对应的记录，若有则直接转发到对应端口，若无，执行下一步 若交换表中无对应的记录，则向所有的端口广播一个消息，目的MAC地址设置为目的主机，目的主机收到之后会回发一个数据包，交换机记录下其MAC地址以及从哪个端口可达。 交换机可以将一个子网分隔成多个局域网 hubs, routers, switches的比较]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter 4 The Network Layer]]></title>
    <url>%2F2018%2F05%2F19%2Fcomputer_networking_04%2F</url>
    <content type="text"><![CDATA[Introduction 网络层完成主机到主机之间的数据传输 网络层协议存在于所有的主机和路由器当中（二层交换机中没有） 当IP数据报通过路由器时，路由器会检查所有数据报首部字段（Header Checksum） Forwarding and Routing ( 存储和转发 ) Forwarding（转发）When a packet arrives at a router’s input link, the router must move the packet to the appropriate. =&gt; 转发指的是路由器将某个入口链路上到来的数据包转移到合适的出口链路的过程。 Routing（路由）The networklayer must determine the route or path taken by packets as they flow from a sender to a receiver. The algorithms that calculate these paths are reffered to as routing algorithms. =&gt; 路由是指网络通过运行路由算法，计算出一条从源端到目的端的路径的过程 补充 转发是路由器内部的事，而路由不是（路由需要网络里各个路由器的参与） 网络中的各个路由器，通过运行 路由算法 (routing algorithms)计算出保存在各个路由器本地的 本地转发表 (local forwarding table)。路由器根据此转发表来进行转发数据包。 Connection Setup（连接建立） 这是 网络 除转发和路由外 的第三个重要功能（互联网没有这个功能） 在网络层建立连接 EG.：ATM、frame-relay Virtual Circuit and Datagram Networks 虚电路网络：在网络层建立连接的网络 数据报网络：在网络层不建立连接的网络 Virtual-Circuit Networks （虚电路网络） 组成 从源到目的端的路径 VC number是标识沿路径每条链路上的号码（在每条链路上唯一即可） 沿途路由器中转发表中的项（由进入端口号的VC Number决定从哪个口出去，以及出去的时候VC Number修改为什么） 示例 网络结构 上述网络结构中路由器A的转发表 虚电路网络中连接一旦建立，数据包所走的路径就确定了（而互联网不是） Datagram networks（数据报网络） no call setup at network layer =&gt; 网络层无连接建立 routers: no state about end-to-end connections =&gt; 路由器不保持端到端的连接状态 Packets forward using destination host address =&gt; 数据包的转发是根据目的端主机地址来进行转发的 查询路由表进行转发的时候采用的是 最长前缀匹配 (longest perfix matching rule) IP是数据包网络的寻址方式 虚电路网络 VS 数据报网络 Internet(互联网) =&gt; 数据报网络 data exchange among computers 弹性服务，无严格的定时要求 “smart” end system =&gt; 终端相对智能 many link type =&gt; 有多种链路类型 ATM =&gt; 虚电路网络 envolved from telephone =&gt; 演化自电话技术 有严格的定时要求，可靠性要求高 “dump” end systems =&gt; 端系统简单，网络内部实现复杂 What’s inside a Router? Router的两个功能 run routing algorithms/protocol (RIP, OSPF, BGP)=&gt; 运行路由算法/协议 forwarding datagrams from incoming to outgoing link=&gt; 从入链路到出链路转发数据报 Input ports Line termination =&gt; 物理层 Lookup =&gt; 根据数据报的目的地址，在输入口内存中使用转发表查找应该从哪个端口输出 forwarding =&gt; 将数据包转移到对应的出口 queueing =&gt; 如果数据报到达的速率比交换结构的转发速率要快，则导致排队的发生 三种类型的交换 Memory：共享内存 =&gt; 交换速率受内存大小的限制 Bus：总线型 =&gt; 交换速率受总线带宽的限制 Crossbar Output ports Where does Queuing Occur?路由器中排队的发生可能在入口端的接收缓存或者是出口端的发送缓存 发送排队的时机 入端口收到数据包的速率大于路由器转移数据包的速率 =&gt; 入口端发生排队 出口端收到路由器转发过来的数据包的速率大于发送数据包的速率 =&gt; 出口端发生排队 网络中所有数据的调度都是非抢占式的 缓存溢出时的策略 drop-tail: 如果缓存已满，则直接将新收到的数据包丢弃 RED(Random Early Detection) =&gt; 随机早期检测。在缓存将满而未满的时候就主动随机丢弃缓存队列中的数据包 （可以优化网络的拥塞状态） 路由协议一般是应用层的 IP(Internet Protocol, 网际协议) PDU为Datagram Datagram Format （数据报结构） Version (4bits) : IP协议版本号 Header Length (4bits) : IP数据报头的长度，单位为字节 。包括头部Options Type of service (8bits) : TOS，用来标识IP数据报的服务类型 Datagram length (16bits) : 整个数据报的长度，单位为字节。包括头部和数据域 第二行的个字段主要用于分片 Time-to-live (8bits) : TTL，有效时间 =&gt; 通常指的是跳数 Upper-layer protocol (8bits) : 上层所使用的协议 Header-checksum (16bits) : 首部校验和 网络层只对Datagram首部进行校验 可行性 data在传输层有checksum，故可以不需要再网络层对data进行校验 网络层提供的是不可靠的传输，允许出错 优点只对首部进行校验，可以减少delay，同时减轻路由器的负载 =&gt; 每个路由器都要网络层数据包处理，所以要让处理的开销尽量的小 存在的问题 当某个正在网络中传播的数据包data部分出错，其途经的路由器由于只对其网络层头部进行校验，而不对data进行校验，所以会将这个出错的包继续传递，直到传递到终端才检测出来数据包错误。=&gt; 造成传输资源的浪费 TCP和UDP之外的其它传输层协议可能本身并不具备校验功能 为何每个路由器都要对数据包进行重新打包？header中的数据 每经过一个路由器都 会改变，比如TTL每跳减一，因此 header checksum 需要重新计算 IPv4 datagram 首部 最小、默认 开销为 20个字节 =&gt; 严格来讲，由于Options域的存在，首部的开销是不确定的 IPv4 Datagram Fragmentation （IPv4 数据报分片） 为什么（何时）要进行分片？低层（链路层）网络不同协议所支持的 MTU ( maximun transimit unit, 最大传输单元 ) 不一致。而互联网中不同链路可以采用不同的协议，就可能导致 路由器两端链路的MTU不一致。=&gt; 当路由器两端链路的MTU不一致，且是从MTU大的一端 -&gt; 小的一端的时候，就可能需要分片 (当然，除了分片之外，路由器也可以选择主动丢弃，让发送端去调节数据包的大小) IPv4用于实现分片的头部字段 Identification : 属于同一个数据包的分片都有一个相同的Id DF : 若该标识置1，则表示不分片 MF : 若该标识置1，则表示不是最后一个分片 Fragment Offset: 分片的偏移量 单位是8bits 一定要注意，偏移计算的是data部分，每个分片都单独有一个网络层头部 当 (MTU - 首部size) 不是8的倍数时，每个分片data部分的最大size，取不超过但最大的能整除8的数 一个示例 注意 发送主机 或者 路由器 都有 可能对IP数据报进行分片 一个 IP分组可能被多次分段（分片） 但 IP分片重组 (reassembly) 仅在目的主机进行 为何IP分片重组只在目的主机进行 不同的数据包从源端到目的端所走的路径可能不同，这就导致 不同分片可能经由不同的路由器组到达目的端 ==&gt; 换句话说，途中的某个路由器可能无法收到同一个数据包的所有分片，就无法进行分片重组 这样可以减少路由器的开销，提高网络核心的效率 IPv4 Addressing （IPv4编址） IP address 主机 和 路由器 接口长度为32bits的标识 常采用 点分十进制 (dotted-decimal notation)进行表示 Interface（接口）主机或路由器和物理链路的接口 Subnets（子网）To determine the subnets, detach each interface from its host or router, creating islands of isolated networks, with interfaces terminating the end points of the isolated networks. Each of these isolated networks is called a subnet 同一个子网内IP的高位比特位一致 拔开所有接口后，仍然连砸一起的网络属于同一个子网 CIDR(Classless Interdomain Routing, 无类型域间选路) 网络地址（子网地址）部分是长度可变的 格式：a.b.c.d/x =&gt; 其中x表示的是网络地址（子网地址）部分的长度 子网地址（网络地址）：前 x 位保留，后 32-x 位置0 主机地址：前 x 位置0，后 32-x 位保留 子网掩码 (subnet mask)：前 x 位置1，后 32-x 位置0 =&gt; 网络地址部分全置1，主机地址部分全置0 Classful Addressing（分类编址） 当ip地址表示的时候没有 /x 的时候，就可能采用的是这种方式判断网络地址和主机地址 Class A: 0.0.0.0 ~ 127.255.255.255 =&gt; A类地址前8位为网络地址 Class B: 128.0.0.0 ~ 191.255.255.255 =&gt; B类地址前16位为网络地址 Class C: 192.0.0.0 ~ 223.255.255.255 =&gt; C类地址前24位为网络地址 Class D: 224.0.0.0 ~ 239.255.255.255 =&gt; D类地址为多播地址 Class E: 240.0.0.0 ~ 255.255.255.255 =&gt; E类地址预留未用 Private IP（私有IP地址 / 内网地址）==&gt; 在很大程度上可以对互联网进行扩容（通过NAT技术） 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 特殊的IP地址 0.0.0.0 =&gt; 本主机 0···0 | Host =&gt; 主机地址 255.255.255.255 =&gt; 全局广播地址 network | 1···1 =&gt; 子网内广播地址 127 + Anything =&gt; 回环（Loopback）地址 如何辨别IP地址 IP地址范围 是包括了主机地址部分全0和全1的两个地址，但是 可分配给主机的IP地址范围 不包括。 Explicit（显示）：VLSM =&gt; 通过可变长子网掩码判别网络地址和主机地址 Implicit（隐式）：Classful =&gt; 通过判断ip地址属于哪一类IP地址，进而判断网络地址和主机地址 举个栗子12345678910111213141516171819Subnet mask is: 255.255.255.224Host IP: 202.112.41.241Problems: 1. network address and host address ? 2. how many subnets are created at most ?解： 首先判断将当前的子网掩码转为2进制： 255.255.255.224 =&gt; 1···100000 （前27位为1） 224 =&gt; 11100000 241 =&gt; 11110001 ①. 网络地址：202.112.41.224 主机地址：0.0.0.17 ②. 分析可知该IP属于C类IP，前24位是网络地址 27 - 24 = 3（位） 2^3 = 8（个） 所以对多可以创建8个子网。 DHCP (Dynamic Host Configuration Protocol, 动态主机配置协议) plug-and-play =&gt; 即插即用 基于UDP 动态自动分配IP地址，可充分利用IP地址资源 为何选用UDP TCP延迟大，UDP效率高 一开始Client并没有IP地址，无法与服务端建立连接，只能通过UDP广播的形式与服务端通信 分配IP的去求对丢包和可靠传输的要求不高。 IPv4地址耗尽的解决措施 VLSM / CIDR IPv4 DHCP NAT IPv6 NAT (Network Address Translation, 网络地址转换) NAT是在共有IP地址和私有IP地址之间进行转换的技术 NAT中的每个外网端口号对应内网主机当中的一个进程 =&gt; 使得一个IP的资源被充分的利用 对于从 内网流出的数据包，将其 源IP地址和端口号 从私有的IP地址和端口号 替换成公网的IP地址和端口号 将内网IP、端口与外网IP、端口的 映射关系，保存在 NAT table 当中 对于从 外网流入的数据包，参照 NAT Table，将 目的IP地址和端口号 替换成私有的IP和端口 ICPM (Internet Control Message Protocol, 互联网控制消息协议) 报告差错 =&gt; 用于在IP主机路由器之间传递控制消息（主机通否？主机可达否？路由可用否？） ping IPv6 IP地址扩容 提供区分服务 减少路由器的工作，提高效率 =&gt; IPv6 有分片机制，但是在基本首部中是不支持的，在扩展首部中可以支持。但 规定之只能在端系统中进行分片和重组，路由器不可操作扩展首部（除了逐跳选项） 制定IPv6协议的动机 32位的IPv4地址不够用 =&gt; 这是最主要的动机 IPv6首部的格式有利于提高转发和处理速率 IPv6首部的变化，提高了Qos IPv6 datagram format 首部长度固定为40 bits (基本首部) 路由器上不允许进行分片 概述 IPv6吧IP地址的长度增加到了16个字节 IPv6简化了IP Datagram的首部格式 =&gt; 字段数减少了，且基本首部的长度是固定的 IPv6增强了对进一步扩展的支持 =&gt; 将IPv4首部中Options项移到了扩展首部当中 IPv6增强了对Qos（Quality of Service）的支持 IPv6增强了对安全的支持 IPv6增加了对Anycast通信方式的支持 IPv6数据报的一般格式 IPv6数据报的首部 长度固定为40个字节，称为基本首部 取消不必要的功能，字段个数减为8 取消Header checksum 加快了路由器处理数据报的速度 支持扩展首部（分片、逐跳选项、路由选择…） =&gt; 数据报途中经过的路由器都不处理这些扩展首部（除了逐跳选项），这 大大提高了路由器的处理效率 有效载荷（payload）= 扩展首部 + 数据 地址长度扩展为128位 IPv6数据报格式 补充 记法：采 冒号十六进制记法，支持零压缩 IPv6支持：单播、组播、任播（目的站是一组计算机，但数据报在交付的时候只交付其中的一个，通常是距离最近的一个） IPv4映射的IPv6地址 IPv6相较于IPv4的变化 IPv6首部长度固定为40字节，而IPv4的默认为20，可以由options IPv6基本首部中没有分片字段，移动到了扩展首部中（而且IPv6的分片和重组只能在终端上运行） IPv6没有首部Checksum =&gt; 简化路由器的工作，提高效率 IPv6地址长度为128位，而IPv4为32位 IPv6支持任播，而IPv4不支持 IPv6首部字段减少，提高了路由器的处理效率 ICMPv6 差错报告报文 提供信息的报文 多播听众发现报文 邻端发现报文 IPv4向IPv6过渡的方案 双协议栈——Dual IP Layer/Dualo Stack =&gt; 在主机和路由器上同时实现IPv4和IPv6两种协议 隧道技术（Tunneling）：把IPv6分组封装在IPv4分组当中传送 =&gt; 把IPv6 datagram 整体作为数据封装在IPv4 datagram 中进行传送 Routing algorithms （路由算法） Routing =&gt; 确定一条从源端到目的端的一条路径的过程（不一定是最短的） global routing algorithms =&gt; 集中式路由算法 decentralized routing algorithms =&gt; 分散式路由算法 The Link-State (LS) Routing Algorithms 链路状态路由算法（集中式） 采用Dijstra算法求最短路径 伪代码 u =&gt; 源端 N’ =&gt; 一个包含所有到源端最短路径已知的点的集合 C(x, y) =&gt; x, y之间的link-cost D(v) =&gt; 节点v到源端的距离，不可达则为∞ P(v) =&gt; 节点v到源端路径的前向节点 12345678910111213Initiazation: N' = &#123;u&#125; for all nodes v if v adjacent to u then D(v) = C(u, v) else D(v) = ∞Loop find w not in N' such that D(w) is a minimum, add to N' update D(v) for all v adjacent to w D(v) = min&#123;D(v), D(w) + C(w, v)&#125;Until all nodes in N' 举个栗子 运行链路状态路由算法得到的结果 得到一颗最小生成树 得到一张转发表 在LS路由算法中，为了获取所有节点的Link-cost，有一个 链路状态广播（利用洪泛获取link-cost信息） 的过程，开销相对较大 The Distance-Vector(DV) Routing Algorithms 链路状态路由算法（分散式） 利用的是动态规划的思想 伪代码 Dx(y) =&gt; x到y的最短路径的link-cost Dx(y) = MINv{C(x, v) + Dv(y)} =&gt; 其中，v为x的所有邻居 对于每个节点x，运行如下路由算法 12345678910111213141516171819202122Initialization: for all destinations y in N: Dx(y) = C(x, y) //如果是x的邻居则有值，否则为 ∞ for each neighbor w: //一开始不知道邻居到其它节点的Link-cost Dx(y) = ? for all desrinations y in N for each neighbor w: //向自己的邻居节点发送自己已知的距离向量 send distance vector Dx = [Dx(y): y in N] to w、Loop //等待自己到邻居的link-cost改变，或者收到邻居发给自己的距离向量 wait (until I see a link cost change to some neighbor w or until I receive a distance vector from some neighbor w) for each y in N: Dx(y) = MINv&#123;C(x, v) + Dv(y)&#125; // 如果自己到任一节点的link-cost发生变化，向所有的邻居发送距离向量 if Dx(y) change for any destination y: send distance vector Dx = [Dx(y): y in N] to all neighborsforever 伪代码说明 每个节点在本地保存自己的距离向量和所有邻居节点的距离向量 一旦自己到邻居的link-cost变化或者收到邻居发的距离向量，则重新计算自己的距离向量，如果有变化就发给所有的邻居。 Link-cost change: good news travels fast =&gt; 当某个 link-cost 减小，网络很快趋于稳定（收敛） bad news travels slow =&gt; 当某个 link-cost 增大，需要经过很多次迭代才收敛（存在计数到无穷问题） poison reverse(毒性反转)当RouterA发现与RouterX的连接断开，并准备向邻居节点发送新的距离向量的时候，并不是忽略它，而是将到他的路径毒化，设置其跳数为最大跳数加1，即不可到达。让其他节点尽快知道RouterX已经不可经由RouterA到达了，加快网络的收敛速度。 DV vs LS Message Complexity（报文复杂性） LS: n个node，E跳link，需发送O(nE)个messages DV: 只在相邻节点间传递消息 收敛速度 LS: 固定，要求发送O(nE)个messages =&gt; 可能存在震荡 DV: 收敛时间变化不定 =&gt; 环路问题，计数到无穷问题 健壮性 LS: 节点可能通告不正确的链路费用 ；每个节点仅计算自己的表 DV: 节点可能通告不正确的路径信息 ；每个节点的表都由他人使用 =&gt; 差错通过网络进行传播 Distance Vector Link State 仅与邻居节点交换消息 向网络上所有其他节点广播消息 消息包括到所有节点的最短距离 消息仅包括到邻居节点的距离 收敛速度比较慢 收敛速度比较快 会广播不正确的路径信息 会广播不正确的链路信息 有计数到无穷（Count to Infinity Problem）问题 没有计数到无穷（Count to Infinity Problem）问题 Hierarchical Routing（分层式路由） Intra-AS routing algorithms =&gt; 自治系统内部路由算法 Inter-AS routing algorithms =&gt; 自治系统间路由算法（只传递可达性信息） Routing in the Internet 内部网关协议(IGP) =&gt; 自治系统内部路由协议的总称 RIP OSPF RIP 基于UDP，且RIP为应用层协议（RIP的报文封装在UDP数据报中发送，故RIP为应用层协议）=&gt; 值得注意的是，路由器应该有应用层和传输层，否则无法运行路由协议。但是在转发数据包的时候不使用传输层和应用层的功能 采用距离向量路由算法（DV算法）=&gt; 以跳数作为距离指标，并且将跳数限制在15跳以内 RIP跳数 =&gt; 从当前节点到目的节点所穿越的子网个数，包含目的子网（最小为1） RIP协议的最大跳数为15 每30s更新一次，如果180s未收到某个邻居节点的向量表，则认为其已经断开（采用毒性反转之后，如果收到某个邻居节点的向量表中包含某个跳数大于RIP的最大跳数，就认为那条路径断开，而不用等待180s） 转发表示例 OSPF 读书路由协议属于应用层，而 OSPF 不是，它 是传输层协议。它在IP之上却没有使用其他传输层协议 采用的是链路状态路由算法（LS算法） BGP(边界网关协议) 自治系统间的路由协议 基于TCP 主要传递可达性信息 静态路由表的计算 （！！！圈重点） 例题： 解答： 单播、组播、广播、任播 单播：一对一，只有一个接收端 组播：一对一组 =&gt; 组内成员可以来自不同的子网，接收端是组内的所有成员 广播：一对所有 =&gt; 默认是在某个子网内部，不能穿越路由器 共性：一个发送端 Brodcast and multicast routing实现广播的两种复制数据的方式 Source-duplication =&gt; 源端复制（效率很低） In-network duplication =&gt; 网内复制（会有洪泛问题） Uncontrolled Flooding（不可控洪泛）When node receives broadcast packet, sends copy to all neighbors 当收到某个邻居的广播报文时，无条件地转播给其它所有的邻居 =&gt; 如果有网络有回路存在，就会导致“广播风暴” Controlled Flooding（可控洪泛） Sequence-number-controlled flooding （序列号可控洪泛）给每个数据包都加上一个序列号，当再次收到一个序列号相同的数据包的时候不再转发给邻居 =&gt; 可以避免“广播风暴”，但是不能完全解决冗余数据包的问题 Reverse path forwarding (RPF, 反向路径转发) 依赖于路由器知道自己与发送端的一条最短路径 当收到一个数据包的时候 先创建一个从自己到源端的最短路径 如果发送这个 数据包的节点在该路径上，则将其转发给所有的邻居，否则不转发 可以避免 广播风暴，但是仍然存在冗余数据包问题 利用生成树进行广播生成树构建好之后，路由器收到一个广播数据包，只转发向包含于生成树的路径转发数据包 =&gt; 没有冗余数据包，也可以避免广播风暴 用于组播的协议 Distance-Vector Multicast Routing Protocol(DVMRP) Protocol-Independent Multicast(PIM) routinh protocol]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter 3 Transport Layer]]></title>
    <url>%2F2018%2F05%2F09%2Fcomputer_networking_03%2F</url>
    <content type="text"><![CDATA[Introduction of Transport-Layer Servicers （传输层提供的服务） 传输层将网络层所提供的主机到主机之间的 逻辑通信（logical comminication）扩展为进程到进程间的通信 =&gt; !!最主要的的功能 传输层只在端系统（end systems / hosts）中才有，在路由器和二层交换机上没有 Inetnet的传输层协议：TCP、UDP 传输层 VS 网络层 网络层 完成的是 主机到主机 之间的逻辑通信， 传输层 完成的是不同主机间 进程到进程 的逻辑通信 =&gt; 可以说，传输层扩展了网络层的配送域 PS: 并不是说传输层可以单独完成不同主机间进程到进程通信，肯定是要基于网络层及之下各层所提供服务的支持。但是以应用进程的视角来看，确实它只要把通信的消息传给传输层，传输层会帮他把消息投递到目的主机的传输层，目的主机进程就从它的传输层中获取消息。 网络层提供的是不可靠的传输（best-effort delivery service）， 而 传输层可以 在网络层不可靠的基础上引入一些可靠数据传输的机制，来向上 提供可靠的传输（如：TCP） 网络层和传输层都不能提供最短延迟和最小带宽的保障 Internet 传输层协议 TCP 可靠数据传输 （reliable data transfer） 保证数据有序分发 拥塞控制（congestion control） 流量控制（flow control） UDP 不可靠 无序分发 Multiplexing and DeMultiplexing （分解与复用）传输层通过复用收集各进程的消息，通过分解将消息分发给各个进程 各层的PDU（某一层协议所处理的最小数据单元） Socket 是数据穿梭于网络进程和网络之间的大门，同时也就是传输层和进程之间的门户。与传输层直接通信的其实是进程中的Socket（一个进程可以由多个Socket） Demultiplexing（分解）传输层将收到的网络层投递给它的Segments，去除传输层头部，分发给正确的Socket Multiplexing（复用）传输层收集来自各个Socket的message，并加上传输层头部，生产Segment，再交由网络层 每个Socket对应于一个端口号，传输层在分发Segments的时候通过目的端端口号判断应该分发给哪个Socket UDP 的 Multiplexing and DeMultiplexing 一个 UDP Socket 由一个二元组唯一标识（目的IP，目的端口号） UDP协议在分发的时候就根据上面提到的二元组分发Segment给对应的Socket（实际上是去除传输层头部，然后将里面的Message发送给Socket） 来自不同IP、端口（源IP，源端口），但是目的IP和端口号一致的Segment会被分发给同一个Socket TCP 的 Multiplexing and DeMultiplexing 一个 TCP Socket 有一个四元组唯一标识（源IP，源端口号，目的IP，目的端口号） TCP协议在分发的时候就根据标识TCP Socket的四元组来分发Segments 来自不同IP、端口（源IP，源端口）的Segment会被分发给不同的Socket Connectionless Transport: UDP （无连接的传输层协议）——UDP） UDP（User Datagram Protocol, 用户数据报协议） 基于UDP的应用层协议：SNMP、RIP、DNS、NFS 为什么需要UDP？ UDP 不需要建立连接 （少了建立连接的开销以及带来的时延） 实现简单 =&gt; 发送者与接受者之间由于是无连接的，所以不需要保存连接状态信息 没有拥塞控制 =&gt; 不限速 UDP头部较小（Small packet header overhead）=&gt; UDP由于需要实现的功能较少，头部的字段也比较少，只需要8 byte UDP的应用场景 多媒体（在线视频） 具有重复性操作的场合（如：DNS） 一对多通信的场景 UDP所提供的服务 传输层将网络层所提供的 主机到主机 之间的逻辑通信 扩展到进程到进程 间的逻辑通信 校验和（Checksum） UDP Segment Structure 首部 只有四个字段，只占8 bits 结构异常简单 Length指的是整个Segment的长度，包括数据域，以字节为单位 UDP的Checksum只能检错，不能纠错 Principles of Reliable Data Transfer（可靠数据传输原理） 校验和 =&gt; 检验比特差错 ACK反馈 序列号 =&gt; 解决冗余数据包问题（冗余数据包指的是接收端会收到一个数据包的多份拷贝） 定时器超时重传 =&gt; 解决丢包问题 重传 rdt1.0=&gt; 假设信道完全可靠，无丢包，无比特差错 发送端传输层只要完成从应用层接收message，打包（给message加上传输层头部，构建Segment），并发送给可靠信道进行传输。而接收端传输层只需要从信道获取Segment，解包，然后分发给对应的Socket即可 rdt2.0=&gt; 假设信道无丢包，但是有可能发生比特差错=&gt; rdt2.0是一个典型的 ARQ协议，也是一种停等协议（stop-and-wait protocol） ARQ (Automatic Repeat reQuest) protocolsIn a computer network setting, reliable data transfer protocols based on such retransmission are known as ARQ prorocols 在计算机网络中，基于重传的可靠数据传输协议，我们称之为ARQ协议 ARQ协议的要求： Error detection（错误检测） Receiver feedback（接收反馈） Retransmission（重传） rdt2.0 协议就是一种ARQ协议 发送端 从上层应用层获取消息，打包，发送到信道传输。接着进入等待状态，等待接收端的ACK/NAK。 如果收到ACK，则表示接收端收到了正确无误的数据包，状态切换回等待消息的状态，如果有消息就继续发送，如果没有，则等待应用层的消息 如果收到NAK，则表示接收端收到了数据包，但是数据包 发生了比特差错，则重传之前发送的数据包 接收端 接收端从下层接收到数据包之后进行校验，如果 发生比特差错，则 向发送端发送一个NAK并丢弃该数据包 如果 没有发生比特差错，则解包后 传递给上层，并向发送端发送一个ACK 存在的问题如果当接收端返回的ACK/NAK也发生了比特差错时，发送端并不知道此次发送是否成功，那么它该作何处理？ 思路一：xxx -&gt; 你说什么？-&gt; 你说什么？-&gt; 你说什么？-&gt; …简单粗暴，接收端收到一个回复不知道是ACK还是NAK就再次询问客户端到底有没有正确接收。怕不是要打起来一会儿。。。 思路二：引入比特校准机制添加最够的Checksum，让其既具备检错功能，也具备纠错功能。这要求信道传输数据包的时候不能丢失（在rdt2.0的假设中是具备的，但是实际中是会发生丢包的），而且可能因为要兼具纠错功能，Checksum会很长 思路三：瞎几把重传一旦发送端收到的回复发生比特差错，无法判断的时候，就直接重传。这是一个稍微可行的方案，但是由于在无法判断传输是否成功的情况就重传，客户端可能会收到一个数据包的多个拷贝(产生冗余数据包（duplicate packets）问题)，这个时候客户端就不知道该如何判断服务器发过来的是一个没有接收过的数据包还是一个冗余的数据包 =&gt; 解决冗余数据包问题 =&gt; 引入序列号 (sequence number) 机制发送端在发送数据包的头部多加一个Sequence number的字段，接收端在接收到一个数据包的时候将其序列号取出，与自己已经接收到的前一个数据包的序列号对比，就可以判断这个数据包是不是冗余的了。因为rdt2.0采用是一种停等协议的工作模式，所以用1 bit的序列号就可以解决这个问题 rdt2.1=&gt; 在rdt2.0的基础上采用上面思路三 + 引入序列号的方式解决了冗余数据包问题 =&gt; 还是采用了NAK + ACK的实现方案 rdt2.2=&gt; 在rdt2.1的基础上，去除了NAK，收到错误数据包之后不发送NAK，而将最近一次成功接收到的数据包的ACK发送回去 =&gt; 这种方案就导致发送端可能接收到同一个数据包的多个ACK (冗余ACK，duplicate ACKs) rdt3.0=&gt; 假设信道可能丢包，但是有可能发生比特差错 =&gt; 在rdt2.2的基础上，考虑丢包问题。 =&gt; 定时器 + 超时重传 =&gt; 解决丢包问题 接收端FMS(finite-state machine, 有限状态机)图同rdt2.2 Pipelined Reliable Data Transfer Protocols（流水线型可靠数据传输协议） rdt3.0其实已经是一个可用的协议了，但是采用停等协议大大限制了网络的传输性能（发送端必须接收到接收端返回的ACK才发送下一个数据包或者重传，增大了传输时延，降低了带宽利用率）。而相比之下，流水线型可靠数据传输协议 允许已发送未确认的数据包可以有多个 Go-Back-N (回退N) Selective repeat（选择重传） Go-Back-N (GBN)回退N 定时器超时，所有已发送未被确认的数据包都 重传 采用累积确认：收到ack=10，则表示序列号为10及之前的数据包都已正确接收，接收端下一个期望收到的数据包的序列号为11 接收端收到乱序的数据包直接丢弃 Go-Back-N滑动窗口 base : 最早的发送却没有被确认的数据包的序列号 nextseqnum : 最小的没有使用的序列号（实际上指的是发送下一个非重传数据包时所使用的序列号） N : 发送端序列号窗口的大小（限制发送端已发送未被确认数据包的数量，在流量控制的时候可以遏制发送端发包的速率） [base, nextseqnum - 1] : 已发送未被确认的数据包的序列号范围 [0, base - 1] : 发送且已被确认的数据包的序列号 [nextseqnum, base + N - 1] : 剩余可用的序列号范围（指的是该时刻在不溢出发送窗口大小N的情况下，可以继续使用的序列号） ps: 如果序列号的取值是以取模的方式循环使用，上面的范围划分就略有变动，但是意思是差不多的 Go-Back-N FSM 图 发送端 上层的调用（Invocation from above）: 当上层调用rdt_send()发送数据包的时候，发送端检查发送窗口是否已满（即检查一发送未确认的数据包的个数是不是已经达到N了），如果满了就通知上层拒绝发送（接着上层肯能会一段时间后重试），没有满则生成一个Segment并发送 收到一个ACK（Receipt of an ACK）: 发送端采用 累积确认（cumulative acknowledgment）的方式，例如：收到ack=10，则表示序列号为10及之前的数据包都已正确接收，接收端下一个期望收到的数据包的序列号为11 超时事件（A timeout event）: 发送端开始发送数据包的时候回启动一个定时器，之后每收到一个ACK会检查是否还有已发送未确认的数据包。有则重启定时器，没有则停止定时器。一旦定时器超时，所有已发送但未确认的数据包都将被重传（最多重传N个） 接收端 接收端收到 一个序列号为n的 有序的数据包（in-order packet, 表示接收端最近一次传递给上层的数据包的序列号为n-1），则给发送端回一个对应序列号的ACK，同时将数据包解包够传递给上层 接收端收到错误的数据包 则 直接丢弃 接收端收到正确但乱序的数据包（就比如收到的数据包序列号为n，但是上一次传递给上层的数据包的序列号不是n-1），接收端的处理也是 直接丢弃。这虽然看起来很浪费，但却是比较明智的处理方式。试想，如果接收端收到一个序列号为n+1的数据包，但是上一次传递给上层的却是序列号为n-1的数据包，则很可能序列号为n的数据包在传输的过程中丢失了，那么必然导致发送端计时器超时，发送端会重发数据包为n和n+1的数据包，所以接收端完全没有必要缓存序列号为n+1的数据包（这样实现起来简单并且有效）。 补充 发送端既然采用的是累积确认，那么如果发送端收到一个对序列号为n的ACK，但是上次收到的是n-3的，对n-1和n-2的ACK可能丢失了。这个时候发送端不会理会那两个丢失的ACK。因为接收端是有序接收的，所以发送端收到对序列号为n的数据包的ACK就可以认为序列号为n以及比n小的数据包都已经成功被接收了 Selective Repeat（SR）选择重传 发送端 从上层收到数据（Data received from above）：当发送端接收到上层的数据时，获取下一个可用的序列号，如果该序列好在发送端序列号窗口内（表示当前窗口未满），则打包发送。如果不在序列号窗口内，则和GBN一样，发回给上层或缓存起来。 超时（Timeout）：发送端会为每一个已发送未确认的数据包维护一个逻辑计时器，一旦某个计时器超时，就重发它所负责监视的那个数据包。 收到ACK（ACK received）： 收到的ACK所确认的数据包的序列号 落在滑动窗口内，则将其标记为已确认 收到的ACK所确认的数据包的序列号 等于send_base（就是滑动窗口的第一个序列号），则 将滑动窗口右移至第一个未被确认的序列号处。 接收端 如果序列号在[recv_base, recv_base + N - 1]范围内被接收（也就是说收到的数据包在接收端的滑动窗口内）：向发送端 回一个对该序列号的ACK。 如果该序列号不等于recv_base，则将该序列号标记为已接收，将数据包缓存起来 如果该序列号等于recv_base，则接收端 滑动窗口右移至第一个未标记的序列号处。并将刚才扫过的数据包（就是[old_recv_base, new_recv_base - 1]之间的数据包）一并上交给上层。 如果序列号在[recv_base - N, recv_base - 1]范围内被接收（也就是说这个刚收到的数据包之前已经接收过并回复ACK了）：向发送端回一个该序列号的ACK =&gt; 这个ACK看起来是多余的，其实是必须的。因为接收端将ACK发出之后就可能导致滑动窗口右移的操作。如果发送给发送端的ACK没有到达或者出错了，接收端在计时器超时之后就会重传，而这个时候发送端的窗口已经右移了。如果不再对这个数据包回复一个ACK，则导致发送端该序列号一直没有被确认，发送端就会不断重发这个数据包，而且滑动窗口也会停滞不前。 其他情况（发生比特差错，收到右溢出滑动窗口的包等）：忽略这个数据包，直接丢弃 滑动窗口大小的问题=&gt; 滑动窗口的大小应该小于或等于序列号空间大小的一半 当序列号范围有限时，如果接收端滑动窗口太大，可能导致接收端无法判断刚接收到的数据包是一个新的未接收过的数据包还是重复的已经接收过的数据包 举个栗子： 图中，1等待接收（可能由于丢包，比特差错等，等待发送端重传。或者是由于所走路由的问题，比2,3到来的晚），2,3已经接收，4可以接收 recv_base = 1, N = 4。显然，序列号是采用 mod 6 的方式复用的 这个时候 收到一个序列号为4的数据包， 那么它 可能是一个新到来的落在滑动窗口内的数据包([1, 2, 3, 4] =&gt; [recv_base, recv_base + N - 1]) 也 可能是上一轮滑动窗口中已经接收并回复ACK，但是由于发送端没有正确接收到ACK而重发的数据包，因此 这个数据包可能是之前已经接收过的冗余数据包（[3, 4, 5, 0] =&gt; [recv_base - N, recv_base - 1]） 对于第一种情况，我们需要缓存该数据包并回复ACK，而对于第二种情况我们只需要回复ACK即可 为了避免上述情况，滑动窗口的大小应该小于或等于序列号空间大小的一半 Connection-Oriented Transport: TCP 点对点（Point-to-Point） 传输可靠、有序的字节流 =&gt; 对每个字节进行编号 流水线型（Pipelined） 发送端和接收端都有缓存（send &amp; receive buffers） 全双工通信（full-duplex service） 面向连接的（connection-oriented） 拥塞控制（congestion control） 流量控制（flow control） TCP接收和发送缓存 =&gt; 注意：在TCP连接的两端各自都有自己的发送和接收缓存（因为TCP是全双工的，所以两端的终端都有发送和接收数据的需求） MSS（Maximum Segment Size, 最大报文长度）MSS is the maximun amount of application-layer data MSS指的是Segment中应用层数据的最大长度，并不包括传输层头部 TCP Segment Structure 字段说明 Source port : 源端端口号（16 bits） Dest port : 目的端端口号（16 bits） Sequence number : 序列号（32 bits） Acknowledgment number : 确认号（32 bits） Header length : TCP Segment头部（传输层头部）的长度（4 bits）。单位是4个字节，一行 Unused : 目前未使用的字段域（6 bits） Flag filed : 标志域（6 bits） URG、PSH : 与urgent data pointer filed 并用，处理紧急数据包（实践中未用到） =&gt; Don’t care now ACK : 标识这个数据包是不是一个ACK RST、SYN、FIN : 这三个字段域用于创建TCP连接过程中 Receive window : 该字段用于流量控制，指示的是发送数据包一端，接收窗口的剩余可用大小 Internet checksum : 校验和，用于检测数据包是否出错 Urgent data pointer : 指向紧急数据尾的指针（实践中未用）=&gt; Don’t care Options : TCP Segment头部的可选字段，可以没有 Data : TCP Segment的数据域，包含了上层传递下来的message 补充说明 TCP首部的开销至少是20个字节，通常默认情况下Options字段域是为空的 Header length 的单位是4个字节（一行32bits） TCP的序列号和确认号 序列号和确认号是TCP提供可靠数据传输最重要的两个重要字段 TCP 把data看做有序的字节流。它按字节编号，给每一个字节分配一个序列号 =&gt; 一个Segment的序列号由其数据域第一个字节的序列号所代表 TCP同样也是使用累积确认的机制，但是和之前讲的有点不一样：The acknowledgment number that Host A puts in its segment is the sequence number of the next byte Host A is expecting from Host B （主机A在给主机B发送的ACK包的确认号是主机A期望从主机B获取到的下一个数据包的序列号） 例如：发送端如果收到确认号为536的ACK包，则表示序列号为536之前的所有数据包均已被成功接收，并且接收端期望下一个收到序列号为536的数据包 Reliable Data Transfer =&gt; (TCP)的可靠数据传输 TCP在IP不可靠服务的基础上实现了可靠数据传输 流水线型协议 =&gt; 带宽利用率高 采用累积确认 TCP采用单个重传计时器 重传的时机： 定时器超时 收到3次冗余ACK 快速重传 =&gt; 当收到3次冗余ACK时（实际上是收到了4个相同的ACK），就认为定时器超时，重传已发送未确认的编号最小的数据包 TCP中使用了哪些机制来实现可靠数据传输 引入序列号来解决冗余数据包的问题=&gt; 接收端收到序列号与之前收到的数据包序列号相同时，就丢弃该包 采用累积确认=&gt; 发送端如果收到确认号为536的ACK包，则表示序列号为536之前的所有数据包均已被成功接收，并且接收端期望下一个收到序列号为536的数据包 TCP采用单个重传计时器+快速重传+累积确认来解决丢包问题=&gt; 当发送端定时器超时或者收到相同数据包的3次冗余ACK时，便重传已发送未被确认的数据包中编号最小的数据包 Checksum =&gt; 用来检测数据包是否出现差错 TCP交互流程图中ACK和ack ACK =&gt; 表示的是TCP Segment中的ACK标志域，如果ACK=1则表示这是一个ACK包，如果ACK=0则表示这不是一个ACK包 ack =&gt; 表示的是TCP Segment中的确认号字段 Flow Control（流量控制） 调节发送端发包的速率，防止接收端缓存溢出 控制已发送未被确认的数据包的数量 ≤ Receive Window size （接收端剩余缓存空间的大小 =&gt; 接收端通过ACK返回给发送端） TCP Connection Management（TCP连接管理） TCP 三路握手 ① 客户端首先向服务端 发送一个SYN Segment，其中SYN = 1，并且 随机生成一个起始的序列号 client_initial = 5 赋给seq（将随机生成的序列号填入SYN Segment的序列号字段）=&gt; 没有应用层data，但是占用一个序列号 ② 服务端收到客户端发送的TCP SYN Segment后，服务端分配发送和接收buffer以及相关变量。同时发送一个SYNACK Segment 给客户端，SYN = 1，ACK=1（表示这是一个ACK包），ack = 6 （client_initial + 1）。同时 随机生成一个服务端的初始化序列号 server_initial = 17 赋值给seq （通知客户端我已经接收到你建立连接的请求，并且返回给客户端自己的初始化序列号）。 =&gt; SYNACK 包也没有应用层data，但也同样占用一个序列号 ③ 第三步客户端给服务端返回一个普通的ACK，普通ACK是 不占用序列号 的，但是 可以捎带数据（捎带数据指的是，客户端可以在建立连接的最后一个ACK中，放入一部分要发送的数据。则这个数据包即完成了作为ACK的职能，也携带了一部分数据。） TCP 四路挥手 不含data的正常ACK，序列号可以不写（因为不占用序列号）； 在非ACK数据包中的ack无含义，不用写。 TCP状态转换图 =&gt; 点我 Principles of Congestion control拥塞控制 调节发送端发包的速率，避免路由器缓存溢出 TCP Congestion Control（TCP拥塞控制） =&gt; TCP Tahoe（代表系统首次启动的情况）： 1~4时刻为慢启动阶段，cwnd以指数方式增长，其中 时刻4的时候达到了系统初始设置的慢启动阈值，系统进入拥塞避免状态，cwnd的增加开始放缓速度，以线性方式增加。到时刻 8的时候定时器超时，ssthesh = cwnd / 2， cwnd = 1 (MSS)。系统 进入慢启动阶段。到时刻12的时候达到了系统初始设置的慢启动阈值，系统进入拥塞避免状态。 =&gt; TCP Reno（代表系统运行时收到3次冗余ACK的情景）：时刻9系统收到3次冗余ACK，cwnd = cwnd / 2，系统 进入快速恢复阶段 慢启动（slow start）首次启动时，拥塞窗口（cwnd）的大小置为1 MSS（Maximum Segment Size），接着每收到一个ACK，cwnd 的值便翻一番，指数增长。当 定时器第一次超时时，cwnd的值置为1，同时将慢启动阈值 （ssthresh）的值设置为 cwnd/2。接下来 cwnd 仍然以指数方式增长，但是 当达到ssthesh时，进入拥塞避免状态（需要注意的是，初始的时候，ssthesh会设置有一个初始值，当如果第一次启动时在没有超时之前，cwnd达到了预设的ssthesh，也会进入拥塞避免状态）。 拥塞避免（Congestion Avoidance）当进入拥塞避免状态之后，cwnd 不再以指数方式增长，而是 以线性方式增长。 当定时器超时时，ssthesh = cwnd / 2， cwnd = 1 (MSS)。系统 进入慢启动阶段； 当收到3次冗余ACK时，cwnd = cwnd / 2，系统 进入快速恢复阶段 快速恢复（Fast Recovery）每收到一个冗余ACK，cwnd + 1 如果引发TCP进入快速恢复阶段的 缺失报文段在定时器超时之前到达，进入拥塞避免状态。 如果在此期间，定时器超时，则ssthesh = cwnd / 2, cwnd = 1 (MSS)，进入慢启动状态]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter 2 Applicaiton Layer]]></title>
    <url>%2F2018%2F05%2F06%2Fcomputer_networking_02%2F</url>
    <content type="text"><![CDATA[Principles of Network Applications 只有端系统中才有应用层和传输层 网络应用体系架构（Network Application Architectures） client-server （C / S） Peer-to-peer (P2P) Hybird of C/S and P2P (混合架构) ps: 与网络体系架构（5层架构、OSI/ISO七层架构…）做一下区分 C/S 特点 服务端要一直在线，且要 先于客户端启动 服务端通常 要有一个固定的，长期不变的唯一地址（IP Address） 客户端之间并不直接进行通信，所有的客户端都直接与服务端通信 易于管理 缺点 单点故障 接入客户端过多的时候，容易导致服务器过载（所以服务端通常采用分布式集群，且性能一般都比较强大） 维护、升级成本大 P2P 不需要一直在线的服务端 任意两个主机之间都可以直接通信 高可扩展性 （设备增加不会系统影响整体的性能），但是不易管理 Process Communication（进程通信） 同一主机的进程之间 通过 进程间通信（innerprocess communication） 进行通信，而不同主机的进程之间通过交换数据报（message）进行通信 =&gt; 发送进程将构造message并将其发送到网络当中，接收进程从网络中接收message，并解析它 Client and Server Processes （客户端和服务端进程）In the context of a communication session between on pair of processes, the process that initiates the communication (that is, initially contacts the other process at the begining of the session) is labeled as the client, The process that waits to be contacted to begin the session is the server 通常我们将 发起通信的一端标记为客户端 不只是C/S架构中有 服务端和客户端的概念，P2P架构中同样也有，不同的是在C/S架构中一个进程扮演的角色是固定的，而 P2P架构中同一个进程既可以是客户端，也可以是服务端，甚至可以同时扮演两个角色 The Interface Between the Process and the Computer Network (进程和网络之间的接口) =&gt; Socket Socket作为Process和Network之间的门户 ，发送和接收message都需要经过Socket。可以把Process比作一个工厂或仓库，而Socket就是工厂或长裤的大门 一个Socket只属于一个Process，而一个Process可以持有多个Socket 我们用 IP+Port 标识一个进程 Transport Services Available to Applications （传输层给应用层所提供的服务） 同时也可以说是理想情况下，应用层需要传输层给它提供哪些服务 Reliable Data Transfer (数据的可靠传输)传输层需要向应用层提供进程到进程的可靠通信 Throughput （最小带宽的保障）有些网络应用（比如网络电话）是对带宽比较敏感的，被称为 带宽敏感型应用（bandwidth-sensitive-applications）。这些应用对吞吐量有一定要求，要求吞吐量至少高于某个速率才能正常工作这样子。所以传输层就需要能为应用层提供保证吞吐量的服务 Timing （延迟保障） Security （安全保障） Transport Services Providede by the Internet 互联网所提供的传输层服务 TCP Services 提供数据的可靠传输，不提供最小带宽，最短时延的保障，不提供安全保障 connect-oriented (面向连接) reliable transport (可靠传输) flow control (流量控制) congestion control (拥塞控制) UDP services 不提供可靠数据传输，不提供最小带宽，最短时延的保障，不提供安全保障 一些经典应用程序所采用的应用层协议和传输层协议 TCP: Telnet, FTP, SMTP, HTTP UDP: SNMP, DNS, RTP, RIP The Web and HTTP HTTP HTTP——HypreText Transfer Protol（超文本传输协议） HTTP是应用层协议（Application protocol） HTTP采用的是C/S架构 基于TCP HTTP是无状态的(stateless) =&gt; 不保存用户端的状态信息，所以HTTP协议也被称为无状态协议（stateless protocol） Non-Persistent and Persistent Connections RTT (Round-trip time, 往返时间)定义：一个很小的数据包（小到可以近乎忽略数据包的长度）从客户端到服务端往返一次所需要的时间 一次HTTP请求的响应时间 total = 2*RTT + transimit time 总的响应时间 = 2倍的RTT + 收到整个返回的对象所需要的时间（文件长度/带宽） Non-Persistent HTTP （非坚持的HTTP）每建立一个TCP连接，只能传一个对象（object =&gt; HTML file, JPEG…） 由于接收每个对象都要单独建立连接，所以 接收每个对象所需要的响应时间都包含至少两个RTT 服务器负担重：传送每个对象都需要服务器维护一个新的连接，而连接的建立和维护是有一定开销的 Persistent HTTP （坚持的HTTP）一个连接建立可以传第一个Object 这个接收第一个对象的时候需要至少两个RTT，紧接着后面的每个对象都少了建立连接的RTT了。 HTTP Message Format HTTP Request Message (HTTP请求消息格式) method field (方法域)：GET, POST, HEAD, PUT, DELETE … URL: 请求位置 Version：HTTP协议的版本号 Header lines: 包含了请求头信息，请求头中包含一系列的键值对 Entity body: 数据域，当使用GET请求的时候，这个域是为空的，当使用POST请求的时候，这个域包含了请求所携带的数据 HTTP Request message都是用ASCII text表示的 需要注意的是，请求中携带数据，不一定要使用POST方法， GET方法也同样可以携带数据。虽然GET请求的Entity body域是空的，但是GET方法可以在URL后面包含数据。 一个HTTP请求的简单例子12345GET /somedir/page.html HTTP/1.1Host: www.someschool.eduConnection: closeUser-agent: Mozilla/4.0Accept-language: fr 其中第一行分别是请求方法，URL和HTTP版本 后面四行是请求头 Host: 服务器主机的域名 Connection: close =&gt; 要求服务器在发送完所请求的数据之后，不保持连接 User-agent =&gt; 通常用来标识浏览器内核版本，服务端可以通过这个请求头对不同的浏览器返回不同的文件，这样就可以实现同一个URL针对不同的浏览器返回不同数据的功能 Accept-language =&gt; 告诉服务器前端所期望服务器返回数据的语言 HTTP Response Message （HTTP返回消息格式） status line version: HTTP协议的版本号 status code: 本次请求的状态码 parase: 对状态码的简单描述 Header lines: 包含了返回头信息，返回头中包含一系列的键值对 Entity body: 数据域，如果有的话包含了服务器返回的数据 HTTP Response Status Code (HTTP 返回消息状态码) 状态码列表 200 OK: 本次请求成功，并且所请求的object对象已经在Response消息中返回 301 Moved Permanently: 所请求的Object已经被移到另一个位置，在Response Message的Location 头中包含了Object的新位置，正常情况下浏览器会自动访问新地址 400 Bad Request: 服务器无法理解客户端的请求 404 Not Found: 所请求的object在服务器上不存在 505 HTTP Version Not Supported: 请求的HTTP协议版本不被服务端支持 一个HTTP回复消息的简单例子123456789HTTP/1.1 200 OKConnection: closeDate: Sat, 07 Jul 2007 12:00:15 GMTServer: Apache/1.3.0 (Unix)Last-Modified: Sun, 6 May 2007 09:23:24 GMTContent-Length: 6821Content-Type: text/html(data data data data data ....) 上面的消息中包含：an initial status line，six header lines，the entity body 第一行表示服务端HTTP协议版本号为1.1，客户端本次请求的状态码为200，状态码的描述为OK（表示客户端请求的服务器存在，并且服务器上存在客户端所请求的文件） Connection: close =&gt; 告知客户端，服务器发送完这个Object对象之后就会关闭连接 Date =&gt; 表示服务器创建这个message的时间 Server =&gt; 包含了服务器的一些信息，与User-Agent类似 Last-Modified =&gt; 表示这个Object的最后修改时间，这个在浏览器进行缓存处理的时候极为有用 Content-Length =&gt; 返回Object的数据长度 Content-Type =&gt; 返回Object的类型 User-Server Interaction: Cookies (用户服务器交互：Cookies) Cookies 技术四大组件 A cookie header line in the HTTP response message (HTTP返回消息中的一个cookie头行：例如 Set-cookie: 1678) A cookie header line in the HTTP request message（HTTP请求消息中的一个cookie头行：例如 Cookie: 1678） A cookie file kept on the use’s end system and managed by use’s browser (一个cookie文件，持久化在客户终端，并且由客户端浏览器统一管理) A back-end database at the Web site (网站上的后端数据库 =&gt; 服务器上记录用户的状态信息，通过请求中的cookie，从数据库中取出对应的信息). 交互示例 用户一开始向服务器发送一个正常的HTTP请求 服务器在返回的消息中，通过 Set-cookie 头示意客户端浏览器保存一个Cookie。客户端浏览器如果打开了Cookie支持，就会将收到的Cookie存起来，持久化到Cookie文件里面 之后对同一网站的请求，浏览器都会在每个请求消息中自动加入 Cookie 头，并将之前持久化保存起来的Cookie信息取出，填上去 服务器收到带Cookie头的请求就会去数据库查询相关信息， 使用Cookie技术，可以 在无状态的HTTP上层创建了一个可以保持用户状态的用户会话层 Web Caching（Web缓存） Web Caching（Web缓存）也称之为 proxy server（代理服务器）。是一个可以代替源端Web服务器响应客户端请求的这么一个网络实体 WEB缓存在同一时刻既作为Client（客户端），也作为Server（服务端） Web Caching 的工作流程 首先，客户端浏览器建立一个到Web缓存的TCP连接，并将请求发送给Web缓存 Web缓存收到客户端的请求之后，检查本地是否有客户端要请求的object的本地缓存，如果有就将其放入HTTP Response Message中返回给客户端，否则转第三步 如果Web Caching中没有客户需要的Object，Web缓存就根据客户端请求中的目标地址，向源Web服务器发起一个请求，获取到客户需要的Object 接着Web缓存将从源服务器中收到的Object缓存到本地，并奖客户端需要的Object放入HTTP Response Message返回给客户端 采用Web缓存的好处 WEB缓存可以大大地减少客户端请求的响应时间，特别是当客户端与源服务器的瓶颈带宽远小于客户端与WEB缓存之间的瓶颈带宽的时候。=&gt; 缩短响应时间，提高响应速度 Web缓存能够大大减少一个机构的接入 链路到闲特网的通信量。通过减少通信量，该机构(如一家公司或者一所大学)就不必急 于增加带宽，因此降低了费用。此外，Web缓器能从整体上大大减低因特网上的 Web 流量，从而改善了所有应用的性能。 =&gt; 减少源服务器的负载，降低机构的出口带宽费用，改善整个因特网的性能 可以提供另一条路径去访问远程服务器（VPN）。客户端访问不到源服务器但是可以访问Web缓存，而Web缓存可以访问到源服务器，那客户端就可以通过WEB缓存的代理，间接访问源服务器 采用Web缓存可能存在的缺陷 信息的滞后性，客户端获取到的可能不是源端最新的版本 解决办法：通过 Conditional GET(有条件的GET)，当Web缓存收到客户端的请求的时候，就向源服务器发送一个有条件的GET，询问客户端请求的Object与Web缓存本地的缓存的对象相比是否有更新。如果有更新，就从源服务器下载Object，更新本地的缓存，并将最新的Object返回给客户端；如果没有更新，Web缓存就直接将本地缓存的Object返回给客户端。 Conditional GET (有条件的GET) 什么是有条件的GET The Request message use the GET method （用GET方法请求） The Request message includes an If-Modified-Since: header line （请求的时候带上If-Modified-Since头） 实例 一开始Web缓存本地没有缓存，收到一个客户端的请求之后就转而去请求源服务器 12GET /fruit/kiwi.gif HTTP/1.1Host: www.exotiquecuisine.com 接着源服务器会返回类似如下的返回消息 1234567HTTP/1.1 200 OKDate: Sat, 7 Jul 2007 15:39:29Server: Apache/1.3.0 (Unix)Last-Modified: Wed, 4 Jul 2007 09:23:24Content-Type: image/gif(data data data data ...) Web缓存收到源服务器返回的消息之后，就会将Object缓存下来，同时也 会把对应的Last-Modified头信息（Object最后修改时间）保存下来。一段时间后，比如过了一周，又有一个客户端向Web缓存请求这个Object，由于过了一段时间了，这个Object可能被修改/更新过了，所以 Web缓存需要向源服务器发送一个Conditional GET， 以确定是否要从源服务器更新本地的缓存。Conditional GET请求如下： 123GET /fruit/kiwi.gif HTTP/1.1Host: www.exotiquecuisine.comIf-Modified-Since: Wed, 4 Jul 2007 09:23:24 源服务器收到一个Conditional GET之后，会检查目标Object的最后修改时间和GET请求中 If-Modified-Since:字段的时间孰大孰小，如果时间一致，表示不用更新，会返回如下信息（如果时间不一致，则正常返回要请求的Object）： 12345HTTP/1.1 304 Not ModifiedDate: Sat, 14 Jul 2007 15:39:29Server: Apache/1.3.0 (Unix)(empty entity body) Web缓存的 Conditional GET请求 如果收到 源服务器返回的304状态码，就认为本地缓存的Object是最新的，直接将其放入HTTP Response Message 当中返回给客户端 File Transfer: FTP （文件传输协议） 特点 基于TCP 采用C/S架构 是应用层协议 控制流和信息流分离，控制信息的传输采用带外传输（out-of-bound）的方式 两种连接 FTP协议在 21端口上传递控制信息，在 22端口上传递数据（文件） 初始时客户端通过向服务器的21号端口建立一条TCP连接（control connection），并且向服务端发送identifycation，username，password等信息。接着服务端向客户端建立一条TCP连接用于传输数据（data connection）。即便在同一个Session，每传递一个新的文件都需要新开一个data connection 控制连接（control connection）始终处于连接的状态，并且是维持用户状态的（state），数据连接 在每传输完一个文件之后就关闭，同时传输多个文件会开启多个数据连接（Non-Persistent Connection） Electronic Mail in the Internet (因特网中的电子邮件) SMTP（简单邮件传输协议）=&gt; TCP POP3 IMAP 对比SMTP和HTTP 同： 两种协议都是用于从一个主机向另一个主机传输文件 持久HTTP和SMTP都采用持久连接 都是应用层协议 都基于TCP 异： HTTP 是一种 拉式协议（pull protocol），它由想接受文件的一端发起连接；而 SMTP 是一种 推式协议（push protocol），它由想发送文件的一端发起连接 SMTP 的message需要使用 7-bits ASCII 格式，对于不是7-bits ASCII格式的文字或者包含比特流，都需编码为 7-bits ASCII 格式之后传送。而相比之下，HTTP就没有这种限制 对于包含文本和图形的文档 HTTP是把每个Object放到一个Response message中发送 而SMTP是把所有的Object放在一个报文中发送 SMTP是一种推式协议，所以不能用来从邮件服务器上获取邮件，而应该采用其它协议来获取邮件 收发邮件所用的协议 发邮件 SMTP (Simple Mail Transfer Protocol) 收邮件 POP3 (Post Office Protocol——Version 3) =&gt; 邮局协议，端口110 “download and delete” mode “download and keep” mode IMAP (Internet Mail Access Protocol) =&gt; 互联网邮件访问协议 HTTP (HyperText Transfer Protocol) =&gt; 超文本传输协议 DNS Domain Name System, 域名系统 DNS 协议基于UDP，PORT 53 DNS Servers 组成 A distributed databse implemented in a hierarchy of DNS Servers (一个由分层的DNS服务器实现的分布式数据库) An application-layer protocol that allows hosts to query the distributed database (一个使得主机能够查询这个分布式数据库的应用层协议) Services Provided by DNS (DNS所提供的服务) 实现域名（hostname）和IP地址的转换 =&gt; 最主要的功能 支持给主机设置别名（Host aliasing）=&gt; 可以给复杂难记的域名指定一个简单易记的别名，别名指向的原域名我们称之为 规范主机名(canonical hostname)。我们可以用这个别名通过DNS服务器查到其规范主机名，进而查到对应的IP 支持给邮件服务器设置别名 (Mail Server aliasing) 支持负载均衡 (Load distribution) =&gt; 对同一个域名的访问/请求，可以由多个服务器分担 DNS服务为什么不采用集中式设计（centralized design） 单点故障 （A Single point of failure） 通信容量限制（Traffic volume）=&gt; 单个服务器无法处理上亿个甚至更多的请求 远距离的集中式数据库（Distant centralized databse）=&gt; 单个DNS服务器无法临近所有主机，距离越远，所产生的时延也就越大 维护困难（Maintenance）=&gt; 单个DNS服务器将为互联网的所有主机保存数据，将会导致中央数据库非常的庞大，难于维护。 DNS Server 是一个分布式、分层的数据库 Root DNS Servers =&gt; 根域名服务器（全球只有13个，大部分在北美） Top-level domain (TLD) =&gt; 顶级域名服务器 Authoritative DNS Servers =&gt; 权威域名服务器 Local DNS Server =&gt; 本地域名服务器（通常每个ISP会有一个本地的域名服务器） 两种查询方式 交互式查询（Interactive Queries） 递归式查询（Recursive Queries） DNS Caching (DNS缓存)DNS服务器会对查询过的域名对应有缓存，并且该缓存会有一个存活时间，被访问的越频繁越不容易失效 DNS Caching 可以减少客户端查询DNS服务器所导致的延迟 DNS Caching 可以降低高级域名服务器的负载 DNS Records一个DNS记录是如下的四元组 12// 域名，值，类型，存活时间（Time-to-live）(Name, Value, Type, TTL) 记录的类型 A记录：Name -&gt; hostname, Value -&gt; IP 例：(relay1.bar.foo.com, 145.37.93.126, A) NS记录：Name -&gt; ，则 Name 是个域 (如foo. com) ，而 Value 是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名 例：(foo.com, dns.foo.com, NS) CNAME记录：则 Value 是别名为 Name 的主机对应的规范主机名 例：（foo.com, relat1.var.foo.com, CNAME） MX记录：，则 Value 是个别名为 Name 的邮件服务器的规范主机名 例：（foo.com, mail.bar.foo.com, MX） Peer-to-peer Applicaions（P2P应用程序） 共享资源 节点间课直接通信 非集中式 C/S 架构中存在的问题 难于扩展（由于服务端负载有限额，当客户端达到一定额度之后，就很难在扩展了） 单点故障 需要超级节点作为管理者（服务器的性能要足够好） 网络边缘的资源未得到充分的利用 P2P 的特点 资源利用率高 可扩展性好 可靠性/健壮性好（无单点故障，文件有多份拷贝） 不需要超级节点管理，节点自管理 隐私不可控（BT） 动态性更强 搭便车问题 Robustness（健壮性）系统受到干扰之后迅速恢复回原来状态的能力。 Flooding（洪泛）每次受到邻居节点消息之后都无条件的转发给其它邻居，导致洪泛发生。]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter 1 Computer Network and the Internet]]></title>
    <url>%2F2018%2F05%2F05%2Fcomputer_networking_01%2F</url>
    <content type="text"><![CDATA[What is the Internet? There are couple of ways to answer this question. First, we can describe the nuts and bolts of the Internet, that is, the basic hardware and software components that make up the Internet. Second, we can describe the Internet in terms of a networking infrastructure that provides services to distributed applications 对于什么是因特网，可以从两方面来描述。首先，我们可以描述它的基本原理，即 构成Internet的基本硬件和软件组件 。其次，我们可以将其描述为 一个网络基础设施，它为分布式应用程序提供服务 A Nuts-and-Bolts description 数以百万计的计算机设备——主机/终端（host/end systems） 通过 通信链路（communication links） 和 分组交换机（packet switches） 相互连接在一起。 主机/终端（host/end systems）广义所指，除了传统的PC、Linux工作站等还包括手机、TV等一众可以连接到互联网的设备 通信链路（communication links）通信链路有多种类型，它们基于不同的物理介质，如：同轴电缆（coaxial cable），铜线（copper wire），光纤（fiber optics）等，采用不同的材质，会影响链路的 传输速率（transmission rate） 传输速率（transmission rate） transmission rate = bandwidth（传输速率=带宽）==&gt; 发送端发包的速率 ps: 吞吐量 ==&gt; 接收端收包的速率 分组交换机（packet switches）A packet switch takes a packet arriving on one of its incoming communication links and forwards the packet on one of its outgoing communication links. (分组交换机的功能就是接收一个链路上发来的数据包，并将其转发给它的另一个出口链路上)目前Internet上的分组交换机主要有两种：路由器（routers） 和 链路层交换机（link-layer switches） 路由器（routers） ==&gt; 常在网络核心（network core）中使用 链路层交换机（link-layer switches） ==&gt; 常在接入网（access network）中使用 路由（route / path）The sequence of communication links and packet switches traversed by a oacket from the sending end system and to the receiving end system is know as route or path (数据包从发送端到接收端所途经的通信链路和分组交换机组成所谓的路由) ==&gt; 一个路由其实就是网络上的一条路径，某些数据包通过这条路径从发送端传输到接收端 互联网服务提供商（Internet Serveice Providers，ISPs）互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信运营商 A Sercices description The Internet is an infrastructure for providing services to distributed applications ==&gt; Internet一个为分布式应用提供服务的网络基础设置 对于一个分布式的网络应用程序，程序之间要进行通信就需要一个传输媒介，而Internet就很好的扮演了这个角色。 What is Protocol?A protocol defines the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event. 一个协议定义了两个通信实体之间交换信息的格式和顺序，以及在消息和其它事件的发送或接收时所采取的响应动作 The topology structure (拓扑结构) 集中式单点故障；结构，管理简单；中心节点价格昂贵，维护困难； Star =&gt; 星型 Tree =&gt; 树型 分布式 Bus =&gt; 总线型 Mesh =&gt; 网状网 （适用于无线通信） Ring =&gt; 环形 Network structure(网络结构) Network edge （网络边缘） Access network （接入网） Physical media （物理介质） Network core （网络核心） The Network Edge (网络边缘) end systems （终端） access network （接入网） links （链接） Client and Server Programs (C / S) C/S A client program is a program running on one end system that requests and receives a service from a server program running on another end system. 客户端程序运行在一个终端上，并且向运行在另一个终端上的服务端程序请求并获取服务。 P2P 同一个终端既可以作为客户端请求服务，也可以作为服务端程序提供服务 Access network （接入网）=&gt; 主机（终端）与边缘路由器相连的那段网络（Physical link）称之为接入网 =&gt; 接入网很大程度上决定了用户的所能真正享有的带宽 Physical Media （物理媒介） 传输的是Bits（一系列的比特流）； guided media =&gt; 导向型（有线） unduided media =&gt; 无导向型（无线） Twisted Pair(TP) =&gt; 双绞线 Coaxial Cable =&gt; 同轴电缆 Fiber Optics =&gt; 光纤（ low bit error rate (比特差错率低) ） Terrestrial Radio Channels =&gt; 地面无线信道 Satellite Radio Channels =&gt; 卫星无线信道 The Network Core (网络核心)=&gt; 分组交换机以及连接分组交换机间的链路 电路交换网络和分组交换网络可以类比为饭馆订餐：电路交换网络就好比一个饭店，需要提前预定座位，并且饭店会在你预定之后再规定时间内一直为你保留预定的座位，你在既定时段的任何一个时间点去都是有位置的，期间有未预定的顾客进入，即便饭店有空位，也无法入座；而分组交换网络则好比不需要预定的饭店，先到先得，如果饭店满座了就需要等待。 Circuit Switching (电路交换网络) 典型的就是电话网络 Dedicated allocation =&gt; 固定分配，独占独享 Resource reservation =&gt; 资源预留（不共享，不允许别的连接使用） Multiplexing =&gt; 多路复用(将网络资源切片) frequency-division multiplexing =&gt; 频分多路复用 (FDM) time-division multiplexing =&gt; 时分多路复用 (TDM) 需要呼叫建立 时延小，无资源竞争 由于电路交换网络给每个Connection分配固定的带宽，分配的连接越多，意味着每个Conncetion所能享有的带宽就越少 Packet Switching (分组交换网络) 典型的，Internet网络采用的就是分组交换网络 Share network resources =&gt; 各个分组 共享网络资源 each packet uses full link bandwidth =&gt; 每个分组均能使用全部的链路带宽 resources used as needed =&gt; 资源按需分配 resource contention =&gt; 存在资源竞争 =&gt; 可能会导致丢包，拥塞，延时等一系列问题 Statistical Multiplexing =&gt; 统计复用 （异步时分多路复用） 传统的 TDM（时分多路复用）是给每一个终端分配一个 time-slot（时隙），对于某个具体的终端，不管这个终端有没有在进行通信，分配给它的那部分带宽都将被占用，是同步的 而 统计复用（异步时分多路复用）是把公共信道的时隙实行“ 按需分配 ”，即只对那些需要传送信息或正在工作的终端分配time-slot，这样就能使所有的时隙都能被充分的利用，可以使服务的终端数大于一个周期内时隙划分的个数，提高了媒质的利用率，从而起到了复用的作用。 Store-and-forward （存储转发） =&gt; 以太网交换机的控制器先将输入端口到来的数据包缓存起来，先检查数据包是否正确，并过滤掉冲突包错误 （增加了网络的时延，但是使得网络有了一定的检错功能） 与电路交换相比 Packet switching allows more users to use network( 分组交换允许更多的用户使用网路 ) Great forbursty data ( 处理突发数据极为有效 ) 两种网络的应用场景 在 带宽需求相对固定 的情况下， 电路交换网络 比较合适 资源需求稳定 固定电话的通信就是，语音要求的带宽非常固定，而且采用电路交换网络也可以保证通话的质量 在 带宽需求动态变化 时，分组交换网络 比较适用 典型的Internet网络的带宽需求就是动态变化的 Delay, loss and throughputin Packet-Switched Neworks在分组交换网络中的延迟，丢包和吞吐量 Delay（延迟） Nodal procesing delay =&gt; 节点处理延迟（一般是很短的） 差错检测 （check bit error） 决定从哪个口转发出去 (determine output link) Queueing delay =&gt; 排队延迟（可以为0，也可以很长，取决于当前网络的状态） Transimission delay =&gt; 传输延迟（可以很小，也可以很长，取决于数据包的长度以及网络的带宽） =&gt; 所以 提高网络带宽只能降低传输延迟 Propagation delay =&gt; 传播延迟 （延迟的大小由物理介质的长度决定，因为传播的速度很快，所以一般这个延迟也不会很大） 其中传播的具体速度的大小取决于是用那种物理介质传输的（光纤，双绞线等等） 取值范围：2*108 m/s ~ 3*108 m/s (最快接近光速) 与数据包的长度无关 !!! dnodal = dproc + dqueue + dtrans + dprop(数据包在一个节点上的时延 = 节点处理延迟 + 排队延迟 + 传输延迟 + 传播延迟) Loss（丢包）当分组交换机（链路层交换机和路由器）有限缓存溢出的时候就会发生丢包 可能会由前一个节点或源端节点重传，或者压根不重传 在端系统的视角看来，就是一个数据包已经被发送到网络核心，当时却没有到达目的节点 Throughput（吞吐量） 百度百科： 吞吐量是指对网络、设备、端口、虚电路或其他设施，单位时间内成功地传送数据的数量（以比特、字节、分组等测量） instantaneous throughput (瞬时吞吐量) average throughput (平均吞吐量) 在Internet网络中端到端的吞吐量 通常和 接收端收包的速率 是一致的 在Internet网络中的端到端吞吐量取决于网络中的瓶颈链路（Bottleneck link） 补充 所有网络信号在物理介质上的速度近似为光速，可以认为是一样的 =&gt; 即 网络信号在传输时并无快慢之分 之所以在 不同的链路上有带宽差别，是因为由于协议，技术等原因导致 两个相邻的数据包之间存在不同大小的时隙 网络中一条链路上数据的传输永远是串行的（并不会出现类似“多车道”的情况） Quality of service, Qos =&gt; 服务质量 Protocol Layers and Their Service Models（协议分层以及他们的服务模型）计算机网路的体系结构（architecture）是计算机网络各层及其协议的集合 PDU (Protocol Data Unit, 网络协议数据单元)同一层的所有协议所处理的数据单元 Five-layer Internet protocol stack (五层网络协议栈、TCP/IP协议栈) 各层提供的功能 Applicaiton（应用层）: 仅为用户提供接口 Transport（传输层）：实现进程到进程间的通信 Network（网络层）：实现主机到主机之间的通信 Link（数据链路层）：实现相邻节点间的数据传输 Physical（物理层）：在物理介质上传输比特流 各层的PDU Applicaiton（应用层）: message（报文 / 消息） Transport（传输层）：segment（报文段） Network（网络层）：datagram（数据报） Link（数据链路层）：frame（数据帧） Physical（物理层）：bit（比特） 协议 是对等实体之间的， 服务 则是由下层通过向上层提供接口提供的 Seven-layer ISO/OSI reference model]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中实现关系代数中的除运算浅析]]></title>
    <url>%2F2018%2F05%2F04%2F2018-5-4-database-double-not-exists%2F</url>
    <content type="text"><![CDATA[准备工作 先给出构造测试表的初始化代码，有兴趣的小伙伴可以跑一跑试试 12345678910111213141516171819202122232425262728293031323334353637383940drop table R;drop table S;create table R ( X integer, Y varchar(5));create table S ( Y varchar(5), Z integer);insert into R (X, Y) values ( 1, 'A');insert into R (X, Y) values ( 2, 'B');insert into R (X, Y) values ( 3, 'C');insert into R (X, Y) values ( 1, 'B');insert into R (X, Y) values ( 1, 'C');insert into R (X, Y) values ( 2, 'A');insert into S (Y, Z) values ( 'A', 3);insert into S (Y, Z) values ( 'B', 3);insert into S (Y, Z) values ( 'C', 3); 现在整体的表结构如下 R S 解释 其中X,Y,Z都可以代表一个或多个字段 Y为两张表中的相同字段 关系代数除运算（division）扫盲 R÷S 对于某个R关系中的X的某个具体值x映射到Y的集合，如果它包含关系S中Y的集合，那么这个x就会出现在结果集当中 像上面构造的两张表R和S，R÷S的结果就是’A’了 OK，所以说了和没说差不多，我还是不懂什么是关系代数中的除运算(:з」∠)…那下面就来举一个形象一点的栗子ლ(╹◡╹ლ) 这是栗子 R表示学生的选课信息，其中X表示学号，Y表示课程号 S表示课程的信息，其中Y表示课程号，Z表示学分 好现在，上面的两种表就变成下面这样了 R S ok，现在我们要找出一部分学生的学号，他们选了所有的课 R÷S ==&gt; 选了所有课的学生（很显然，上面只有学号为1的学生选了所有的课） 结果如下： SQL实现网上常见的方式就是用双重not exists来实现，咋一看不是很好理解，笔者这里对其进行稍详尽点的分步分析 最终代码1234567891011SELECT DISTINCT R1.XFROM R R1WHERE NOT EXISTS( SELECT * FROM S WHERE NOT EXISTS( SELECT * FROM R R2 WHERE R2.X = R1.X AND R2.Y = S.Y )); 分析 我们先来对里面一层的not exists进行分析 执行下面代码： 123456789101112131415SELECT *FROM SWHERE NOT EXISTS( SELECT * FROM R R2 WHERE R2.X = 1 AND R2.Y = S.Y);SELECT *FROM SWHERE NOT EXISTS( SELECT * FROM R R2 WHERE R2.X = 2 AND R2.Y = S.Y); 第一个执行结果为空，第二个执行结果如下 分析一下可以知道，上面的SQL完成的任务是“对于某个学号的学生，求得该学生未选的课程列表” OK，我们加上外层的not exists 1234567891011SELECT DISTINCT R1.XFROM R R1WHERE NOT EXISTS( SELECT * FROM S WHERE NOT EXISTS( SELECT * FROM R R2 WHERE R2.X = R1.X AND R2.Y = S.Y )); 从上面的分析我们知道，内层的SQL求的是对于一个具体的学生，其未选课程的列表 那么外层加上一个not exists，整个SQL的含义就是求没有未选课程的学生，换句话说，就是求选了所有课的学生 当然，第一行的DISTINCT也是很有必要的，去除了重复的X，你可以试试，不加，看一下结果，会发现每一个结果都会出现S表中Y集合的大小那么多次。]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin use函数的魔法]]></title>
    <url>%2F2018%2F03%2F30%2Fkotlin_01%2F</url>
    <content type="text"><![CDATA[魔法预览 实现了Closeable接口的对象可调用use函数 use函数会自动关闭调用者（无论中间是否出现异常） Kotlin的File对象和IO流操作变得行云流水 use函数的原型 123456789101112131415161718192021222324252627282930/** * Executes the given [block] function on this resource and then closes it down correctly whether an exception * is thrown or not. * * @param block a function to process this [Closeable] resource. * @return the result of [block] function invoked on this resource. */@InlineOnly@RequireKotlin("1.2", versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = "Requires newer compiler version to be inlined correctly.")public inline fun &lt;T : Closeable?, R&gt; T.use(block: (T) -&gt; R): R &#123; var exception: Throwable? = null try &#123; return block(this) &#125; catch (e: Throwable) &#123; exception = e throw e &#125; finally &#123; when &#123; apiVersionIsAtLeast(1, 1, 0) -&gt; this.closeFinally(exception) this == null -&gt; &#123;&#125; exception == null -&gt; close() else -&gt; try &#123; close() &#125; catch (closeException: Throwable) &#123; // cause.addSuppressed(closeException) // ignored here &#125; &#125; &#125;&#125; 可以看出，use函数内部实现也是通过try-catch-finally块捕捉的方式，所以不用担心会有异常抛出导致程序退出 close操作在finally里面执行，所以无论是正常结束还是出现异常，都能正确关闭调用者 来一波对比 实现读取一个文件内每一行的功能 java实现 12345678910111213141516171819202122232425FileInputStream fis = null;DataInputStream dis = null;try &#123; fis = new FileInputStream("/home/test.txt"); dis = new DataInputStream(new BufferedInputStream(fis)); String lines = ""; while((lines = dis.readLine()) != null)&#123; System.out.println(lines); &#125;&#125; catch (IOException e)&#123; e.printStackTrace();&#125; finally &#123; try &#123; if(dis != null) dis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(fis != null) fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; Kotlin实现 12File("/home/test.txt").readLines() .forEach &#123; println(it) &#125; 对Kotlin就是可以两行实现。 仔细翻阅readLines这个扩展函数的实现你会发现，它也是间接调用了use，这样就省去了捕捉异常和关闭的烦恼 同样的，经过包装以后你只需要关注读出来的数据本身而不需要care各种异常情况 File的一些其它有用的扩展函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*** 将文件里的所有数据以字节数组的形式读出* Tip：显然这不适用于大文件，文件过大，会导致创建一个超大数组*/public fun File.readBytes(): ByteArray/*** 与上一个函数类似，不过这个是写（如果文件存在，则覆盖）*/public fun File.writeBytes(array: ByteArray)： Unit/*** 将array数组中的数据添加到文件里（如果文件存在则在文件尾部添加）*/public fun File.appendBytes(array: ByteArray): Unit/*** 将文件以指定buffer大小，分块读出（适用于大文件，也是最常用的方法）*/public fun File.forEachBlock(action: (buffer: ByteArray, bytesRead: Int) -&gt; Unit): Unit/** * Gets the entire content of this file as a String using UTF-8 or specified [charset]. * * This method is not recommended on huge files. It has an internal limitation of 2 GB file size. * * @param charset character set to use. * @return the entire content of this file as a String. */public fun File.readText(charset: Charset = Charsets.UTF_8): String/** * Sets the content of this file as [text] encoded using UTF-8 or specified [charset]. * If this file exists, it becomes overwritten. * * @param text text to write into file. * @param charset character set to use. */public fun File.writeText(text: String, charset: Charset = Charsets.UTF_8): Unit/** * Appends [text] to the content of this file using UTF-8 or the specified [charset]. * * @param text text to append to file. * @param charset character set to use. */public fun File.appendText(text: String, charset: Charset = Charsets.UTF_8): Unit/** * Reads this file line by line using the specified [charset] and calls [action] for each line. * Default charset is UTF-8. * * You may use this function on huge files. * * @param charset character set to use. * @param action function to process file lines. */public fun File.forEachLine(charset: Charset = Charsets.UTF_8, action: (line: String) -&gt; Unit): Unit/** * Reads the file content as a list of lines. * * Do not use this function for huge files. * * @param charset character set to use. By default uses UTF-8 charset. * @return list of file lines. */public fun File.readLines(charset: Charset = Charsets.UTF_8): List&lt;String&gt;/** * Calls the [block] callback giving it a sequence of all the lines in this file and closes the reader once * the processing is complete. * @param charset character set to use. By default uses UTF-8 charset. * @return the value returned by [block]. */@RequireKotlin("1.2", versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = "Requires newer compiler version to be inlined correctly.")public inline fun &lt;T&gt; File.useLines(charset: Charset = Charsets.UTF_8, block: (Sequence&lt;String&gt;) -&gt; T): T 上面的函数都是基于use实现的，可以放心使用，而不用担心异常的发生，并且会自动关闭IO流]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android WI-FI Direct Kotlin 浅析（一）]]></title>
    <url>%2F2018%2F03%2F26%2Fandroid_wifi_direct_01%2F</url>
    <content type="text"><![CDATA[简介 百度百科：2010年10月，Wi-Fi Alliance（wi-fi联盟）发布Wi-Fi Direct白皮书，白皮书中介绍了有关于这种技术的基本信息、这种技术的特点和这种技术的功能，Wi-Fi Direct标准是指允许无线网络中的设备无需通过无线路由器即可相互连接。与蓝牙技术类似，这种标准允许无线设备以点对点形式互连，而且在传输速度与传输距离方面则比蓝牙有大幅提升 与Android开发者而言呢，Google嗅到了WI-FI直连的发展前景，整了一套WI-FI直连的API，在Android4.0+（API &gt;= 14）的设备上均能使用。这给我们进行手机之间的互联操作提供了一个新的实现思路。它可以不需要路由而让两个设备直接相连，但其传输速度可是远远超过蓝牙传输。而且它不需要热点的建立，甚至两个设备不需要在一个局域网下。想象一下，不用建立热点也可以实现像快牙，茄子一类的面对面快传的需求～》《～ 基本使用 定义一个广播接收器 每当当前设备与Wi-fi直连相关的状态发生改变，系统便会以广播的形式通知我们，所以让我们定义一个Receiver欢迎它 在下面定义的Receiver里面我们监听了4个Action，这是最常用的4个，还有其它的Action可以看官方文档，或者，来去撸一波源码 12345678910111213141516171819202122232425262728293031323334353637383940414243class WifiDirectReceiver : BroadcastReceiver() &#123; /** * 写一个便捷的注册方法，动态注册的时候就不用写intentFilter了 */ fun registerReceiver(context: Context) &#123; val intentFilter = IntentFilter() intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION) intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION) intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION) intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION) context.registerReceiver(this, intentFilter) &#125; override fun onReceive(context: Context?, intent: Intent?) &#123; when (intent?.action) &#123; /** *当Wifi功能打开或关闭的时候系统会发送 WIFI_P2P_STATE_CHANGED_ACTION 广播 * Tip: 并不是指是否已经成功连上WI-FI */ WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION -&gt; &#123; &#125; /** * 当前设备的详细信息发生变化的时候，系统会发送 WIFI_P2P_THIS_DEVICE_CHANGED_ACTION 广播 */ WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION -&gt; &#123; &#125; /** * 当可连接的对等节点列表发生改变的时候，系统会发送 WIFI_P2P_PEERS_CHANGED_ACTION 广播 * invoke when the list of peers find, register, lost */ WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION -&gt; &#123; &#125; /** * 当一个连接建立或断开的时候，系统会发送该广播 * This action received when the connection setup or dis-setup */ WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION -&gt; &#123; &#125; &#125; &#125;&#125; 接下来在Activity中动态注册12345678910111213141516171819class WifiDirectActivity : AppCompatActivity() &#123; private val wifiDirectReceiver = WifiDirectReceiver() override fun onStart() &#123; super.onStart() wifiDirectReceiver.registerReceiver(this) &#125; override fun onStop() &#123; super.onStop() unregisterReceiver(wifiDirectReceiver) &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125;&#125; 没错，直接动态注册了！！！Android8.0的新特性让Android开发喵几乎一夜之间丧失在AndroidManifest中静态注册的技能（所以为了，考虑兼容，我们就直接动态注册了） 好，接下来验证一下WIFI_P2P_STATE_CHANGED_ACTION 我们在Receiver里面加点输出（实际开发还是用Log，极不推荐直接输出，这里笔者还是决定偷懒♪(^∇^*)） 12345678910111213141516/** *当Wifi功能打开或关闭的时候系统会发送 WIFI_P2P_STATE_CHANGED_ACTION 广播 * Tip: 并不是指是否已经成功连上WI-FI */WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION -&gt; &#123; //get the state of current device val state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, WifiP2pManager.WIFI_P2P_STATE_DISABLED) if (state == WifiP2pManager.WIFI_P2P_STATE_ENABLED) &#123; //Wifi p2p enable println("wifi enable") &#125; else &#123; //wifi p2p disEnable println("wifi disEnable") &#125;&#125; 然后跑到真机上（万能的模拟器然而并不能模拟wifi功能，只能真机实测一波啦），反复开关Wifi功能 12303-26 16:26:08.744 29313-29313/com.j.ming.eupanwifidirect I/System.out: wifi enable03-26 16:26:11.098 29313-29313/com.j.ming.eupanwifidirect I/System.out: wifi disEnable03-26 16:32:16.376 29313-29313/com.j.ming.eupanwifidirect I/System.out: wifi enable OK, 得到上面的输出，我们就知道确实，这个ACTION在WI-FI功能开关的时候会触发 WIFI_P2P_THIS_DEVICE_CHANGED_ACTION 大新闻：这个ACTION携带了一团神秘数据，^``^,那就是本设备的设备信息啦～ 同样的，我们加一点输出，看一下都包含哪些信息（当然，最直接的是看WifiP2pDevice这个数据） 1234567/** * 当前设备的详细信息发生变化的时候，系统会发送 WIFI_P2P_THIS_DEVICE_CHANGED_ACTION 广播 */WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION -&gt; &#123; val device: WifiP2pDevice = intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_DEVICE) println(device)&#125; 同样真机测试，来调皮的开关一下WI-FI功能（当然，一开始也会打印出设备信息，那就是在这个Receiver被注册的时候） 12345678910111203-26 16:43:29.420 30294-30294/com.j.ming.eupanwifidirect I/System.out: wifi enable03-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: Device: 魅蓝 Note303-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: deviceAddress: 2e:57:31:98:45:3503-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: primary type: 10-0050F204-503-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: secondary type: null03-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: wps: 003-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: grpcapab: 003-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: devcapab: 003-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: status: 303-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: wfdInfo: WFD enabled: falseWFD DeviceInfo: 003-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: WFD CtrlPort: 003-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: WFD MaxThroughput: 0 可以看到包括设备的名字，本设备的MAC地址，状态balabala 后面两种ACTION涉及到连接，我们等下讨论 WifiP2pManager 的异种接口 requestPeers、requestGroupInfo、discoverPeers、createGroup、removeGroup等等 当然可以直接用，不过为了简介，我们一边用一遍封装出一个管理类 获得WifiP2pManager对象 下面的操作需要添加以下权限123456&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" android:required="true" /&gt;&lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" android:required="true" /&gt; 12345678910111213object WifiDirectManager&#123; private var manager: WifiP2pManager by Delegates.notNull() private var channel: WifiP2pManager.Channel by Delegates.notNull() fun init(context: Context): WifiDirectManager&#123; //通过获取系统服务的方式获得Manager对象 manager = context.getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager channel = manager.initialize(context, Looper.getMainLooper())&#123; //初始化操作成功的回调 &#125; return this &#125;&#125; 利用Kotlin 的object关键字，快速创建一个单例对象 channel在后续的操作中要用到，这个是manager初始化成功之后返回的渠道对象 上述init方法建议在Application的onCreate中调用，至少在使用前调用 discoverPeers 在上述的WifiDirectManager类里面添加如下方法 1234567891011121314151617181920212223242526/** * discover available peer list */fun discoverPeers(): WifiDirectManager &#123; manager.discoverPeers(channel, object : WifiP2pManager.ActionListener&#123; override fun onSuccess() &#123; println("discover Peers success") &#125; override fun onFailure(reason: Int) &#123; println("discover Peers fail: $reason") &#125; &#125;) return this&#125;/** * request the peer list available */fun requestPeers(): WifiDirectManager &#123; manager.requestPeers(channel) &#123; peers -&gt; //请求对等节点列表操作成功 println(peers) &#125; return this&#125; 在Activity里面拖一个button，在点击事件里面调用这个函数 123btnSendTestBroadcast.setOnClickListener &#123; WifiDirectManager.discoverPeers()&#125; 上面的方法，望文生义，就是用来检索附近的可用对等节点列表，然后后面就是这个整套API最坑的一个回调了 WifiP2pManager.ActionListener 这个回调里面的success和failure表示的是一个操作是否执行成功，而并不能反映出这个操作的结果 所以从上面这个回调里我们只能知道，执行discoverPeers这个操作有没有成功，是无法获取到对等节点列表的 那怎么获取检索的结果呢，答案是: 在Receiver里面直接获取（API &gt;= 18） 在Receiver里面调用requestPeers()获取- 两种获取对等节点列表的方式 Tip：在调用discoverPeers之后才能获取到对等节点列表 1234567891011121314/** * 当可连接的对等节点列表发生改变的时候，系统会发送 WIFI_P2P_PEERS_CHANGED_ACTION 广播 * invoke when the list of peers find, register, lost */WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION -&gt; &#123; //api &gt; 18 have this extra info, if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123; val wifiP2pList: WifiP2pDeviceList = intent.getParcelableExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST) println(wifiP2pList) &#125; else &#123; //if the sdk version lower than 18 //get WifiP2pDeviceList by call WifiP2pManager.requestPeers to get WifiDirectManager.requestPeers() &#125;&#125; 可以看到，当可用对等节点列表变化时，系统会发送 WIFI_P2P_PEERS_CHANGED_ACTION 广播，我们有两种方式获取对等节点列表 API &gt;= 18 的时候可以直接在 intent 携带数据中获取到 WifiP2pDeviceList 对象 当 API 在[14, 18) 之间的时候，只能调用manager的requestPeers方法，在回调当中获取 其实：只要都采用第二种方式，就能保持一致性了 具体输出结果可以自己试一试 connect12345678910111213141516171819202122232425/** * connect by MAC address(hardware address) */fun connect(deviceAddress: String) &#123; val config = WifiP2pConfig() config.deviceAddress = deviceAddress config.wps.setup = WpsInfo.PBC manager.connect(channel, config, object : WifiP2pManager.ActionListener &#123; override fun onSuccess() &#123; println("connect operator success") &#125; override fun onFailure(reason: Int) &#123; println("connect operator fail: $reason") &#125; &#125;)&#125;/** * invoke this method to connect a p2p device */fun connect(device: WifiP2pDevice): WifiDirectManager &#123; connect(device.deviceAddress) return this&#125; 在前面我们已经获取到对等节点列表了，每个对等节点设备信息里面包含其mac地址，用mac地址就能连接 连接成功以后 系统就会发送 WIFI_P2P_CONNECTION_CHANGED_ACTION 广播了，你可在里面获取对方设备的信息以及群组的信息 如果两个对等节点都没有创建群组，则连接之后其中一端设备会自动成为群组，每个组员都能获取到群组的IP WIFI_P2P_CONNECTION_CHANGED_ACTION 包含的信息 给WifiDirectManager类添加几个封装函数 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * request the group info */fun requestGroup(): WifiDirectManager &#123; manager.requestGroupInfo(channel) &#123; group -&gt; &#125; return this&#125;/** * create a group */fun createGroup(): WifiDirectManager &#123; manager.createGroup(channel, object : WifiP2pManager.ActionListener &#123; override fun onFailure(reason: Int) &#123; println("create group fail: $reason") &#125; override fun onSuccess() &#123; println("create group success") &#125; &#125;) return this&#125;/** * remove a group */fun removeGroup(): WifiDirectManager &#123; manager.removeGroup(channel, object : WifiP2pManager.ActionListener &#123; override fun onSuccess() &#123; println("remove group success") &#125; override fun onFailure(reason: Int) &#123; println("remove group success: $reason") &#125; &#125;) return this&#125; 看看Receiver里面的代码 123456789101112131415/** * 当一个连接建立或断开的时候，系统会发送该广播 * This action received when the connection setup or dis-setup */ WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION -&gt; &#123; val networkInfo = intent.getParcelableExtra&lt;NetworkInfo&gt;(WifiP2pManager.EXTRA_NETWORK_INFO) val wifiP2pInfo = intent.getParcelableExtra&lt;WifiP2pInfo&gt;(WifiP2pManager.EXTRA_WIFI_P2P_INFO) if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123; val wifiP2pGroupInfo = intent.getParcelableExtra&lt;WifiP2pGroup&gt;(WifiP2pManager.EXTRA_WIFI_P2P_GROUP) &#125; else &#123; &#125; &#125;&#125; 从上面可以看出，当收到系统发送的 WIFI_P2P_CONNECTION_CHANGED_ACTION 广播的时候，我们可以获取下面信息 NetworkInfo WifiP2pInfo (对端设备的信息) WifiP2pGroup （两种方式获取， 和之前获取对等节点列表的操作类似） 应用方式 可以一个设备主动创建一个Group，然后其它设备检索后连接 一旦连接成功，这些设备就处于同一自组网下了，组员是可以直接在WifiP2pGroup里面获取到群主的ip。接下来就可以直接用Socket进行各种骚操作了 至于群主如何获取组员的IP，目前想到的一种方式是群主开一个Socket监听，组员连接成功通过socket向群主发送一个请求，然后群主就可以在请求的socket对象里面获取组员的IP了]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用ngrok实现内网穿透]]></title>
    <url>%2F2018%2F03%2F19%2Fngrok_01%2F</url>
    <content type="text"><![CDATA[实现内网穿透紫ngrok无法通过天墙之后，国内也出现了一批成熟的商业化实现方案，诸如花生壳、net123、Sunny-ngrok等。不过免费的极不稳定还有流量带宽限制，最后还是决定自己搭一个。本文利用ngrok搭建一个用于内网穿透的环境。需求是通过一层反向代理，实现通过一个外网域名访问一个部署在局域网上的服务。 准备 一个公网服务器（Linux系统）==&gt; 阿里云，腾讯云之类的都行 这个公网服务器主要用作反向代理，我们在本文中称之为VPS服务器 一个独立的域名 一个用于提供服务的本地PC 步骤 GO语言环境搭建ngrok项目是用GO语言实现的，需要先安装GOLANG开发环境，系统不限，因为GO语言是跨平台的！安装过程很简单，参考官网的教程即可！ 获取ngrok源码12345# 下面是直接去ngrok的github地址下载（待会儿make的时候还会需要装几个其它的依赖，可能会出现很多问题）git clone https://github.com/inconshreveable/ngrok.git# 下面是笔者将代码clone下来，并添加了相应依赖之后的地址，如果用上面的方式出现错误，可以clone下面的地址git clone https://github.com/SunnyQjm/ngrok.git 解析域名因为我们自己搭建，需要使用自己的域名（以 test.j.cn ）为例，我们需要做以下解析： 1234test.j.cn ------------&gt; A记录到你的VPS服务器的IP# ngrok可以指定子域名，下面的解析方式可以让任意子域名都能得到正确的解析*.test.j.cn ------------&gt; CNAME记录到 test.j.cn 生成签名证书 因为我们是自己搭建，就不能用ngrok官方的SSL证书，需要自己生成 下面生成的证书在编译项目的时候要用到，所以务必要在编译之前生成 需要注意的是，客户端和服务器的证书必须是同一份，这样在程序在认证的时候才能正确解析 1234567891011121314151617# 首先导出环境变量，将下面的值替换成你的域名export NGROK_DOMAIN="test.j.cn"#先进入到ngrok的根目录，生成证书的操作需要在根目录下进行cd ngrok# 下面的命令用于生成证书openssl genrsa -out rootCA.key 2048openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=$NGROK_DOMAIN" -days 5000 -out rootCA.pemopenssl genrsa -out device.key 2048openssl req -new -key device.key -subj "/CN=$NGROK_DOMAIN" -out device.csropenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000# 下面的命令用于将我们生成的证书替换ngrok默认的证书cp rootCA.pem assets/client/tls/ngrokroot.crtcp device.crt assets/server/tls/snakeoil.crtcp device.key assets/server/tls/snakeoil.key 编译运行 服务端（VPS服务器一端） 首先指定一下环境变量，在不同的操作系统下需要指定不同的环境变量，才能正确编译(默认是Linux 64位的配置，如果你的服务器是64位的Linux系统，也可以不指定，直接用默认的就行) 123GOOS=linux GOARCH=amd64#如果是32位系统，这里 GOARCH=386#如果是windows系统，GOOS=windows 然后make出服务端程序 1make release-server 如果编译成功，你会在bin目录下看到ngrokd程序 1234cd bin# 查看使用帮助./ngrokd -h 查看使用帮助 123456789101112131415161718# 查看使用帮助./ngrokd -h -domain string Domain where the tunnels are hosted (default "ngrok.com") -httpAddr string Public address for HTTP connections, empty string to disable (default ":80") -httpsAddr string Public address listening for HTTPS connections, emptry string to disable (default ":443") -log string Write log messages to this file. 'stdout' and 'none' have special meanings (default "stdout") -log-level string The level of messages to log. One of: DEBUG, INFO, WARNING, ERROR (default "DEBUG") -tlsCrt string Path to a TLS certificate file -tlsKey string Path to a TLS key file -tunnelAddr string Public address listening for ngrok client (default ":4443") 启动服务端 12345# 如果不能执行，你可能需要用 sudo chmod +x ngrokd 给它执行权限# domain域输入之前生成证书时指定的域名# httpAddr 指定转发http协议的哪个端口# httpAddrs 指定转发https协议的哪个端口（如果不需要可以省略）./ngrokd -domain="$NGROK_DOMAIN" -httpAddr=":8000" -httpsAddr=":4433" 如果执行成功，你会看到类似以下界面： 12345[16:23:40 CST 2018/03/19] [INFO] (ngrok/log.(*PrefixLogger).Info:83) [registry] [tun] No affinity cache specified[16:23:40 CST 2018/03/19] [INFO] (ngrok/log.Info:112) Listening for public http connections on [::]:9748[16:23:40 CST 2018/03/19] [INFO] (ngrok/log.Info:112) Listening for public https connections on [::]:443[16:23:40 CST 2018/03/19] [INFO] (ngrok/log.Info:112) Listening for control and proxy connections on [::]:4443[16:23:40 CST 2018/03/19] [INFO] (ngrok/log.(*PrefixLogger).Info:83) [metrics] Reporting every 30 seconds 自此，服务端算是配置好了 客户端（部署了服务，需要内网穿透访问的主机） 客户端要做的事情就是指定把本机的那个端口暴露给VPS服务器，客户端要在该端口上部署了服务（web服务或者tomcat服务等），这样VPS就能够将请求转发到该端口对应的服务上了 12345678910111213141516171819202122232425262728293031323334# 因为前面说过，服务端和客户端的证书要是同一份，这样认证才能通过，所以好的解决方案是在服务端上把客户端程序也编译出来，然后通过scp命令拷贝到客户端# 假设我要在mac上运行客户端，需要在编译命令前加上一些参数(如果客户端服务器也是Linux 64位，则不用指定环境变量)GOOS=darwin GOARCH=amd64 make release-clientmake release-client# 编译好后scp到本地scp xxx xxx# 下面开始本地配置（下面的配置在客户端进行）# 新建一个配置文件（在ngrok/bin目录下）vim ngrok.cfg# 添加一下两行# 第一行是将要绑定的域名+4443端口（因为ngrok服务端默认有一个服务是坚挺在4443端口的，客户端会通过这个端口与之相连）==&gt; 记得将域名换成自己在生成证书时指定的server_addr: "test.j.cn:4443"trust_host_root_certs: true# 帮助信息./ngrok -hExamples: ngrok 80 ngrok -subdomain=example 8080 ngrok -proto=tcp 22 ngrok -hostname="example.com" -httpauth="user:password" 10.0.0.1# 80就是我们要转发的端口了./ngrok -config=./ngrok.cfg 80# 指定协议和端口，不指定默认是 http+https./ngrok -config=./ngrok.cfg -proto=tcp 22# 指定子域名，不指定就会随机生成./ngrok -config=./ngrok.cfg -subdomain=test 80 连接成功会显示如下状态： 在浏览器中输入http://127.0.0.1:4040，就可以看到请求的具体信息了！是不是很神奇！ 注意： 上文中所有出现域名的地方都要统一，客户端和服务端的证书要是同一份，否则在连接的时候会出现bad certification 参考： 自己建立ngrok服务器进行内网穿透 CentOS上搭建ngrok服务端（内网穿透）]]></content>
      <tags>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现监听移动端上下左右滑动事件]]></title>
    <url>%2F2018%2F01%2F24%2Fjs_01%2F</url>
    <content type="text"><![CDATA[Introduction最近刚入坑web前端，学了一点基础，便准备写个简单的2048小游戏试试手。开发过程中发现，PC端可以直接监听键盘输入，但是移动端就不得不监听屏幕上的滑动事件了。 现有的js库中没有可以直接满足上述要求的封装 在JQuery Mobile 中 可以通过 .on 的方式监听左右滑动事件，但是没有上下滑动事件（而且我想写一个PC端和移动端都通用的网页的话，就必须引入Jquery，同时引入Jquery和Jquery Mobile 使得Bootstrap中的按钮样式改变了，这显然不是想要的结果） 所以为了保持PC端和移动端的一致性，决定直接封装一下js的移动端的触摸事件，实现上述需求 2048可以在手机上打开，仍然具有不错的交互 点我体验 源码地址 JS 触摸事件（event） event的类型 touchstart: 当手指触摸屏幕时触发（相当于Android中的ACTION_DOWN事件） touchmove: 当手指在屏幕上滑动时连续触发（相当于Android中的ACTION_MOVE事件）— 期间调用preventDefault()可以屏蔽事件的默认行为，达到阻止滚动的效果 touchend: 当手指从屏幕上移开时触发（相当与Android中的ACTION_UP） touchcancel: 当系统停止跟踪触摸时触发。关于此事件的触发时机，文档中没有明确说明（我们在接下来的过程中也用不到） event用于跟踪触摸的属性 touches: 表示当前跟踪的触摸操作的Touch对象的数组 targetTouches: 特定于事件目标的Touch对象数组 changeTouches: 表示子上次触摸以来发生了什么改变的Touch对象的数组 注意： 在touchend事件发生时，event的touches对象中就没有元素了，需要到changeTouches中去获取触摸离开时的位置信息 Touch对象包含的数组 clentX: 触摸目标在窗口中的x坐标 clientY: 触摸目标在窗口中的y坐标 identifier: 标识触摸的唯一ID pageX： 触摸目标在页面中的x坐标 pageY： 触摸目标在页面中的y坐标 screenX： 触摸目标在屏幕中的x坐标 screenY： 触摸目标在屏幕中的y坐标 target：触摸的DOM节点目标 封装一个操作对象该对象的封装，前两个函数参考书籍《JavaScript 高级程序设计》（第三版） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var EventUtil = &#123; addHandler: function (element, type, handler) &#123; if (element.addEventListener) element.addEventListener(type, handler, false); else if (element.attachEvent) element.attachEvent("on" + type, handler); else element["on" + type] = handler; &#125;, removeHandler: function (element, type, handler) &#123; if(element.removeEventListener) element.removeEventListener(type, handler, false); else if(element.detachEvent) element.detachEvent("on" + type, handler); else element["on" + type] = handler; &#125;, /** * 监听触摸的方向 * @param target 要绑定监听的目标元素 * @param isPreventDefault 是否屏蔽掉触摸滑动的默认行为（例如页面的上下滚动，缩放等） * @param upCallback 向上滑动的监听回调（若不关心，可以不传，或传false） * @param rightCallback 向右滑动的监听回调（若不关心，可以不传，或传false） * @param downCallback 向下滑动的监听回调（若不关心，可以不传，或传false） * @param leftCallback 向左滑动的监听回调（若不关心，可以不传，或传false） */ listenTouchDirection: function (target, isPreventDefault, upCallback, rightCallback, downCallback, leftCallback) &#123; this.addHandler(target, "touchstart", handleTouchEvent); this.addHandler(target, "touchend", handleTouchEvent); this.addHandler(target, "touchmove", handleTouchEvent); var startX; var startY; function handleTouchEvent(event) &#123; switch (event.type)&#123; case "touchstart": startX = event.touches[0].pageX; startY = event.touches[0].pageY; break; case "touchend": var spanX = event.changedTouches[0].pageX - startX; var spanY = event.changedTouches[0].pageY - startY; if(Math.abs(spanX) &gt; Math.abs(spanY))&#123; //认定为水平方向滑动 if(spanX &gt; 30)&#123; //向右 if(rightCallback) rightCallback(); &#125; else if(spanX &lt; -30)&#123; //向左 if(leftCallback) leftCallback(); &#125; &#125; else &#123; //认定为垂直方向滑动 if(spanY &gt; 30)&#123; //向下 if(downCallback) downCallback(); &#125; else if (spanY &lt; -30) &#123;//向上 if(upCallback) upCallback(); &#125; &#125; break; case "touchmove": //阻止默认行为 if(isPreventDefault) event.preventDefault(); break; &#125; &#125; &#125;&#125;; 使用1234//使用的时候很简单，只需要向下面这样调用即可//其中下面监听的是整个DOM//up, right, down, left为四个回调函数，分别处理上下左右的滑动事件EventUtil.listenTouchDirection(document, true, up， right, down, left)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高C考试说明]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_n%2F</url>
    <content type="text"><![CDATA[说明 最后一个高C课，老师旁边围了一圈，就有了如下信息 题型 简答：50 编程：30 实验：20 （代码分析，分析哪里错了…） 以下不用看括号里是我加的，以防万一 timewait不用看 key managment不用看 （知道怎么创建一个秘钥管理套接字：socket(PF_KEY, SOCK_RAW, 0)） ioctl 不用看 老师说会考 前几章重点 大端小端代码 traceroute、ping会考（研究生学长说不考，但是今年王老师出卷，其它先复习，有时间看看ping和traceroute的源码） HDR_INCL套接字选项（原始套接字设置该选项可以自己构造IP首部） BPF、DLPI、SOCK_PACKET（三种提供链路层访问控制的方式） 掌握netstat怎么用（用于显示各个端口的状态）]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（13）—— 线程（Threads）（第26章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_m%2F</url>
    <content type="text"><![CDATA[概述 用fork实现并发要求存在的问题 fork的代价是比较昂贵的 fork返回之后父子进程之间的信息传递需要进程间通信(IPC)机制。 使用线程可以有效的解决上面的问题 线程的创建是轻量级的，线程也被称为轻权进程（lightweight process）。线程的创建可能比进程快10~100倍 同一进程内的所有线程共享全局内存，这使得线程之间易于共享信息，然后随之而来的便是同步(synchronization)问题 同一进程内的线程共享： 全局变量 进程指令（process instruction） 大多数数据（most data） 打开的文件（open file）==&gt; 即描述符 信号处理函数和信号处置（Signal handlers and signal disposition） 当前工作目录（Current working directory） 用户ID和组ID（User and group ID） 线程独享以下内容： 线程ID （thread ID） 寄存器集合，包括程序计数器和栈指针 （Set of registers， including program counter and stack pointer） 栈（用于存放局部变量和返回地址） Stack（for local variables and return address） errno ==&gt; 全局动态变量（记录最近的一次错误） 信号掩码(Signal mask) 优先级(Priority)]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（12）—— 路由套接字和秘钥管理套接字（Routing Sockets and Key Managment Sockets）（第18章，第19章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_l%2F</url>
    <content type="text"><![CDATA[概述AF_ROUTE domain: 唯一支持的套接字是原始套接字(raw socket) 一个路由套接字上支持以下的三种操作 通过往路由套接字写数据来向内核发送消息（例如: 添加或删除路由） 通过从路由套接字读数据来接收内核发送的消息（例如：内核在接收到一个ICMP重定向消息的时候，就通过这种方式通知进程） 进程可以使用sysctl函数倾泻出路由表或列出所有已配置的接口 前两种需要超级权限，最后一种操作任何进程都可以执行 前两种可以复合起来使用，比如：进程通过写一个路由套接字往内核发送一个消息，请求内核提供关于某个给定路径的所有信息，又通过这个这个路由套接字接收内核的应答 数据链路套接字地址结构 &ensp; 1234567891011struct sockaddr_dl&#123; uint8_t sdl_len; //数据链路层地址是可变长度的，这个成员即为记录地址结构的长度 sa_family_t sdl_family; //AF_LINK uint16_t sdl_index; //网络接口的正值索引，if &gt; 0 uint8_t sdl_type; //IFT_ETHER等 uint8_t sdl_nlen; //名字的长度 uint8_t sdl_alen; //链路层地址的长度 uint8_t sdl_slen; //链路层选择器的长度 char sdl_data[12]; //数据域: 0 ~ sdl_nlen - 1 ==&gt; name // sdl_len ~ sdl_alen - 1 ==&gt; link-layer address&#125; 创建一个路由套接字 12int sockfd;sockfd = socket(AF_ROUTE, SOCK_RAW, 0); Key Managment 概述 PE_KEY domain: 唯一支持的套接字是原始套接字(raw socket) 创建一个秘钥管理套接字 12int sockfd;sockfd = socket(PF_KEY, SOCK_RAW, 0);]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（11）—— 数据链路访问（Datalink Access）（第29章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_k%2F</url>
    <content type="text"><![CDATA[概述目前大多数操作系统都为应用程序提供访问数据链路层的功能，这种功能可提供如下能力 能够监视由数据链路层接收的分组，使得诸如tcpdump之类的程序能够在普通计算机系统上运行，而无需使用专门的硬件设备来监视分组。如果使网络接口进入混杂模式(promiscuous mode)，甚至可以监听本地电缆上流通的所有分组 The ability to watch the packets received by the datalink layer, allowing programs such as tcpdump to be run on normal computer systems (as opposed to dedicated hardware devices to watch packets). (promiscuous mode) 能够作为普通应用进程而不是内核的一部分运行某些程序，例如：RARP The ability to run certain programs as normal applications instead of as part of the kernel. For example, most Unix versions of an RARP server are normal applications that read RARP requests from the datalink (RARP requests are not IP datagrams) and then write the reply back to the datalink 实现数据链路层访问的三个常见方法： BSD的分组过滤器BPF SVR4的数据链路提供者接口DLPI Linux的SOCK_PACKET接口 BPF4.4BSD and many other Berkeley-derived implementations support BPF DLPISVR4 provides datalink access through DLPI(Datalink Provider Interface) SOCK_PACKET and PF_PACKETTwo methods under Linux: SOCK_PACKET: original, widely available but less flexible PF_PACKET: newer method 1234/* newer systems*/fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));/* older systems*/fd = socket(AF_INET, SOCK_PACKET, htons(ETH_P_ALL)); 相关库 libpcap: 分组捕获函数和库 libnet：分组构造与输出库 检查UDP校验和字段的栗子见课本 图29-3]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（10）—— 原始套接字（Raw Socket）（第28章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_j%2F</url>
    <content type="text"><![CDATA[概述原始套接字提供TCP和UDP所不提供的以下3个能力 有了原始套接字，进程可以读与写ICMPv4、IGMPv4和ICMPv6分组 Raw sockets let us read and write ICMPv4, IGMPv4, and ICMPv6 packets. (ping, mrouted) 有了原始套接字，进程可以读写内核不处理其协议字段的IPv4数据报 With a raw socket, a process can read and write IPv4 datagrams with an IPV4 protocol field that is not processed by the kernel. 有了原始套接字，进程还可以使用IP_HDRINCL套接字选项（IP header include），自行构造IPv4首部 With a raw socket, a process can build its own IPv4 header using the IP_HDRINCL socket option 原始套接字的创建 创建 调用socket函数创建，而且函数的第二个参数必须是SOCK_RAW 123//下面以创建一个IPv4原始套接字为例int sockfd;sockfd = socket(AF_INET, SOCK_RAW, protocol); protocol参数通常不为0，是形如IPPROTO_xxx的某个常值 只有超级用户才能创建原始套接字（防止普通用户自行构造IP数据报） 可按以下方式开启IP_HDRINCL选项 123const int on = 1;if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &amp;on, sizeof(on)) &lt; 0) 出错处理 可在原始套接字上调用bind，但比较少见 可在原始套接字上调用connect，但比较少见 原始套接字输出原始套接字的输出遵循以下规则： 普通输出通过调用sendto或sendmsg并指定IP地址完成，如果套接字已连接，也可以调用write，writev，send Normal output is performed by calling sendto or sendmsg and specifying the destination IP address 如果IP_HDRINCL选项未开启，进程发送数据的起始地址是IP首部之后的第一个字节，IP首部由内核自行构造，并把socket中第三个参数的值设置进IP首部的协议字段 If the IP_HDRINCL option is not set, the starting address of the data for the kernel to send specifies the first byte following the IP header because the kernel will build the IP header and prepend it to the data from the process 如果IP_HDRINCL选项开启，进程发送数据的起始地址是IP首部的第一个字节，进程调用输出函数输出的数据中必须包括IP首部，整个IP首部自行构造 If the IP_HDRINCL option is set, the starting address of the data for the kernel to send specifies the first byte of the IP header IPv4标识字段可置为0，告诉内核设置该值 IPv4首部校验和字段总是由内核计算并存储 IPv4选项字段是可选的 内核会对超出外出接口MTU的原始分组进行分片 The kernel fragments raw packets that exceed the outgoing interface MTU 原始套接字输入内核把哪些接收到的IP数据报传递到原始套接字？遵循一下规则 规则 接收到的UDP和TCP分组绝不传递到任何原始套接字(如果一个进程想要读取，必须在数据链路层读取) Received UDP packets and received TCP packets are never passed to a raw socket. (must be read at the datalink layer) 大多数ICMP分组在内核处理完其中的ICMP消息后传递到原始套接字 Most ICMP packets are passed to a raw socket after the kernel has finished processing the ICMP message 所有的IGMP分组在内核完处理完其中的IGMP消息后传递到原始套接字 All IGMP packets are passed to a raw socket after the kernel has finished processing the IGMP message 内核无法识别其协议字段的所有IP数据报传递到原始套接字 All IP datagrams with a protocol field that the kernel does not understand are passed to a raw socket 如果某个数据报是以片段的形式到达，那么在它的所有片段均到达且重组之前，不传递任何片段到原始套接字 If t`he datagram arrives in fragments, nothing is passed to a raw socket until all fragments have arrived and have been reassembled. 内核在分配一个IP数据报到raw socket时的处理 When the kernel has an IP datagram to pass to the raw sockets, all raw sockets for all processes are examined, looking for all matching sockets. A copy of the IP datagram is delivered to each matching socket. The following tests are performed for each raw socket and only if all three tests are true is the datagram delivered to the socket 当内核分发IP数据报给原始套接字的时候，所有进程的所有原始套接字都将检查一遍，只要匹配，便获得该IP数据报的一个备份，下面是三个判断条件，只有当三个判断条件都为真时，内核才把接收的套接字传递给这个套接字 如果该原始套接字调用socket创建的时候，第三个参数指定了protocol（即不为0），则IP数据报中的协议字段，必须和其匹配 ==&gt; 协议匹配 如果该原始套接字已经调用了bind绑定到本地的某个IP地址，那么IP数据报中的地址字段，必须和其匹配 ==&gt; 目的地址匹配 如果该原始套接字已经调用connec连接了，则IP数据报的源端地址必须是connect所连接的对端设备的地址 ==&gt; 源端地址匹配 ping Program原理：往目的IP发送一个ICMP回射请求，该节点则以一个ICMP回射应答响应。由于ICMP规则要求回射应答中返回来自回射请求的标识符，序列号，以及可选数据。可以在可选数据中存放时间戳，以便在收到应答的时候就算RTT。（一般系统发送ICMP都有默认的TTL值大小（例如linux/unix 默认是64或255），提取出应答包中的TTL对当前主机和目的主机之间的跳数有一定指导意义） 一个没有特性蔓延（creeping featurism）的ping程序 自行阅读书上ping程序的源码 ping程序的概貌 traceroute Program 原理：一开始向目的节点发送一个TTL为1的 traceroute 可以用来测量本机到一个目的主机的路径 实现的原理是利用了IPv4的TTL字段或IPv6的跳限字段，一开始设置为1，然后中间节点会返回一个ICMP”time exceeded in transmit”（传输中超时）错误，接着逐渐增大TTL，从而逐步确定下一跳路由地址。直至目的节点返回一个ICMP”port unreachable”（端口不可达）错误，则表示到达目的节点（这要求目的节点没有在该端口上开启服务，即发送ICMP包时，目的端口号应该选择一个未被目的主机使用的端口号 ==&gt; traceroute选择了一个大于30000值作为目的端口号，因为UDP协议要求端口号必须小于30000，所以目的主机如果接收到必然会会一个ICMP端口不可达错误）。 早期用IP_HDRINCL来达到修改TTL的目的，现在多用IP_TTL套接字选项来修改]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（9）—— 名字和地址转换（Name and Address Conversions）（第11章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_i%2F</url>
    <content type="text"><![CDATA[概述数值地址长而不容易记，手工键入容易出错。用名字代表数字地址的机制便应运而生点我获取本文源码 主机名和IPv4地址之间转换：gethostbyname、gethostbyaddr 服务名字和端口号之间转换：getservbyname、getservbyport 两个协议无关的转换函数：getaddrinfo、getnameinfo 域名系统（Domain Name System， DNS） 主要用于主机名字和和IP地址之间的映射 基于UDP 简单名字（simple name）和全限定域名（Fully Qualified Domain Name， FQDN） 简单名字：如 solaris或bsdi 全限定域名：如 qjm253.top 严格来说FQDN最后必须以.结尾，但通常用户会省略。例如上面个域名严格来讲为： qjm253.top. 资源记录 A：A记录把一个主机名映射成一个32位的IPv4地址 AAAA：AAAA记录把一个主机名映射成一个128位的IPv6地址 PTR：称为指针记录（pointer record）的PTR记录把IP地址映射成主机名（IPv4、IPv6） MX：MX记录把一个主机指定作为个给定主机的“邮件交换器”（mail exchanger） CNAME：CNAME代表“canonical name”（规范名字），常用作为常用的服务指派CNAME记录 解析器和名字服务器（Resolvers and Name Servers） 名字服务器：存储了域名和IP地址的对应关系 解析器：客户端通过调用解析器中的函数来实现与DNS名字服务器的交互（实现名字与IP地址的转换） gethostbyname函数 原型：1234567891011121314151617181920#include &lt;netdb.h&gt;/*** 根据名字获取IPv4地址信息** @param 待转换的名字，如：qjm253.top* @return 成功则返回非空指针，出错则返回NULL，并且设置h_errno*/struct hostent *gethostbyname(const chat *hostname);/*** host entry 结构体，该结构中包含了所查找主机的所有IPv4地址信息*/struct hostent&#123; char *h_name; //正式主机名 char **h_aliases; //主机别名 int h_addrtype; //地址类型 int h_length; //地址长度，单位：byte char **h_addr_list; //主机包含的IPv4地址列表&#125; hostent结构和它所包含的信息 错误：h_errno 当调用gethostbyname出错时，便会设置h_errno的值为下列常值之一 类型 HOST_NOT_FOUND TRY_AGAIN NO_RECOVERY NO_DATA（等同于HOST_NOT_FOUND） hstrerrno函数接收一个上述常值之一，返回错误的具体描述 栗子： 本程序与课本略有不同，简单的支持一个地址解析以及默认解析IPv4 &ensp; ghbn.c12345678910111213141516171819202122#include &lt;unp.h&gt;int main(int argc, char **argv)&#123; char *ptr, **pptr; struct hostent *hptr; char str[INET_ADDRSTRLEN]; int i = 0; if(argc != 2) err_quit("usage: ./ghbn &lt;Domain name&gt;"); if( (hptr = gethostbyname(argv[1])) == NULL)&#123; err_msg("get hostbyname error for host %s : %s", argv[1], hstrerror(h_errno)); &#125; else &#123; printf("official hostname: %s\n", hptr-&gt;h_name); for(pptr = hptr-&gt;h_aliases; *pptr != NULL; pptr++) printf("\talist: %s\n", *pptr); for(pptr = hptr-&gt;h_addr_list; *pptr != NULL; pptr++) printf("address: %s\n", Inet_ntop(AF_INET, *pptr, str, sizeof(str))); &#125;&#125; 测试： 12345678910111213141516171819//我们先来测试一下正常的情况//可以很容易看出本博客是搭建在github上的，并且使用了一个作者自己的域名指向github上的域名输入： ./ghbn qjm253.top输出： official hostname: sni.github.map.fastly.net alist: qjm253.top alist: sunnyqjm.github.io address: 151.101.77.147//再来测试一下域名不存在的情况输入： ./ghbn qjm253.top.c输出： get hostbyname error for host qjm253.top.c : Unknown host//测试一下域名存在，但是没有映射地址的情况//qjm253.cn是笔者的一个保留域名，目前还没有解析到任何地址输入： ./ghbn qjm253.cn输出： get hostbyname error for host qjm253.cn : No address associated with name gethostbyaddr函数 原型：1234567891011#include &lt;netdb.h&gt;/*** 本函数试图由一个二进制的IP地址和找到相应的主机名，与gethostbyname的行为相反** @param addr addr参数实际上不是一个char *类型的指针，而是一个指向in_addr结构的指针* @param len len实际上就是in_addr结构体的大小* @param family 由于本函数只支持IPv4，所以family为AF_INET* @return 成功则返回非空指针，失败则返回NULL，并且设置h_errno**/struct hostent *gethostbyaddr(const char *addr, socklen_t len, int family); 栗子&ensp; ghba.c12345678910111213141516171819202122232425#include &lt;unp.h&gt;int main(int argc, char **argv)&#123; char *ptr, **pptr; struct hostent *hptr; char str[INET_ADDRSTRLEN]; struct sockaddr_in ia; if(argc != 2) err_quit("usage: ./ghbn &lt;IPAddress&gt;"); Inet_pton(AF_INET, argv[1], &amp;ia.sin_addr); if( (hptr = gethostbyaddr(&amp;ia.sin_addr, sizeof(ia.sin_addr), AF_INET)) == NULL)&#123; err_msg("get hostbyname error for host %s : %s", argv[1], hstrerror(h_errno)); &#125; else &#123; printf("official hostname: %s\n", hptr-&gt;h_name); for(pptr = hptr-&gt;h_aliases; *pptr != NULL; pptr++) printf("\talist: %s\n", *pptr); for(pptr = hptr-&gt;h_addr_list; *pptr != NULL; pptr++) printf("address: %s\n", Inet_ntop(AF_INET, *pptr, str, sizeof(str))); &#125;&#125; gethostbyaddr的第一个参数虽然是in_addr的地址结构，但是传的时候不能直接用in_addr，要使用sockaddr_in里面的in_addr。（博主猜想是应用的头文件中可能包含了in_addr结构体的多种实现，而gethostbyaddr函数要求的in_addr地址结构必须时候sockaddr_in里面定义的那种，读者有兴趣可以自行验证） 测试： 1234输入： ./ghba 127.0.0.1输出： official hostname: localhost address: 127.0.0.1 上面测试的是本机的回环地址，是成功的。如果要测试其它地址则不成功，具体可点我查看 getservbyname和getservbyport getservbyname 原型：1234567891011121314151617#include &lt;netdb.h&gt;/*** 通过服务名获取服务信息** @param servname 服务名，如：domain, ftp* @param protoname 协议名，如：TCP, UDP* @return 若成功则返回非空指针，若出错则返回NULL**/struct servent *getservbyname(const char *servname, const char *protoname);struct servent&#123; char *s_name; //正式的服务名 char **s_aliases; //服务别名列表 int s_port; //网络字节序的端口号 char *s_proto; //协议名&#125; 栗子&ensp; gsbn.c1234567891011121314151617#include &lt;unp.h&gt;int main(int argc, char **argv)&#123; struct servent *sptr; char **sptrs; if(argc != 3) err_quit("usgae: ./gsbn &lt;servname&gt; &lt;protoname&gt;"); sptr = getservbyname(argv[1], argv[2]); if(sptr == NULL) err_quit("get error"); printf("official name: %s\n", sptr-&gt;s_name); for(sptrs = sptr-&gt;s_aliases; *sptrs != NULL; sptrs++) printf("\t\talias: %s\n", *sptrs); printf("port: %d\n", sptr-&gt;s_port); printf("protocol: %s\n", sptr-&gt;s_proto);&#125; 测试1234567891011输入： ./gsbn domain udp输出： official name: domain port: 13568 protocol: udp输入： ./gsbn ftp tcp输出： official name: ftp port: 5376 protocol: tcp getservbyport 原型123456789#include &lt;netdb.h&gt;/*** 通过端口号获取服务的信息* @param port 端口号* @param protoname 协议名，如：TCP, UDP* @return 若成功则返回非空指针，若出错则返回NULL*/struct servent *getservbyport(int port, const char *protoname); 栗子&ensp; gsbp.c1234567891011121314151617#include &lt;unp.h&gt;int main(int argc, char **argv)&#123; struct servent *sptr; char **sptrs; if(argc != 3) err_quit("usgae: ./gsbn &lt;port&gt; &lt;protoname&gt;"); sptr = getservbyport(atoi(argv[1]), argv[2]); if(sptr == NULL) err_quit("get error"); printf("official name: %s\n", sptr-&gt;s_name); for(sptrs = sptr-&gt;s_aliases; *sptrs != NULL; sptrs++) printf("alias: %s\n", *sptrs); printf("port: %d\n", sptr-&gt;s_port); printf("protocol: %s\n", sptr-&gt;s_proto);&#125; 测试12345678//shell 通常运行在514端口，并且采用的是tcp协议输入： ./gsbp 514 tcp输出： official name: shell alias: cmd port: 514 protocol: tcp getaddrinfo函数这是一个比以上函数更新的函数，了解即可]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（8）—— UDP套接字编程（UDP Sockets Introduction）（第八章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_h%2F</url>
    <content type="text"><![CDATA[概述UDP编程和TCP编程有着本质的差异：UDP是无连接不可靠的数据报协议，非常不同于TCP提供的面向连接的可靠字节流点我获取本文源码 UDP的适用场景 DNS（域名系统） NFS（网络文件系统） SNMP（简单网络管理协议） 典型的UDP C/S 程序的函数调用 recvfrom和sendto函数 123456789101112131415161718192021222324252627282930313233#include &lt;sys/socket.h&gt;/*** 类似read函数，通过sockfd指向的套接字读数据** @param sockfd 目标描述符* @param buff 接收缓存，用于存放收到的数据* @param nbytes 指定接收的字节数* @param flags 标志位，14章详细讨论，此处都设为0* @param from 用于存放收到消息的源端地址* @param addrlen Value-Result参数，限定from大小，存放from实际大小** @return 成功 ==&gt; 返回收到的字节数* 出错 ==&gt; 返回-1*/ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen);/*** 类似write函数，通过sockfd指向的套接字写数据** @param sockfd 目标描述符* @param buff 发送缓存，用于存放要发送的数据* @param nbytes 指定发送的字节数* @param flags 标志位，14章详细讨论，此处都设为0* @param to 要发送的目的端地址* @param addrlen to结构的大小** @return 成功 ==&gt; 返回发送的字节数* 出错 ==&gt; 返回-1*/ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t addrlen); recvfrom返回0是可以接受的（不像read函数返回0代表对端关闭），因为UDP是无连接的 recvfrom调用的时候如果不关心发送端的地址，则后两个参数from和addrlen可以置为NULL。要注意的是，如果from传的是NULL，addrlen也必须传NULL（可能是由于recvfrom函数的内部实现导致的） recvfrom和sendto都可用于TCP，但通常不这么用 UDP实现简单的回射C/S程序 服务器程序123456789101112131415161718192021222324252627282930313233343536#include &lt;unp.h&gt;void dg_echo(int sockfd, SA *cliaddr, socklen_t clilen);int main(int argc, char **argv)&#123; int sockfd; struct sockaddr_in servaddr, cliaddr; //第二个参数指定为SOCK_DGRAM，标识创建一个UDP套接字 sockfd = Socket(AF_INET, SOCK_DGRAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9748); servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //为套接字绑定众所周知的端口号，以及指定接收哪些网络接口的请求 Bind(sockfd, (SA *) &amp;servaddr, sizeof(servaddr)); dg_echo(sockfd, (SA *) &amp;cliaddr, sizeof(cliaddr));&#125;void dg_echo(int sockfd, SA *cliaddr, socklen_t clilen)&#123; int n; socklen_t len; char mesg[MAXLINE]; for( ; ; )&#123; len = clilen; //接收客户号段发送的消息 n = Recvfrom(sockfd, mesg, MAXLINE, 0, cliaddr, &amp;len); //回射 Sendto(sockfd, mesg, n, 0, cliaddr, len); &#125;&#125; 这段程序和TCP服务端回射程序的实现逻辑类似，不一样的是收发消息用的是Recvfrom和Sendto 需要注意的是：UDP是无连接的，所以如果要给客户回发消息，就必须记录下客户的地址信息，Recvfrom的后两个参数就是用来记录客户的地址信息的，回发消息给客户的时候，用这个记录的地址信息即可 UDP层中隐含排队，所有收到的包都在队列中排队，recvfrom每次从队头取出消息处理，没有消息则阻塞（消息队列长度是有限制的，可通过SO_RCVBUF套接字选项修改） 客户端程序1234567891011121314151617181920212223242526272829303132333435363738#include &lt;unp.h&gt;void dg_cli_my(FILE *fp, int sockfd, SA *servaddr, socklen_t len);int main(int argc, char **argv)&#123; int sockfd; struct sockaddr_in servaddr; if(argc != 2) err_quit("usage: ./udpcli01 &lt;IPAddress&gt;\n"); //创建一个UDP套接字 sockfd = Socket(AF_INET, SOCK_DGRAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9748); Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr); dg_cli_my(stdin, sockfd, (SA *) &amp;servaddr, sizeof(servaddr));&#125;void dg_cli_my(FILE* fp, int sockfd, SA *servaddr, socklen_t len)&#123; int n; char sendline[MAXLINE], recvline[MAXLINE]; //从控制台接收用户输入，并发送给服务器 //接着接收服务器回射的消息，并输出到控制台 while( (Fgets(sendline, MAXLINE, fp)) != NULL)&#123; Sendto(sockfd, sendline, strlen(sendline), 0, servaddr, len); n = Recvfrom(sockfd, recvline, MAXLINE, 0, NULL, NULL); recvline[n] = 0; Fputs(recvline, stdout); &#125;&#125; 本段程序和TCP回射客户端程序的实现逻辑类似，同样的区别就在于对网络数据的读写操作不同 需注意的是：UDP是无连接的，所以客户端在调用Sendto的时候并不要求一定要有一个服务器在监听。即客户端只是负责把数据发出去，不管是否有人收到 TCP和UDP回射程序对比 两个客户的TCP客户/服务器小节 服务器每收到一个客户端的连接，便派生一个子进程，并将连接交付给子进程维护，父进程接着回去监听客户端的请求。在子进程中处理特定客户端的回射服务 两个客户的UDP客户/服务器小节 UDP服务器将收到的多个数据报置于套接字接收缓冲区中，再逐个取出，并根据Datagram报文中的发送端地址分别回复 对比 UDP回射服务程序是永不终止的，不像TCP中类似EOF的东西。而TCP回射服务程序，可以通过客户关闭连接导致服务端子进程中读到EOF，进而子进程退出。 大多数TCP服务器是并发的，而大多数UDP服务器是迭代的（TCP需要用连接标识不同的客户，并与之通信，所以一般做成并发。而UDP不需要维持连接，对收到的任何一个包进行处理都可以知道是谁发出的，对应处理即可，所以一个进程里面可以处理所有的请求） TCP通信必须要一个长期在线的服务端，并且服务端要先于客户端启动，而UDP通信则不用 可以看出，利用UDP进行通信的时候，并不要求服务器在客户端之前启动（即即便客户端比服务器先启动也是不会报错的，指示发出去的消息没有响应而已），只是服务器在启动之前，客户端无法获取到服务，一旦服务器启动，客户端变可以获取到服务。 相比之下，TCP进行进行通信的的时候，必须服务端先于客户端启动。因为TCP是有连接的，其通信依赖于一个已经建立好的连接，一旦连接无法建立，变无法进行通信（虽然可以在连接失败时反复尝试，但服务器没启动之前，客户端的connect函数都是返回错误的） UDP程序栗子小节 从客户角度总结UDP客户/服务器程序 从服务器角度总结UDP客户/服务器程序 服务器可从到达的IP数据报中获取的信息]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（7）—— 套接字选项（Socket Options）（第七章）]]></title>
    <url>%2F2018%2F01%2F05%2Fsuper_c_g%2F</url>
    <content type="text"><![CDATA[获取和设置影响套接字的三种方式 getsockopt和setsockopt函数和 fcntl函数 (file control) ioctl (IO control) getsockopt 和 setsockopt 函数这两个函数仅用于套接字 12345678910111213141516171819202122232425262728#include &lt;sys/socket.h&gt;/*** 获取一个打开的套接字的选项** @param sockfd 必须指向一个打开的套接字描述符* @param level 级别* @param optname 选项名* @param optval 指向一个变量的指针，用于接收函数的结果，其长度由最后一个长度限定* @param optlen 这是一个Value-Result参数，传入时限定optval的最大长度，防止缓存溢出* 函数执行结束时，可以通过这个参数知道内核究竟往optval写了多少数据* @return 成返回0，出错返回-1*/int getsockopt(int sockfd, int level, itn optname, void *optval, socklen_t *optlen);/*** 设置一个打开的套接字的选项** @param sockfd 必须指向一个打开的套接字描述符* @param level 级别* @param optname 选项名* @param optval 指向一个变量的指针，用于向函数传递要设置的值，其长度由最后一个长度限定* @param optlen 指示了optval的长度* @return 成返回0，出错返回-1*/int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); 套接字选项汇总 ==&gt; 课本图7-1和7-2 标志 ==&gt; 表示这个选项是一个二元选项。0表示关闭，非0表示开启 IPv4套接字选项下面几个选项的等级（level）均为IPROTO_IP IP_HDRINCL 可以为一个原始套接字设置该选项，设置以后可以自己构造IP首部（即在往里面写数据的时候是从IP包的首部起始位置开始写） IP_OPTIONS 该选项允许我们在IPv4中设置IP选项 IP_RECVDSTADDR 该套接字选项导致所收到的UDP数据报的目的IP地址由recvmsg函数作为辅助数据返回 IP_RECVIF 该套接字选项导致所收到的UDP数据包的接收接口索引有recvmsg函数作为辅助数据返回 IP_TOS 该套接字选项允许我们为TCP、UDP或SCTP套接字设置IP首部中的服务类型字段 IP_TTL 我们可以使用本选项设置或获取系统改用在从某个给定套接字发送的单薄分组上的默认TTL值]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（6）—— I/O复用（I/O Multiplexing）（第六章）]]></title>
    <url>%2F2018%2F01%2F05%2Fsuper_c_f%2F</url>
    <content type="text"><![CDATA[I/O复用概述进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件就绪（也就是说输入已准备好，或这描述符已能过承接更多的输出和），他就通知进程。这种能力称为I/O复用 应用场合 当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用 When a client is handling multiple descriptors (normally interactive input and a network socket) 一个客户同时处理多个socket套接字是可能的，不过比较罕见 It is possible, but rare, for a client to handle multiple sockets at the same time 如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字 If a TCP server handles both a listening socket and its connected sockets 如果一个服务器既要处理TCP，又要处理UDP If a server handles both TCP and UDP 如果一个服务器要处理多个服务或者多个协议 If a server handles multiple services and perhaps multiple protocols (e.g., the inetd daemon) I/O复用的引用场景不仅仅局限于网络编程 I/O模型 blocking I/O ==&gt; 阻塞式I/O nonblocking I/O ==&gt; 非阻塞式I/O I/O multiplexing(select and poll) ==&gt; I/O复用 signal driven I/O (SIGIO) ==&gt; 信号驱动式I/O asynchronous I/O (the POSIX aio_functions) ==&gt; 异步I/O 阻塞式I/O模型 非阻塞式I/O模型 ==&gt; 轮询（polling） I/O复用模型 信号驱动式I/O模型 异步I/O模型 各种I/O模型的比较 同步I/O操作（synchronous I/O operation）：导致请求进程阻塞，知道I/O操作完成 异步I/O操作（asynchronous I/O operation）：不导致请求进程阻塞 上述5种模型中，前4种是同步的，最后一种是异步的 select函数select函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的事件后才唤醒它 Allows the process to instruct the kernel to wait for any one of multiple events to occur and to wake up the process only when one or more of these events occurs or when a specified amount of time has passed. (readable, writable, expired time) 原型12345678910111213141516171819202122232425262728293031323334353637#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;/*** 调用select函数可告知内核对哪些描述符（就读、写或异常条件）感兴趣以及等待多长时间** @param maxfdl 最大文件描述符* @param readset 读监听集（当监听集内任意描述符可读，会导致select解除阻塞状态）* @param writeset 写监听集（当监听集内任意描述符可写，会导致select解除阻塞状态）* @param exceptset 异常监听集（当监听集内任意描述符出现异常，会导致select解除阻塞状态）* @param timout 最长等待时长（如果该时间过去了，select会跳出）** @return 正常返回就绪描述符的总数* 0 ==&gt; 超时返回* -1 ==&gt; 出错*/int select(int maxfdl, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);struct timeval &#123; long tv_sec; //秒 long tv_usec; //微秒&#125;//fd_set的数据结构，实际上是一long类型的数组，每一个bit都能与一打开的文件句柄//（不管是socket句柄，还是其他文件或命名管道或设备句柄）建立联系typedef struct&#123;/*XPG4.2requiresthismembername.Otherwiseavoidthenamefromtheglobalnamespace.*/#ifdef__USE_XOPEN__fd_maskfds_bits[__FD_SETSIZE/__NFDBITS];#define__FDS_BITS(set)((set)-&gt;fds_bits)#else__fd_mask__fds_bits[__FD_SETSIZE/__NFDBITS];#define__FDS_BITS(set)((set)-&gt;__fds_bits)#endif&#125;fd_set; timeout NULL: 忙等 值为0：立即返回 不为0：至多等待一段时间后返回 fd_set fd_set通常是一个整数数组，其中每个元素中的每一bit对应一个文件描述符 四个操作宏 1234567891011//将监听集清0void FD_ZERO(fd_set *fdset);//将一个描述符对应的bit置1void FD_SET(int fd, fd_set *fdset);//将一个描述符对应的bit置0void FD_CLR(int fd, fd_set *fdset);//判断一个描述符对应的bit位是否被置1void FD_ISSET(int fd, fd_set *fdset); 举个栗子： 12345678910111213141516171819假设fd_set 只有8位 ==&gt; fd_set fs执行: FD_ZERO(&amp;fs)结果: 00000000执行: FD_SET(1, &amp;fs)结果: 01000000执行：FD_SET(3, &amp;fs)结果: 01010000执行: FD_CLR(1, &amp;fs)结果: 00010000执行: FD_ISSET(3)返回: 1执行: FD_ISSET(1)返回: 0 select函数中的三个监听集，如果对哪个不感兴趣，直接设置为NULL就行了 select函数中的三个监听集参数均为Value-Result参数 maxfdpl maxfdl指定待测试后描述符的个数，它的值是待测试的最大描述符加1（因为数组的下标是从0开始的） FD_SETSIZE 常值是fd_set中描述符的总数，通常是1024，不过一般用不到那么大。指定maxfdp1可以提高select的效率 描述符就绪条件 str_cli函数修订版 各种条件下的处理 如果对端TCP发送数据，那么该套接字可读，并且read返回一个大于0的值 如果对端TCP发送一个FIN，那么该套接字可读，并且read返回0（EOF） 如果对端TCP发送一个RST，那么该套接字可读，并且read返回-1，而errno中含有确切的错误码 修订版的str_cli函数12345678910111213141516171819202122232425262728293031323334/** * 改进后的str_cli函数，可以在服务器停止后马上返回 */void str_cli(FILE* fp, int sockfd)&#123; int maxfdpl; fd_set rset; char sendline[MAXLINE], recvline[MAXLINE]; //首先清0 FD_ZERO(&amp;rset); for( ; ; )&#123; //在调用select之前，设置监听集，告知select感兴趣的描述符 FD_SET(fileno(fp), &amp;rset); FD_SET(sockfd, &amp;rset); //待测试的描述符数应该比我们要监听的最大描述符要大1（因为c语言数组是从0开始计的） maxfdpl = max(fileno(fp), sockfd) + 1; //一直阻塞，直至上述两个描述符至少其中一个可读（没有指定超时时间，所以会一直等待） Select(maxfdpl, &amp;rset, NULL, NULL, NULL); if(FD_ISSET(sockfd, &amp;rset))&#123; //socket 可读 if(Readline(sockfd, recvline, MAXLINE) == 0) err_quit("str_cli: server terminated prematurely"); Fputs(recvline, stdout); &#125; if(FD_ISSET(fileno(fp), &amp;rset))&#123; //用户从控制台输入了数据 if(Fgets(sendline, MAXLINE, fp) == NULL) return; Writen(sockfd, sendline, strlen(sendline)); &#125; &#125;&#125; 点我查看示例源码地址 rset作为一个Value-Result参数使用 在select调用之前，将感兴趣的描述符对应的bit置位。这样在调用select的时候，告知Unix内核当哪些描述符准备好时应该通知用户 在select调用之后，Unix内核将哪些描述符准备好了记录在rset当中。故在select解除阻塞之后，可以用FD_ISSET判断是哪些描述符准备好了。(这样处理即便是多个描述符同时准备好了，也可以处理) 批量输入和缓存（Batch Input and Buffering） 交互式输入： 批量输入： 以第五章最初的回射函数为例 TCP是全双工通信的 我们假设客户以网络能接受的最快速度发送，而服务器以网络能提供的最快速度应答 在时刻7的时候，网络管道就已经充满了 如果在时刻8客户输^D(EOF)，则会导致客户端调用close函数关闭连接，而此时仍然还有请求在去的路上，也还有应答在回来的路上，这些消息客户端将无法再收到。 实际上这个时候客户只是不发数据了，但是仍然还需要接收数据。所以我们需要一个能够关闭TCP连接中其中一半的连接的方法 ==&gt; shutdown函数 shutdown函数 close函数的两个限制 close把描述符的引用计数减1，仅在该计数变为0时才关闭套接字。==&gt; 而shutdown可以不管引用计数就激发TCP的正常终止序列 clse终止读和写两个方向。==&gt; shutdown可以有选择的终止读、写或读写均关闭 原型123456789#include &lt;sys.socket.h&gt;/*** howto = SHUT_RD ==&gt; 关闭读一半* SHUT_WR ==&gt; 关闭写一半* SHUT_RDWR ==&gt; 读写均关闭* @return 成功返回0，出错返回-1*/int shutdown(int sockfd, int howto); 调用shutdown关闭一半连接的图示： 在调用shutdown关闭读一半以后，四路挥手的前两步已经完成，但此时客户端仍然可以读 直到服务器发送FIN，完成四路挥手 pselect函数是select新的衍生函数，了解一下用法 1234567#include &lt;sys/select.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;int pselect(int maxfdpl, fd_set *readset, fd_set *writeset, fd_set *exceptionset, const struct timesepc *timeout, const sigset_t *sigmask); 其它参数的功能和select的一致 最后一个参数是一个信号的掩码集，表示pselect在阻塞期间，禁止掩码集内的信号被递交]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（5）—— TCP C/S程序示例（TCP Client/Server Example）（第五章）]]></title>
    <url>%2F2018%2F01%2F05%2Fsuper_c_e%2F</url>
    <content type="text"><![CDATA[简单回射程序概述 客户从标准输入读入一行文本，并写给服务器 服务器从网络输入读入这行文本，并回射给客户 客户从网络输入读入这行回射文本，并显示在标准输出上 TCP回射服务程序 &ensp;tcpserv01.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;unp.h&gt;void str_echo(int);int main(int argc, char** argv)&#123; int listenfd, connfd; pid_t pid; socklen_t clen; struct sockaddr_in cliaddr, servaddr; listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9748); //指定服务端socket的地址为通配地址 //表示接收来自本机各个网络接口的连接请求 servaddr.sin_addr.s_addr = htonl(INADDR_ANY); Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr)); Listen(listenfd, LISTENQ); for( ; ; )&#123; clen = sizeof(cliaddr); connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clen); //接受到来自客户端的请求之后，fork一个进程，在子进程中为客户提供服务 //父进程则关闭本进程内该已连接描述符（引用计数减1） //然后再返回继续accept，可以达到并发的效果 if( (pid = Fork()) == 0 )&#123; //子进程执行 Close(listenfd); str_echo(connfd); Close(connfd); exit(0); &#125; Close(connfd); //父进程执行 &#125;&#125;/** * 为客户端提供服务 * 从客户端接收一个字符串，并将字符串回射回客户端 */void str_echo(int connfd)&#123; ssize_t n; char buf[MAXLINE];again: while((n = read(connfd, buf, MAXLINE)) &gt; 0) Writen(connfd, buf, n); if(n &lt; 0 &amp;&amp; errno == EINTR) goto again; else if(n &lt; 0) err_sys("str_echo: read error");&#125; 50 ～ 55: 这里用到的是系统的read函数，没有对信号中断错误处理，需要自己处理。（收到客户的FIN或EOF将导致read返回） TCP回射客户端程序 12345678910111213141516171819202122232425262728293031323334353637#include &lt;unp.h&gt;void str_cli(FILE*, int);int main(int argc, char** argv)&#123; int sockfd; struct sockaddr_in servaddr; if(argc != 2) err_quit("usage: ./tcpserv01 &lt;IPAddress&gt;"); sockfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_port = htons(9748); servaddr.sin_family = AF_INET; //调用inet_pton函数将用户输入的点分十进制串转化成网络字节序的32为IPv4地址 Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr); Connect(sockfd, (SA *) &amp;servaddr, sizeof(servaddr)); str_cli(stdin, sockfd); Close(sockfd);&#125;/** * 用fgets读取用户的一行输入，发送给服务器，再从服务器接收一行回复并打印到控制台 */void str_cli(FILE* fp, int sockfd)&#123; char sendbuf[MAXLINE], recvline[MAXLINE]; while(Fgets(sendbuf, MAXLINE, fp) != NULL)&#123; Writen(sockfd, sendbuf, strlen(sendbuf)); if(Readline(sockfd, recvline, MAXLINE) == 0) err_quit("str_cli: server terminated prematurely"); Fputs(recvline, stdout); &#125;&#125; 正常启动 先启动服务器123456789//后台启动服务器./tcpserv01 &amp;[1] 10186//我们查看一下端口的状态，用管道过滤，只显示9748端口的信息netstat -a | grep 9748Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:9748 0.0.0.0:* LISTEN 接着直接在本机连接服务器123456789//连接到本机的回环地址./tcpcli01 127.0.0.1//再开一个shell，查看当前的端口状态状态netstat -a | grep 9748Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:9748 0.0.0.0:* LISTENtcp 0 0 localhost:9748 localhost:32890 ESTABLISHEDtcp 0 0 localhost:32890 localhost:9748 ESTABLISHED 0.0.0.0 ==&gt; 代表通配地址 * ==&gt; 代表通配端口 客户端在收到三路握手的第二个分节的时候，connect函数就返回了。而服务器在收到三次握手的第三个分节的时候accept才返回（之前分析过，服务器在收到第二个分节的时候还处于SYN_RECV状态，只有在收到第三个分节的时候才进入ESTABLISHED状态，此时相应的socket才被扔进监听套接字的已完成队列。而accept只在已完成队列中取socket，所以accept必定是在收到第三个分节之后才返回） 正常终止 状态转换图： 进程终止： 关闭本进程打开的所有的描述符 向父进程发送一个SIGCHLD信号 123456789101112./tcpcli01 127.0.0.1hellohello //服务器回射回来的good byegood bye //服务器回射回来的^D //Ctrl + D 相当于输入EOF//在客户端程序退出后马上查看端口状态（由于是本机测试，一定要快，要不然抓不到）netstat -a | grep 9748Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:9748 0.0.0.0:* LISTENtcp 0 0 localhost:33146 localhost:9748 TIME_WAIT 键入EOF后，客户端的fgets返回NULL，导致str_cli结束，最终导致main函数执行到exit而终止 进程终止的部分任务是关闭进程打开的所有的描述符，因此客户端打开的套接字由内核关闭，这导致客户TCP向服务器发送一个FIN，服务器回一个ACK。至此，四路挥手的前两步完成。服务器处于CLOSE_WAIT状态，而客户端处于FIN_WAIT_2状态 服务器TCP收到FIN后，readline函数返回0，导致str_echo退出，接着main函数执行到exit，进而导致服务端子进程退出。 同样的，服务端子进程所打开的所有描述符随之关闭。这导致服务器向客户发送一个FIN，客户回一个ACK，至此，四路挥手结束，连接完全终止。客户套接字进入TIME_WAIT状态。 进程终止的另一部分内容是：在服务器子进程终止时，给父进程发送一个SIGCHLD信号。由于我们在代码中没有捕获该信号，而该信号的默认处理为忽略，所以就导致子进程进入僵死状态123456789//我们调用ps命令来验证一下//因为笔者在测试的时候打开了客户端两次，所以有两个僵死的子进程ps -a PID TTY TIME CMD 2720 pts/0 00:00:21 hexo10186 pts/1 00:00:00 tcpserv0111146 pts/1 00:00:00 tcpserv01 &lt;defunct&gt; //僵死进程13389 pts/1 00:00:00 tcpserv01 &lt;defunct&gt; //僵死进程18996 pts/1 00:00:00 ps POSIX信号处理信号（signal）就是告知某个进程发生了某个事件的通知，有时也称为软件中断（software interrupt）。通常是异步的 每个信号关联一个处置（deposition），或称行为（action）。在信号发生时执行 类型 一个进程发给另一个进程（可以是自身） 由内核发给进程 三种处置 自定义信号处理函数，然后用sigaction设置给信号 SIGKILL和SIGSTOP不能被捕获12//信号处理函数原型void handler(int signo); SIG_IGN ==&gt; 忽略信号 SIG_DEF ==&gt; 默认处理 signal函数 原型： 123456789101112void (*signal(int signo, void (*func)(int)))(int);//定义新类型，来化简上面的原型typedef void Sigfunc(int)/*** 为一个信号设置处理函数* @param signo 信号* @param func 信号处理函数* @return 指向信号处理函数*/Sigfunc *signal(int signo, Sigfunc *func); POSIX规定设置信号的处置必须调用sigaction，上面的signal是对signation的封装，更容易使用 处理SIGCHLD信号 僵死状态 僵死（zombie）状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息包括子进程的进程ID、终止状态以及资源利用信息。如果一个进程终止，而该进程有子进程处于僵死状态，那么它的所有僵死子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们 处理僵死进程1234567891011//首先定义如下信号处理函数void sig_chld(int signo)&#123; pid_t pid; int stat; pid = wait(&amp;stat); printf("child %d terminated\n", pid); return;&#125;//在上面的server端程序的Listen之后添加下面这行Signal(SIGCHLD, sig_child); 点我查看源码 在执行了上面的处理之后，再测试，就观测不到僵死进程了 处理被中断的慢系统调用 适用于慢系统调用的基本规则：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误 有些系统上会发生，有些系统做了处理，不会发生。但是为了便于移植，还是建议用类似于下面的方法处理这种错误123456789for( ; ; )&#123; clilen = sizeof(cliaddr); if( (connfd = accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0)&#123; if(errno == EINTR) continue; else err_sys("accept error"); &#125;&#125; wait和waitpid函数 123456789101112131415161718#include &lt;sys/wait.h&gt;/*** 用于在父进程中清理已终止子进程（解除子进程的僵死状态）** @param wait函数通过这个参数返回子进程的终止状态* @return 成功则返回被清理子进程的ID，错误则返回0或-1*/pid_t wait(int *statloc);/*** 用于在父进程中清理已终止子进程（解除子进程的僵死状态）* @param pid 用于指定清理那个子进程，如果传入-1则表示等待第一个终止的子进程* @param statloc 函数通过这个参数返回子进程的终止状态* @param options 可选项* @return 成功则返回被清理子进程的ID，错误则返回0或-1*/pid_t waitpid(pid_t pid, int *statloc, int options); 调用wait函数的时候如果没有已经终止的子进程，不过仍然有一个或多个子进程在执行，那么wait函数将阻塞到其中任意一个子进程终止为止 waitpid的options可选项如果制定为WNOHANG，则告知内核在没有已终止子进程时不要阻塞 wait函数和waitpid的区别 waitpid可以指定终止哪个子进程，而wait不能 waitpid可以实现在没有已终止子进程时不要阻塞，而wait不能 根据上述区别的第二点我们改进之前的信号处理函数 12345678910//由于wait不能实现在没有已终止子进程时不要阻塞，所以在下面的循环中不能调用wait，否则可能会阻塞主线程//经过下面的修改之后，就可以支持一次调用清理多个进程的要求void sig_chld(int signo)&#123; pid_t pid; int stat; while( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0) printf("chihld %d terminated\n", pid); return;&#125; 具体可以参考课本5.10介绍的同时开五个连接请求的情况]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（4）—— 基本套接字函数（Elementary Sockets Functions）（第四章）]]></title>
    <url>%2F2018%2F01%2F04%2Fsuper_c_d%2F</url>
    <content type="text"><![CDATA[socket函数 1234567891011121314151617#include &lt;sys/socket.h&gt;/*** 该函数用于创建一个socket套接字* @param domin 协议族/地址族* @param type 套接字的类型* SOCK_STREAM ==&gt; TCP套接字* SOCK_DGRAM ==&gt; UDP套接字* SOCK_RAW ==&gt; 原始套接字* SOCK_PACKET ==&gt; 可用于链路层访问控制* @param protocol 指定协议** @return 返回一个socket描述符 sockfd* sockfd &lt; 0 ==&gt; 创建失败* sockfd &gt;= 0 ==&gt; 创建成功，之后可用该sockfd进行IO操作**/int socket(int family, int type, int protocol); family 常值 type 常值 protocol 常值 socket函数中的family不是任意组合都是有效的，下面是组合效果： AF_XXX 和 PF_XXX AF_前缀表示地址族，PF_前缀表示协议族 历史上曾有这样的想法：单个协议族可以支持多个地址族，PF值用来创建套接字，而AF值用于套接字地址结构。 但实际上，支持多个地址族的协议从未出现过，而且头文件 &lt;sys/socket.h&gt;中为一给定协议定义的PF值总是与此协议的AF值相等 connect函数 123456789/**T* 该函数用于建立与指定socket的连接* @param sockfd 一个未连接的socket的描述符* @param sockaddr 指向要连接的套接字的sockaddr结构体的指针* @param addrlen 上述sockaddr结构体的长度** @return 成功则返回0, 失败返回-1, 错误原因存于errno 中**/int connect(int sockfd, const struct sockaddr * servaddr, int addrlen); 如果是TCP套接字，调用connect函数将激发TCP的三路握手过程。而且仅在连接建立成功或出错时才返回 connect错误： ETIMEOUT（超时错误）: TCP客户没有收到对发出的SYN分节的响应 ECONNREFUSED（连接拒绝错误）：客户在发出SYN分节后收到RST响应 表明服务器主机在我们指定的端口上没有进程在等待与之连接（通常是服务器进程没有在运行，或者是客户端连接的时候指定了错误的端口号） 或TCP向取消一个已有的连接 或TCP接收到一个根本不存在的连接上的分节 硬错误（hard error） EHOSTUNREACH或ENETUNREACH（主机不可达或） 客户咋中间的某个路由器上引发了一个“destination unreachable”（目的地不可达）ICMP错误 并且在某个规定时间（4.4BSD规定75s）内仍未收到响应 软错误（soft error） 状态转换 TCP状态转换图 connect函数导致当前客户套接字从CLOSED状态（该套接字自从由socket函数创建以来，一直处于CLOSED状态）转移到SYN_SENT状态 如果连接成功则转移到ESTABLISHED状态 若connect失败，则该套接字不可再用，必须关闭，我们不能对这样的套接字再次调用connect函数 当循环调用函数connect为给定主机尝试各个IP地址直到有一个成功时，在每次connect失败后，都必须close当前的套接字描述符并重新调用socket bind函数 bind函数把一个本地协议地址赋予一个套接字 对于网际协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口号的组合 调用bind函数可以指定一个端口号，或指定一个IP地址，也可以两者都指定或两者都不指定 1234567891011/***** sockfd： 标识一未捆绑套接口的描述字。* my_addr： 赋予套接口的地址。sockaddr结构定义如下：* struct sockaddr&#123;* u_short sa_family;* char sa_data[14];* &#125;;* addrlen： my_addr的长度。* 返回值： 成功返回0，失败返回-1.****/int bind( int sockfd , const struct sockaddr * my_addr, socklen_t addrlen); 端口的绑定 通常用于服务器在启动的时候捆绑他们众所周知的端口 对于客户机，不调用bind绑定端口，而是在发送消息的时候由内核临时分配一个端口，这是正常的 而对于服务器而言，不绑定端口是极为罕见的 地址的绑定 进程可以把一个特定的IP地址绑定到它的套接字上，不过这个IP必须属于其所在主机的网络接口之一 对于客户端而言，绑定IP地址就相当于为该套接字上发送IP数据报指定了源IP地址 对于服务器而言，绑定IP地址就相当于限定该套接字只能接收那些目的地为这个IP地址的客户连接 给bind函数指定要捆绑的IP地址和端口号产生的结果 通配地址(wildcard address) IPv4: INADDR_ANY 123//IPv4struct sockaddr_in servaddr;servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //wildcard IPv6: in6addr_any 123//IPv6struct sockaddr_in6 serv;serv.sin6_addr = in6addr_any; //wildcard 错误 EADDRINUSE(“Address already in use”, 地址已使用) listen函数仅由TCP服务器调用，它做两件事情 当socket函数创建一个套接字时，它被假设为一个主动套接字(active socket)，也就是说，它是一个将调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，之后是内核应接收指向该套接字的连接请求。 本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数 123456/*** 将一个未连接的套接字转换成监听套接字，这样即可以用来监听来自客户端的请求了* @param sockfd 一个未连接的套接字描述符* @param backlog 等待连接队列的最大长度**/int listen( int sockfd, int backlog); 调用时机 本函数通常应该在调用socket和bind这两个函数以后，并在调用accept函数之前调用 内核为任何一个给定的监听套接字维护两个队列 未完成连接队列（incomplete connection queue）：服务器收到请求的SYN分节，并且正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态 已完成连接队列（completed connection queue）：每个已完成TCP三路握手过程的客户对应其中的一项。这些套接字处于ESTABLISHED状态 点我可查看TCP状态转换图 listen函数的第二个参数通常指的是已完成连接队列的最大长度 两个队列的建立时机 accept函数 accpet函数由TCP服务器调用，用于从已完成连接队列头返回一个已完成连接 如果已完成连接队列为空，那么进程将被投入睡眠（假定套接字为默认的阻塞方式） 12345678910/*** 在一个套接字的监听队列中取一个连接，如果没有，则死等** @param sockfd 监听描述符（在调用listen之后监听来自客户端的连接）* @param addr (可选)用来保存新连接的源端地址* @param addrlen (可选)用来保存新连接的源端地址结构的长度** @return 如果连接成功，则返回一个已连接的套接字描述符（用于和客户端通信）**/SOCKET accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 后两个参数为Value-Result参数 ==&gt; 点我查看Value-Result参数详情 fork和exec函数 fork函数12345678#include &lt;unistd.h&gt;/*** 调用fork函数创建一个新进程，与当前进程并行执行** @return 在子进程中为0，在父进程中为子进程ID，若出错返回-1**/pid_t fork(void); fork函数是Unix中派生新进程的唯一方法 调用一次，返回两次。返回值告知当前进程是子进程还是父进程 子进程可通过getppid获取父进程的id 父进程fork之前打开的所有文件描述符都会copy一份给子进程（各个描述符的引用计数加1） 两个典型用法： 创建自身副本，每个副本并行执行各自的操作 一个进程想要执行另一个程序，则fork一下，在子进程调用exec执行其它程序 exec函数1234567#include &lt;unistd.h&gt;int execl(const char* pathname, const char *arg0, ... /*(char*)*/);int execv(const char* pathname, char* const *argv[])... 存放在硬盘上的可执行程序文件能够被Unix执行的唯一方法是：由一个现有的进程调用上述6个exec函数中的一个 exec把当前进程映像替换成新的程序文件，而且该程序通常从main函数开始执行。进程ID不改变 我们称调用exec的进程为调用进程（calling process），称新执行的程序为新程序（new program） 这些函数只在出错时才返回到调用跟着，否则，控制将被传递给新程序的起始点，通常就是main函数 6个exec函数的关系 描述符引用计数 Unix系统内核为每个文件描述符（包括socket fd）维护一个引用计数,这个引用计数标识当前打开着的引用该文件或套接字的描述符的个数 当某个文件描述符或套接字描述符关闭的时候，不是直接关闭文件或套接字，而是引用计数减1，当引用计数减到0的时候执行关闭操作 需要注意的是：如果多个进程同时拥有指向同一个文件或套接字的描述符。且其中一个没有关闭（并且不再使用了），则就算其他文件描述符都关闭了，这个文件或套接字也不会关闭。就会造成内存泄露 举个栗子： 123456789101112131415161718pid_t pid;int listenfd, connfd;listenfd = Socket(...);/*fill in sockaddr_in&#123;&#125; with server's well-know port*/Bind(listenfd, ...)Listen(listenfd, LISTENQ);for( ; ; )&#123; connfd = Accept(listenfd, ...); if( (pid = Fork()) == 0 )&#123; //子进程 Close(listenfd); doit(connfd); Close(connfd); exit(0); &#125; Close(connfd); //父进程&#125; 上面的代码中，调用了fork之后，connfd和listenfd在父子进程中都有一份 所以在父进程中，只用处理listenfd，故关掉connfd 在子进程中，只用处理connfd，故关掉listenfd 试想：如果父进程中没有关闭connfd，则就算子进程执行完毕，connfd关联的套接字的引用计数还是不为0，所以一直不会释放。连接多了之后，每个连接的socket都不释放，慢慢的服务器内存就炸了。 close函数 123456789#include &lt;unistd.h&gt;/*** 通常Unix close函数也用来光比套接字，并终止TCP序列** @return 0 ==&gt; 成功* -1 ==&gt; 出错**/int close(int sockfd); 通常close函数的默认行为是把该套接字标记成已关闭，然后立即返回 被标记的套接字不能再被进程使用，即不能read/write 然后尝试将缓存或队列中所有的Message发出 接着就是正常的TCP终止序列 close函数会将读和写两个方向的连接都关掉 gesockname 和 getpeername 函数 1234567891011#include &lt;sys/socket.h&gt;/*** 返回与sockfd关联的本地协议地址**/int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);/*** 返回与sockfd关联的外地协议地址**/int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen); 其中，两个函数的后两个参数均为Value-Result参数 可以用getsockname获取内核为我们分配的地址或端口号 getsockname还可以用于获取某个套接字的协议族 上面两个函数中的第一个参数sockfd必须是已连接的套接字描述符 当服务器进程通过accept的某个进程通过调用exec执行程序时，getpeername是唯一可以用来获取对端设备地址信息的函数]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（3）—— 套接字编程简介（Sockets Introducrion）（第三章）]]></title>
    <url>%2F2018%2F01%2F04%2Fsuper_c_c%2F</url>
    <content type="text"><![CDATA[套接字地址结构（Socket Address Structures） 大多数套接字函数（socket function）都 需要一个指向套接字地址结构（socket address structure）的指针作为参数 每个协议族（protocol suite）都定义它自己的套接字地址结构 这些结构的名字均以sockaddr_开头，并以对应每个协议族的唯一后缀结尾 IPV4套接字地址结构&ensp;网际（IPV4）套接字地址结构：sockaddr_in&nbsp;-->&nbsp;定义在&lt;netinet/in.h&gt;当中12345678910111213struct in_addr&#123; in_addr_t s_addr; //32-bit ipv4 Address, network byyte ordered //32为的ipv地址，采用网络字节序&#125;；struct sockaddr_in&#123; uint8_t sin_len; //length of structure (16) sa_family_t sin_family; //AF_INET ==&gt;本地址结构是IPV4的地址结构，他属于网际协议族 in_port_t sin_port; //16-bit TCP or UDP port, 网络字节序 struct in_addr sin_addr; //32-bit ipv4 address, 网络字节序 char sin_zero[8]; //unused ==&gt; 保留位，未使用&#125; POSIX规范要求的数据类型 IPV4地址和TCP或UDP端口号都采用网络字节序（大端序）存储 IPV4地址存在两种访问方法（因为历史原因） serv.sin_addr (结构体) serv.sin_addr.in_addr_t （通常是一个无符号的32为整数） sin_zero字段未被使用，不过在填写这种结构的时候sin_zero通常被置为0。（通常的做法是，在填写之前，用bzero将整个结构体清0，再填写，可以保证未填写的部分都是0） 套接字地址结构仅在主机上使用，虽然结构体中的某些字段（例如IP地址和端口号）用在不同主机之间的通信，但是结构体本身并不在主机之间传递 通用套接字地址结构&ensp;通用套接字地址结构：sockaddr&nbsp;-->&nbsp;定义在&lt;sys/socket.h&gt;当中12345struct sockaddr&#123; uint8_t sa_len; sa_family_t sa_family; //Address family: AF_XXX value char sa_data[14]; //protocol-specific address&#125; 前面提到过，大多数套接字函数都需要一个指向套接字地址结构的指针。但是套接字函数大多支持多个协议族，也就是说在调用的时候可能传入不同协议族的地址结构指针，那套接字函数在定义的时候就必须要有一个类型，可以接收各个协议族对应的地址结构指针。 这种需求可以用void *来解决，实际上也更方便，如果用void *来定义，可以接收任意类型的指针，而且不用显示转换。但是void *实在ANSI C中提出的，而套接字函数是在ANSI C之前定义的，所以为了解决上述需求，采用了通用套接字，下面是一个套接字函数的栗子： 1234int bind(int, struct sockaddr *, socklen_t);//调用方式如下bind(sockfd, (struct sockaddr *) &amp;serv, sizeof(serv)); 通用套接字地址结构sockaddr和其他协议族各自的地址结构sockaddr_XX规定的最小size是一样的，都是16个字节 套接字函数在具体处理的时候根据sa_family字段区分不同的地址结构，对应不同的处理 IPV6套接字地址结构&ensp;IPv6套接字地址结构：sockaddr_in6&nbsp;-->&nbsp;定义在&lt;netinet/in.h&gt;当中12345678910111213141516struct in6_addr &#123; uint8_t s6_addr[16]; //128-bit IPV6 address&#125;;#define SIN6_LEN //require for compile-time testsstruct sockaddr_in6 &#123; uint8_t sin6_len; //length of this struct, 大小为28个字节 sa_family_t sin6_family; //AF_INET6 in_port_t sin6_port; //传输层端口，网络字节序 uint32_t sin6_flowinfo; //flow information, undefined struct in6_addr sin6_addr; //IPV6 address, 网络字节序 uint32_t sin6_scope_id; //set of interfaces for a scope&#125; 值-结果参数（Value-Result Argument） 一个参数，当函数调用时，其作为一个值从函数外传入函数内，当函数返回时，该参数又存储了函数执行的部分结果，这种类型的参数称为value-result参数 value-result参数总是以引用/指针的方式传递（只能用地址传递的方式，如果用值传递方式获取不到函数的返回信息） 上文曾提到过，当往一个套接字函数传递地址结构的时候，该结构总是以引用的方式传递（即传递地址结构的指针）。该结构的长度也作为一个参数来传递，不过其传递的方式可能是传值，也可能是传指针，具体的传递方式取决于该结构的传递方向：是从进程到内核，还是从内核到进程 从进程到内核传递套接字地址结构 涉及的函数有：bind、connect、sendto 传递结构长度的时候传值就好了 举个栗子： 12345struct sockaddr_in serv;/*fill in serv&#123;&#125;*/connect(sockfd, (SA *) &amp;serv, sizeof(serv)); 图示： 从内核到进程传递套接字地址结构 涉及的函数有：accpet、recvfrom、getsockname、getpeername 传递结构长度的时候传入一个指向socklen_t的指针（而不是int，POSIX规范建议将socklen_t定义为uint32_t） 举个栗子： 12345struct sockaddr_un cli;socklen_t len;len = sizeof(cli);getpeername(unixfd, (SA *) &amp;cli, &amp;len); 图示： 当函数被调用时，结构大小是一个值（value），它告诉内核该结构的大小，这样内核在写该结构的时候不至于越界；当函数返回时，结构大小又是一个结果（result），它告诉进程内核在该结构中究竟存储了多少信息。 字节排序函数（Byte Ordering） 大端和小端（big-endian and little-endian） 小端：低字节存储在起始地址 大端：高字节存储在起始地址 举个例子：123456780x0102//从左到右为内存增大方向//在大端系统中存储00000001 00000010//在小端系统中存储00000010 00000001 测试主机是大端还是小端的实践 –&gt; click_me123./byteorderx86_64-unknown-linux-gnu: little-endian 网络字节序 不同的机器可能采用不同的存储方式（大端/小端），为了统一，便为网际协议约定了一个网络字节序 网际协议使用大端字节序来传送多字节整数 由于不同主机的差异性，便需要有一些函数来进行网络字节序和主机字节序的转换 字节转换函数12345678910111213141516171819202122232425#include &lt;netinet/in.h&gt;/*** host to network short* 将主机字节序的16位短整型转换为网络字节序的16位短整型**/uint16_t htons(uint16_t host16bitvalue);/*** host to network long* 将主机字节序的32位整型转换为网络字节序的32位整型**/uint32_t htonl(uint32_t host32bitvalue);/*** network to host short* 将网络字节序的16位短整型转换为主机字节序的16位短整型**/uint16_t ntohs(uint16_t net16bitvalue);/*** network to host long* 将网络字节序的32位整型转换为主机字节序的32位整型**/uint32_t ntohl(uint32_t net32bitvalue); 事实上，在64为的系统中，尽管长整数占64位，htonl和ntohl函数操作的仍然是32位值 字节操纵函数字节操作函数和有两组，本书中只用到了bzero 源自Berkeley的函数（b开头的字节操纵函数）1234567891011121314151617#include &lt;strings.h&gt;/*** 将以dest为起始的目标串的前nbytes个字节置为0**/void bzero(void *dest, size_t nbytes);/*** 将dst中的前nbytes个字节拷贝到src串中**/void bcopy(const void *src, void *dst, size_t nbytes);/*** 比较ptr1和ptr2串的前n个字节* @return 若相等则返回0， 否则返回非0**/void bcmp(const void *ptr1, const void *ptr2, size_t nbytes); ANSI C函数（mem开头的字节操纵函数）123456789101112131415161718192021#include &lt;string.h&gt;/*** 把dest串的前len个字节置为c**/void *memset(void *dest, int c, size_t len);/*** memcpy类似bcopy，但是两个指针的位置时候是相反的** PS：当dest串和src串重叠时，bcopy可正常处理，memcpy的处理结果不可知，此时改用memmove函数**/void *memcpy(void *dest, const void *src, size_t nbytes);/*** 比较两个串的前nbytes个字节* @rerurn 0 相等* &gt;0 第一个不相等字节，ptr1 &gt; ptr2* &lt;0 第一个不相等字节，ptr1 &lt; ptr2**/void *memcmp(const void *ptr1, const void *ptr2, size_t nbytes); 之前的文章提到过有一个叫bzero宏的东西。其实是因为笔者的系统不是源自Berkeley的，所有没有bzero函数。但是Steven考虑的比较全面，为没有bzero函数的系统定义了一个bzero宏，间接调用memset函数，但是同样可以实现bzero的效果。 地址转换函数 地址转换函数在ASCII字符串和网络字节序的二进制值之间转换网际地址 inet_aton、inet_addr、inet_ntoa在点分十进制数串（例如“192.168.1.1”）与它长度为32位的网络字节序二进制值之间转换IPv4地址。 两个比较新的函数，inet_pton和inet_ntop对于IPv4和IPv6都适用 inet_aton、inet_addr 和inet_ntoa函数12345678910111213141516#include&lt;arpa/inet.h&gt;/*** 将strptr所指c字符串转换成一个32位的网络字节序二进制值，并通过addrptr指针来存储**/int inet_aton(const char *strptr, struct in_addr *addrptr);/*** 将strptr所指c字符串转换成一个32位的网络字节序二进制值, 并返回**/in_addr_t inet_addr(const char *strptr);/*** 将一个32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。**/char *inet_ntoa(struct in_addr inaddr); inet_addr 被废弃 inet_addr函数出错时返回INADDR_NOE(通常是一个32位均为1的值) 这意味着该函数不能处理“255.255.255.255”，因为它的二进制值和INADDR_NONE的值是一样的，被用来指示函数执行失败 inet_ntoa函数返回值所指向的串驻留在静态内存当中，着意味着该函数是不可重入的 上面这些函数至支持IPv4，如果要支持IPv6，使用下面介绍的两个函数 inet_pton 和 inet_ntop 函数1234567891011121314151617181920#include &lt;arpa/inet.h&gt;/*** 尝试转换由strptr所指的字符串，并通过addrptr指针存放二进制结果** @return 1 ==&gt; 转换成功* 0 ==&gt; 输入的不是有效表达式* -1 ==&gt; 转换出错**/int inet_pton(int family, const char*strptr, void *addrptr);/*** 与inet_pton进行相反的转换，从数值格式（addrptr）转换到表达式格式（strptr）。* @param len 指定目标存储单元的大小，以免该函数溢出调用者的缓冲区* @param strptr 用来存储目标串，如果执行成功，返回值即为这个指针* （不能传递空指针，调用这必须为目标存储单元分配内存，并指定其大小）* @return NULL ==&gt; 失败* strptr ==&gt; 成功**/const char *inet_ntop(int family, void *addrptr, char *strptr, size_t len); 两个函数的family参数可以是AF_INET或AF_INET6。如果以不被支持的地址族作为family参数。这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT sock_ntop和相关函数 在使用inet_ntop的时候，对于IPv4和IPv6的调用方法不同（这使得我们的代码和协议相关了）： 1234567//IPv4struct sockaddr_in addr;inet_ntop(AF_INET, &amp;addr.sin_addr, str, sizeof(str));//IPv6struct sockaddr_in6 addr6;inet_ntop(AF_INET6, &amp;addr6.sin6_addr, str, sizeof(str)); 所以Steven针对上述问题写了下面这么个封装函数 123456789#include "unp.h"/*** 同时支持IPv4和IPv6版本的inet_ntop** @return 成功 ==&gt; 非空指针* 出错 ==&gt; NULL**/char *sock_ntop(const struct *sockaddr, socklen_t addrlen); sock_ntop的实现和其它相关函数此处不做详细讨论，有兴趣可以查看Steven的《Unix 网络编程 卷1》 readn, writen 和 readline 函数 12345678910111213141516#include "unp.h"/*** 从一个描述符中读n字节**/ssize_t readn(int filedes, void *buff, size_t nbytes);/*** 往一个描述符里写n个字节**/ssize_t writen(int filedes, const void *buff, size_t nbytes);/*** 从一个描述符中读文本行，以字节为单位**/ssize_t readline(int filedes, void *buff, size_t maxlen); 上面三个函数对read和write操作可能发生的EINTR错误做了处理，是比较安全的读写函数]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（2）—— 传输层：TCP、UDP、SCTP（第二章）]]></title>
    <url>%2F2018%2F01%2F03%2Fsuper_c_b%2F</url>
    <content type="text"><![CDATA[总图（Big Picture） UDP UDP应用程序将数据封装到UDP数据报，，并将其写到UDP socket。进而封装成IPV4或IPV6数据报（datagram），然后发送到目的地 UDP提供的是无连接的服务（connectionless service） 每个UDP数据报都有一个长度，如果一个数据报正确地到达目的地，那么数据报的长度将随数据一道传递给接收端应用程序 RFC 768 [Postel 1980] TCP 面向连接（Connection-oriented） 提供可靠传输（Reliable） TCP通过给每个字节关联一个序列号（sequence）对所发送的数据进行排序（sequencing） TCP提供流量控制（flow control）==&gt; 控制接收端收包的速率 全双工（full-duplex） TCP连接的建立和终止 三路握手 ———— Three-Way Handshake (SYN, ACK) 服务器通过socket，bind，listen创建一个监听socket，并调用accpet准备接受外来的连接（这些工作要在客户端请求来临之前做好）。 客户端通过socket函数创建一个未连接的socket，再调用connect尝试连接到服务器（此时客户端阻塞，等待服务器响应）。此时会向服务器发送一个SYN包（表明客户端欲向服务器申请服务），等待服务器的确认。 服务器收到SYN包，则向客户端发送一个ACK（告诉客户端，请求我已经收到）。同时发送一个SYN（通知客户端服务器需要知道客户端是否收到回复，收到则请回一个ACK） 客户端收到服务器发回的ACK和SYN之后，connect函数返回（表示连接服务器成功），并向服务器回一个ACK（告知服务器我已经收到你的回复） 服务器收到客户端的ACK以后accept函数返回（此时连接正式建立，可以开始后通信） ACK如果不捎带数据的话，是不占序列号的 SYN占一个序列号 四路终止 ———— Four-Way Termination (FIN, ACK) 客户端调用close（任意一端都可以发起终止，此处以客户端发起为例，发起终止的一端称为执行主动关闭）。接着向服务器发送一个FIN，表示数据发送完毕 服务器接收到FIN后回复一个ACK（此时服务器称为执行被动关闭的一端），同时服务器的read函数会读到一个EOF，导致read函数退出 一段时间后，服务器也调用close，向客户端发送一个FIN 客户端收到FIN以后回复一个ACK FIN占一个序列号 在被动关闭一端收到FIN到其调用close函数之间的间隙，称为半关闭状态（half-close），在这段时间内理论上仍然有发送数据的可能（但是通过close方式关闭的话，时无法再进行通信的，因为close会同时关闭写一端和读一端，后面接收shutdown就可以只关闭写或读） 当一个Unix进程无论自愿（调用exit或main函数返回）还是非自愿（收到一个终止本进程的信号）的终止时，所有打开的描述符都将被关闭，这也导致主机向仍然打开的任何TCP连接上发出一个FIN（对于那些描述符只被这个终止的进程持有的连接而言） TCP状态转换图 上述状态转移图中的细线表示的是可能执行的路线。粗线和虚线表示的是TCP服务器和客户端正常情况（或说大多数情况）走的状态转移路线。 当发生错误，或遇到一些比较凑巧的事件，就可能走细线指向的转移路线 举例来说：途中有一条细线是SYN_SENT ——&gt; SYN_RCVD的 这种情况可能是客户端发出了一个SYN到服务器，并希望服务器回一个ACK和一个SYN 但是由于一些不可预知的错误，服务器返回的SYN和ACK只有SYN回到了客户端，而ACK则延迟了或丢了 这个时候客户端的状态就转移到了SYN_RCVD。之后一旦收到ACK（可能是服务器发送的消息丢包后重传，也可能是延迟的消息到达了），则客户端的状态可正常转移到ESTABLISHED状态 TCP的限制 TCP同时提供可靠数据传输和严格的有序数据分发。然而有一些应用程序需要可靠数据传输，但是不需要顺序维护，而另一些应用过程序只需要部分有序即可。 TCP这种面向数据流的传输方式有时候是不方便的。应用程序必须添加自己的记录标记。 TCP套接字的范围有限，使得为多宿主主机提供高可用数据传输能力的任务变得复杂 容易受到拒绝服务攻击，例如SYN攻击 这些限制影响公共交换电话网的IP性能 端口号（Port Numbers） 众所周知（well-know）的端口：0 ~ 1023 已注册端口：1024 ～ 49151 动态或私有端口：49152 ～ 65535 TCP端口号与并发服务器]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（1）—— Introduction（第一章）]]></title>
    <url>%2F2018%2F01%2F02%2Fsuper_c_a%2F</url>
    <content type="text"><![CDATA[Introduction A Simple Daytime Client A Simple Daytime Server A Simple Daytime Client Steven源码地址 笔者加注释源码地址 功能： 实现向服务器发起一个TCP连接，请求时间信息，并将接收到的信息打印在控制台上 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;unp.h&gt;int main(int argc, char** argv)&#123; /*sockfd 套接字描述符，客户端通过该描述符与服务器进行通信（它指示一个与服务器的连接）*/ int sockfd, n; char recvline[MAXLINE + 1]; /*接收缓存*/ /*服务器地址，用来保存服务器的地址信息（该结构体专门保存IPV4地址），包括ip和端口*/ struct sockaddr_in servaddr; /*如果输入参数不够，则报错并退出*/ if(argc != 2) err_quit("usage: daytimecli &lt;IPAddress&gt;"); /*通过socket函数创建一个套接字，创建失败则退出*/ if( (sockfd = socket(AF_INET, SOCK_STREAM, 0) ) &lt; 0) err_sys("socket error"); /*清0*/ bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; /*指定协议族为网际协议族*/ servaddr.sin_port = htons(13); /*指定端口为13*/ /*将用户从命令行输入的IP存到servaddr中，如果用户输入的格式不正确*/ /*则该函数会返回小于0的错误信息，此时退出应用程序*/ if(inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0) err_quit("inet_pton error for %s", argv[1]); /*连接到servaddr指向的服务器，连接失败则退出*/ if(connect(sockfd, (SA *)&amp;servaddr, sizeof(servaddr)) &lt; 0) err_sys("connect error"); /*读取服务器发回的信息*/ while( (n = read(sockfd, recvline, MAXLINE)) &gt; 0 )&#123; recvline[n] = 0; /*输出到控制台*/ if(fputs(recvline, stdout) == EOF) err_sys("fputs error"); &#125; if(n &lt; 0) err_sys("read error"); exit(0);&#125; struct sockaddr_in 组成 12345678910111213141516/*** 下面是三个struct sockaddr_in的主要成员，数据的具体类型不同的系统不同，* 可以大概理解成下面这样，具体的定义可以查看源码**/unsigned short sin_family; /*源码中并不是直接表示成这样，用了几层宏定义，不过在*/ /*笔者的电脑上，其最原始的定义为 unsigned short*/u_16 sin_port; /*u_16表示无符号16位的数，范围为0~65535*/struct in_addr sin_addr;/*** struct in_addr 的结构如下**/struct in_addr&#123; __be32 s_addr; /*__be32 通常为 unsigned int(32位)*/&#125; 用于存储IPV4的地址信息，包括ip，端口，协议族（IPV4属于 AF_INET） socket() 百度百科–&gt; click_me click me for detail 原型123456789101112131415/*** 该函数用于创建一个socket套接字* @param domin 协议族/地址族* @param type 套接字的类型* SOCK_STREAM ==&gt; TCP套接字* SOCK_DGRAM ==&gt; UDP套接字* SOCK_RAW ==&gt; 原始套接字* SOCK_PACKET ==&gt; 可用于链路层访问控制* @param protocol 指定协议** @return 返回一个socket描述符 sockfd* sockfd &lt; 0 ==&gt; 创建失败* sockfd &gt;= 0 ==&gt; 创建成功，之后可用该sockfd进行IO操作**/int socket(int domain, int type, int protocol); 需注意的是，socket函数的后两个参数不能随意组合。比如在type = SOCK_STRAM 的时候 protocol ≠ IPPROTO_UDP。（当第三个参数为0的时候，会自动选择第二个参数类型对应的默认协议） bzero 原型 1234/*** bzero为一个宏函数，实际上调用的是memset**/#define bzero(ptr, n) memset(ptr, 0, n) void *memset(void *s, int ch, size_t n);** bzero(ptr, n) ==&gt; 以ptr所指为起始，将紧接着的n位置成 0 (可以达到清0的效果) htons() 百度百科–&gt; click_me 原型1234/*** 将一个无符号短整型从主机字节序转网络字节序**/u_short htons(u_short hostshort); 网络字节序统一为 大端（big-endian）序，而现在大部分主机采用的是小端系统，也有机器采用大端系统。为了统一，调用这个函数之后均采用大端序（协议统一） inet_pton() 百度百科–&gt; click_me 原型：12345678910111213/*** 将“点分十进制” --&gt; “二进制整数”** @param af address family(地址族)* @param src 指向一个字符串，这个字符串为一个点分十进制的串，例如："192.168.1.1"* @param dst 指向一个数据结构，用来存储转换后的结果* 如果af = AF_INET, 即为ipv4地址转换，则函数会将结果放在一个in_addr结构体中* 如果af = AF_INET6, 即为ipv6地址转换，则函数会将结果放在一个in_addr6结构体中** @return 如果函数出错则返回一个负值，并将errno置为EAFNOSUPPORT。* 如果参数af指定的地址族和src格式不对，则返回0**/int inet_pton(int af, const char *src, void *dst); inet_pton同时支持和IPV4和IPV6 connect() 百度百科–&gt; click_me click me for detail 原型：123456789/*** 该函数用于建立与指定socket的连接* @param sockfd 一个未连接的socket的描述符* @param sockaddr 指向要连接的套接字的sockaddr结构体的指针* @param addrlen 上述sockaddr结构体的长度** @return 成功则返回0, 失败返回-1, 错误原因存于errno 中**/int connect(int sockfd, const struct sockaddr * servaddr, int addrlen); 为了书写简便，原书作者对上述函数的第二个参数做了一层宏定义：1#define SA struct sockaddr 所以在上面的daytimecli.c 中调用connect的时候，用SA简化了书写，实际上 SA = struct sockaddr1connect(sockfd, (SA *)&amp;servaddr, sizeof(servaddr) read() 百度百科–&gt; click_me 原型：123456789101112/*** 从fd所指向的文件中传送count个字节到buf中** @param fd 关联一个文件的描述符（可以是socket fd）* @param buf 指向一个数组的指针，用做缓存，存取从fd中读出的数据* @param count 读取的大小** @return 返回值为实际读取到的字节数* 如果返回0，表示已到达文件尾或无可读取的数据。* 错误返回-1,并将根据不同的错误原因适当的设置错误码**/ssize_t read(int fd, void *buf, size_t count); 如果read函数中传入的文件描述符为sockfd，则表示从网络中读取count字节的数据并存到buf中。 read函数是一个阻塞函数，如果没有读够count个字节，会一直在那边死等，下面两种情况下read函数和的阻塞状态会解除 如果一个信号的到来，会导致主线程因为去执行信号的回调函数，而解除阻塞函数的阻塞状态。并将errno置成EINTR。表示因为信号中断而退出。（不过现在的系统好像做了优化处理，即便定义了某些信号的处理函数，当该信号到来时，该回调会执行，但同时却不会引发中断错误） 还有就是收到EOF（文件结束指针）。如果是tcp socket，则当对方关闭了写一端的时候，会向本机发送一个FIN，标识对方已经发完数据了。此时read的阻塞状态便会解除。同样的，如果对方给调用close函数关闭了socket，read函数也会解除阻塞（关闭socket相当于写端和读端都关闭了） 对比 write fputs() 百度百科–&gt; click_me 原型：123456789/*** 向指定的文件中写入一个字符串** @param ptr 指向待写入的字符串* @param stream 指向目标文件的一个文件指针（文件指针由fopen获得）** @return 函数返回值为一般非负整数，如果返回EOF(常值，为-1)，则标识读到文件尾**/int fputs(const char* ptr, FILE* stream) IPV6版本 上面的程序是支持IPV，点击此处有IPV6版本的代码 一些关于教材的扩展介绍 包裹函数（wrapper function） linux系统内核的c语言函数名都是小写的，如果之后的代码中出现了大写开头的函数，则表示是原书作者对内核函数做了一层包装，加了一些错误判断等，使用起来更加方便，这些即作者所说的包裹函数（wrapper function） 举个栗子：123456int Socket(int family, int type, int protocol)&#123; int n; if( (n = socket(family, type, protocol)) &lt; 0 ) err_sys("socket error"); return(n);&#125; 上面这个函数便是作者对内核的socket函数做了一层封装，功能和socket函数时候一样的，只不过在出错的时候，这个函数已经帮你将错误打印出来了，如果不需要什么其它特殊处理的话。在使用Socket函数的时候变可以不需要错误处理了 下面展示会了没有使用包裹函数和使用了包裹函数的区别123456//不使用包裹函数if( (sockfd == socket(AF_INET, SOCK_STREAM, 0) ) &lt; 0) err_sys("socket error");//使用包裹函数Socket(AF_INET, SOCK_STREAM, 0); 原书作者定义的包裹函数大致符合下列规则 名字和被包裹的函数一致，只是首字母大写 函数的参数数量和意义和被包裹的函数一致 函数的行为与被包裹的函数保持一致 Unix errno 值 error 为一个全局变量 当Unix中的函数执行过程中有错误发生，则errno就被置为一个指明该错误类型的正值，而函数本身通常返回-1 A Simple Daytime Server Steven源码地址 笔者加注释源码地址 功能： 实现在13号端口上监听来自任意IP的请求，并向客户端输出时间信息 没做并发处理，一次只能向一个客户端提供服务 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;unp.h&gt;#include &lt;time.h&gt;int main(int argc, int argv)&#123; int listenfd, connfd; struct sockaddr_in servaddr; char buff[MAXLINE]; time_t ticks; //调用包裹函数，创建一个socket listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(13); //指定socket的地址为INADDR_ANY，标识监听来自所有地址的请求 servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //将socket绑定到指定的端口，只在指定的端口监听来自客户端的请求 Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr)); //调用Lisen可将socket转换成一个监听套接字，监听套接字可用于监听其他客户端的请求 Listen(listenfd, LISTENQ); for( ; ; )&#123; //accpet函数是一个阻塞函数，死等一个连接请求。 //当监听到一个请求，就返回一个已连接描述符（该描述符用于与新连接的那个客户端通信） connfd = Accept(listenfd, (SA *) NULL, NULL); //获取当前系统的时间 ticks = time(NULL); //将当前时间输出到buff数组中 snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&amp;ticks)); //将buff中的数据发给客户端 Write(connfd, buff, strlen(buff)); //关闭socket连接 Close(connfd); &#125;&#125; bind() 百度百科–&gt; click_me click me for detail 原型：1234567891011/***** sockfd： 标识一未捆绑套接口的描述字。* my_addr： 赋予套接口的地址。sockaddr结构定义如下：* struct sockaddr&#123;* u_short sa_family;* char sa_data[14];* &#125;;* addrlen： name名字的长度。* 返回值： 成功返回0，失败返回-1.****/int bind( int sockfd , const struct sockaddr * my_addr, socklen_t addrlen); bind函数把一个本地协议地址赋予一个套接字，通常在connect或listen函数调用前使用 listen() 百度百科–&gt; click_me click me for detail 原型123456/*** 将一个未连接的套接字（主动套接字）转换成监听套接字（被动套接字），这样即可以用来监听来自客户端的请求了* @param sockfd 一个未连接的套接字描述符* @param backlog 等待连接队列的最大长度**/int listen( int sockfd, int backlog); 函数的第二个参数指定的是系统内核允许在这个监听描述符上排队的最大客户连接数（内核为listen维护两个队列，第二个参数指定的至一般认为是已连接队列的上限） 不是允许的最大并发数 在监听描述符上排队的客户 ==&gt; 客户的请求被listen到了，但是还没有被accept处理，那么这个客户的请求便在该监听描述符上排队，等待被accpet 通常情况下，accpet以后就调用新线程或新进程处理了，所以很快就可以再accept，所以一般在监听描述符上排队的客户数不会很多 accept() 百度百科–&gt; click_me click me for detail 原型：12345678910/*** 在一个套接字的监听队列中取一个连接，如果没有，则死等** @param sockfd 监听描述符（在调用listen之后监听来自客户端的连接）* @param addr (可选)用来保存新连接的源端地址* @param addrlen (可选)用来保存新连接的源端地址结构的长度** @return 如果连接成功，则返回一个已连接的套接字描述符（用于和客户端通信）**/SOCKET accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 上述函数的第二、三个参数为值-结果（value-result）参数 即在函数调用的时候，可以通过这两个参数向函数内部传递内容 同时在函数调用结束的时候，可以通过这两个参数获取到返回信息 accept函数就将新连接的地址信息保存在了后两个参数中（如果不需要可以直接传NULL） accpet为每个连接到本服务器的客户返回一个全新的描述符（唯一标识一个客户） snprintf() 百度百科–&gt; click_me 原型：1234/*** 向str指向的区域格式化输出size个字节的数据**/int snprintf(char *str, size_t size, const char *format, ...) 用法和printf基本相同 不同的是，printf是向控制台打印，而snprintf是通过地址指针，向目标区域输出 write() 百度百科–&gt; click_me 原型：1234/*** 将buf中count个字节的数据输出到fd标识的文件中**/ssize_t write (int fd,const void * buf,size_t count); 对比read close() click me for detail 关闭与客户端的连接。该调用引发正常的TCP连接终止序列：每个方向上（读方向，写方向）发送一个FIN，每个FIN又各自的对端确认]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（十一）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88k%EF%BC%89%2F</url>
    <content type="text"><![CDATA[设计原则 （understanding） 面向接口编程 依赖倒置 组合优于继承 单一职责 开放——封闭 Liskov替换 面向接口编程(Program to An interface, Not An Implementation) 使用“接口继承”，而非“实现继承” 接口关注对象的概貌，将对象中“不变”的信息抽象出来，不涉及细节，因此是“稳定”的 Example: 面向接口的好处： Client只需关注如何进行业务活动（如：驾驶），而不必关心其使用对象的具体实现 一个对象可以很容易地被（实现了相同接口的）另一个对象所替换 对象间的连接不必硬绑定（hard wire）到一个具体类的对象上，因此增加了灵活性 松散耦合，增加了重用的可能性 依赖倒置（Dependency Inversion Principle） 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 依赖倒置原则使细节和具体实现都依赖于抽象，抽象的稳定性决定了系统的稳定性 Example： 组合优于继承 （Favor Composition Over Inheritance ） 继承：OO特点之一 组合：任务委托 二者：都是面向对象设计中用于重用的方法 开发早期，继承经常被过度使用 使用继承的问题： 组合优于继承－设计改进 优先使用组合可获得重用性与简单性更佳的设计 配合使用继承，扩充可用的组合类集，加大重用的范围&lt;% img /img/se_97.jpg %&gt; 何时使用继承？ 子类表达了“是一个父类的特殊类型”，而非“是一个由父类所扮演的角色” 子类的一个实例永远不需要转化为其它类的一个对象 子类是对其父类的职责进行扩展，而非重写或废除（LSP） 单一职责——Single responsibility Principle 所谓职责，可理解为功能，就是设计的类功能应该只有一个，而不是两个或更多 职责也可以理解为引起变化的原因：当一个类中有两个以上的变化方向，会产生过多的变化点 Example: 开放封闭原则——Open For Extension, Yet Closed For Modification (OCP) OCP认为应该试图设计出永远也不需要改变的模块 可以添加新代码来扩展系统的行为；不能对已有的代码进行修改 OCP模块标准 模块的行为可以被扩展，以需要满足新的需求 模块的源代码是不允许进行改动的 一个软件系统的所有模块不可能都满足OCP，但是应该努力最小化这些不满足OCP的模块数量 OCP法则是OO设计的真正核心 符合该法则便意味着最高等级的复用性和可维护性 一个OCP栗子： 改进 Liskov替换原则 使用指向基类（超类）的引用的函数，必须能够在不知道具体派生类（子类）对象类型的情况下使用它们 ==&gt; 在任何父类出现的地方，都可以用子类替换（包括逻辑上和语义上） LSP是根据对象的“多态”而得出的 但在实现子类时必须要谨慎对待，以确保不会无意中违背了LSP 一个违背Liskov原则的栗子 对于下面的代码：12345678910111213141516171819202122232425262728293031//Rectangle类声明如下public class Rectangle&#123; protected double width; protected double height; public Rectangle()&#123;&#125; public void setWidth(double w)&#123; this.width = w; &#125; public void setHeight(double h)&#123; this.height = h; &#125; public double area()&#123; return width * height &#125;&#125;//直接用Rectangle类, 输出200Rectangle rect = new Rectangle();rect.setWidth(10);rect.setHeight(20);System.out.println(rect.area());//将Rectangle换成其子类Square，输出为400Rectangle rect = new Square(0);rect.setWidth(10);rect.setHeight(20);System.out.println(rect.area()); LSP的保证 LSP表明了ISA关系是与对象行为有关的 一个子类型不得具有比基更多的限制，这是因为可能对于基类型的某些使用是合法的，但是会因为违背子类型的其中一个额外限制，从而违背了LSP 一个简单的做法是不要将基类中子类不需要的函数暴露给子类 设计模式（understanding） Abstract Factory（抽象工厂） PROTOTYPE（原型模式） Singleton（单例模式） Adapter（适配器模式） 抽象工厂（Abstract Factory） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 原型模式（Prototype） 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 缺点是每一个类都必须配备一个克隆方法 其实是将product和factory功能合二为一了 单例模式（Singleton） 保证一个类仅有一个实例，并提供一个访问它的全局访问点 解决的主要是性能问题，而非耦合（变化）的问题 适配器模式（Adapter） 把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作 适配类可以根据参数返还一个合适的实例给客户端 桥梁模式（Bridge） 将抽象部分与它的实现部分（行为）分离，使它们都可以独立地变化 解决2个方面的变化问题：抽象与实现（行为）。即一个类中多个方向的变化问题]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（十）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88j%EF%BC%89%2F</url>
    <content type="text"><![CDATA[要求OO设计步骤，结构优化准则，对照架构模式，设计原则和设计模式 面向对象的设计准则 模块化 抽象 信息隐藏 弱耦合 强内聚 可重用 启发规则 设计结果应该清晰易懂 提高软件可维护性和可重用性重要措施 用词一致 使用已有的协议（重载） 减少消息模式的数目 避免模糊的定义 一般—特殊结构的深度应适当 应该使类等级中包含的层次数适当 设计简单的类 尽量设计小而简单的类，便于开发管理 避免包含过多的属性 有明确的定义 尽量简化对象之间的合作关系 不要提供太多服务（保持适当内聚的基础上） 使用简单的协议 使用简单的服务 把设计变动减至最小（结构稳定） 架构模式（Architecture Patterns）An architectural pattern is a proven structural organization schema for software systems（架构模式是指用于软件系统中经实践证明的机构化的组织格式化） 层次、CS、MVC、Pipe-Filter、Master-slave 层次架构 eg: 网络协议（OSI/ISO 七层模型） 每层向上层提供服务 越低层越稳定 职责分离，每层可独立开发 提供给上层高的抽象接口不容易写 低层可能做一些高层用不到的功能 MVC架构 model: 核心功能和数据（是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据） view： 向用户展示信息（是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的） controller： 处理用户的输入（是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据） 用于交互式系统 控制流程 CS架构 Server组件向多个client提供服务 客户端通过向服务器请求得到服务 请求是在进程和机器边界上完成的 采用进程间通信机制 而层级架构则是横跨进程和机器边界 Server通常是长期运行的，拥有监听来自Client的请求 Examples： Remote DB access （远程数据库接入） Remote file systems（远程文件系统） Multi-tier information system（多层信息系统） Web applications（网页应用） 通常在单独的线程中处理请求 Server和Client的交互通常包含在一个session（会话）中 Stateless servers（无状态的服务） 会话状态由client保存（例如：cookie机制） 每个请求都带上client保存的会话状态信息 Stateful servers（有状态服务） 会话状态由Server端保存 所有的Client的请求都关联到其对应的client-id Master-slave（主从模式） 主从模式支持容错和并行计算 主组件将工作分配给若干个从组件，从组件各自计算，最后主组件从这些从组件返回的结果中计算最终的结果 Examples: Process control(进程控制) Embedded systems(嵌入式系统) Large-scale parallel computations（大规模并行计算） Fault tolerant systems(容错系统) ==&gt; 比如磁盘阵列（可以用其中一块或多块硬盘做奇偶校验，可以达到容错的效果） 执行流程： 分析： 一旦Master挂掉，整个系统也就挂了 从组件之间是独立的，不共享状态 从组件之间可以并行运行 对于硬实时系统（对延迟很敏感），主从组件之间的通信延迟可能是一个问题 要解决的问题必须是可分解的 应用领域： 容错 并行计算 精确计算 Pipe-Filter(管道过滤器模式) 该架构适用于处理数据流的系统 每一个处理都封装在一个过滤器组件当中 数据通过相邻过滤器之间的管道（pipe）进行传输 pipe主要负责处理缓存和同步 Examples： Compilers（编译器） Unix shell commands 分析： 很容易插入新的过滤器 过滤器可重用 过滤器可以被独立开发 潜在数据转换开销 输入可以来自不同的数据源，输出也可以输出到不同的地方 天然的并行处理 过滤器间不共享状态 不适用于交互式系统，适用于批处理系统 Java中的管道 InputStream in = new BufferedInputStream(new DataInputStream(System.in)) Broker（代理模式） Peer-to-peer（P2P模式和） Event-bus Blackboard]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（九）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88i%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述要求： 掌握OO分析的方法和步骤，业务，能够使用UML图进行分析建模（类图、用例图、状态图、顺序图等） 面向对象分析是是辈出问题域内的对象，并分析它们相互间的关系，最终建立起问题域的简洁、精确、可理解的正确模型 在用面向对象观点建立起的三种模型中，对象模型（类图）是 最基本、最重要、最核心的 面向对象分析的过程面向该对象分析，就是抽取和整理用户或需求并建立问题域精确模型的过程 用用例图捕获需求 基于用例图构件类图 3个子模型5个层次 3个子模型：对象模型，动态模型，功能模型 5个层次 主题层（通常对应包的划分） 类与对象层 结构层 属性层 服务层 大体流程 寻找类与对象 识别结构 识别主题 定义属性 建立动态模型 建立功能模型 定义服务 需求陈述 通常，需求陈述的内容包括：问题范围，功能需求，性能需求，应用环境及假设条件等。总之，需求陈述应该阐明“做什么”而不是“怎样做” 描述用户的需求而不是提出解决问题的方法 应该避免对设计策略施加过多的约束，也不要描述系统的内部结构，这样做将限制实现的灵活性 对系统性能及系统与外界环境交互协议的描述，是合适的需求 此外，对采用的软件工程标准、模块构造准则、将来可能做的扩充以及可维护性要求等方面的描述，也都是适当的需求。 建立对象模型 确定类与对象 找出和候选的类与对象 用自然语言书写的需求陈述为依据，把陈述中的名词作为类与对象的候选者 用形容词作为确定属性的线索 把动词作为服务(操作)的候选者 筛选出正确的类与对象 冗余、无关、笼统、属性、操作、实现.. 确定关联 初步确定关联 大多数关联可以通过直接提取需求陈述中的动词词组而得出 通过分析需求陈述，还能发现一些在陈述中隐含的关联 筛选 已删去的类之间的关联 与问题无关或应在实现阶段考虑的关联 瞬时关联 三元关联 派生关联 完善 正名 分解 补充 标明重数 划分主题 在开发大型、复杂系统的过程中，为了降低复杂程度，习惯于把系统再进一步划分成几个不同的主题，也就是在概念上把系统包含的内容分解成若干个范畴 确定属性 分析 属性的确定既与问题域有关，也和目标系统的任务有关 应该仅考虑与具体应用直接相关的属性，不要考虑那些超出所要解决的问题范围的属性 在分析过程中应该首先找出最重要的属性，以后再逐渐把其余属性增添进去 在分析阶段不要考虑那些纯粹用于实现的属性 选择 认真考察经初步分析而确定下来的那些属性，从中删掉不正确的或不必要的属性 误把对象当作属性 把链属性误作为属性 把限定误当成属性 误把内部状态当成了属性 过于细化 存在不一致的属性 识别继承关系 反复修改 建立动态模型 第一步，是编写典型交互行为的脚本 第二步，从脚本中提取出事件，确定除服每个事件的动作对象以及接受事件的目标对象（画出事件跟踪图） 第三步，排雷事件发生的次序，确定每个对象可能有的状态及状态之间的转换关系，并用状态图描绘它们 建立功能模型 画出基本的系统模型图 画出功能级数据流图 EG: 对象模型参考： 动态模型参考 脚本 事件跟踪图 功能模型参考]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（八）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88h%EF%BC%89%2F</url>
    <content type="text"><![CDATA[要求掌握UML图的绘制方法，需求规范概述Unified Modeling Language(UML) 统一建模语言 1977.11.17，OMG采纳 ==&gt; ISO标准 ==&gt; 事实的工业标准 元元模型（meta_metamodel）层 由UML中最基本的元素“事物（thing）”组成 元模型（metamodel）层 这一层的每个概念都是元元模型中“事物”概念的实例 模型（model）层 用户模型（user model）层 UML的表示法 视图（view） 通常包括多个图 图（diagram） 模型元素（model element）=&gt;可以在图中使用的概念 通用机制（general mechanism） 通过通用机制可以为UML中的图附加一些额外的信息 比如：构造型，标签值，笔记（写注释）等 UML中的图 用例图 （use-case diagram） 用例是对系统提供的功能（即系统的具体用法）的描述 用例图从用户的角度描述系统功能，并指出各个功能的操作者 用例图定义了系统的功能需求 用例图描述的是一个动态的交互场景，而不是一个静态的功能 静态图（static diagram） 静态图描述系统的静态结构，包括： 类图（class diagram） 对象图（object diagram） ==&gt; 是类图的实例，有生命周期 一般说来，对象图没有类图重要，它主要用来帮助对类图的理解，也可用在协作图中，表示一组对象之间的动态协作关系 行为图（behavior diagram） 这类图描述系统的动态行为和组成系统的对象间的交互关系，包括： 状态图(state diagram) ==&gt; 描述一个类，多个场景 活动图(activity diagram) ==&gt; 描述多个类，多个场景 交互图 （interaction diagram） 这类图描述对象间的交互关系，包括 顺序图（sequence diagram） 协作图（collaboration diagram） 描述一个场景中若干个类的交互（动态协作） 实现图（implementation diagram） 这类图提供关于系统实现方面的信息，包括： 构件图（component diagram） 配置图（deployment diagram）]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（七）]]></title>
    <url>%2F2017%2F12%2F24%2F2017-12-24-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88g%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面向对象方法学概述 概念 认为客观世界是由各种对象组成的，任何事物都是对象个，复杂的对象可以由比较简单的对象以某种方式组合而成。 把所有对象都划分成各种对象类（简称为类，class），每个独享都定义了一组数据和一组方法 按照子类（或称为派生类）与父类（或称为基类）的关系，把若干个对象类组成一个层次结构的系统（也称为类等级） 对象彼此之间仅能通过传递消息互相联系 OO = objets + classes + inheritance + communication with messages 优点 与人类习惯的思维方式一致 稳定性好 可重用性好 较易开发大型软件产品 可维护性好 面向对象建模用面向对象方法开发软件，通常需要建立三种模式的模，分别是描述系统数据结构的对象模型，描述系统控制结构的动态模型和描述系统功能的功能模型 对象模型（在UML部分详细介绍） 动态模型 功能模型 三种模型之间的关系在面向对象方法学中，对象模型是最基本最重要的，为其它两种模型奠定基础，依靠对象模型完成三种模型的集成 针对每个类建立的动态模型，描述了类实例的生命周期或运行周期 状态转换驱使行为发生，行为在数据流图中被映射成处理，与对象模型中的服务相对应 功能模型中的处理对应对象模型中类提供的服务 顶层数据流图中的处理对应复杂对象提供的服务；低层数据流图中的处理对应更基本的对象(基本对象是复杂对象的组成部分)的服务 有时一个处理对应多个服务，也有一个服务对应多个处理的时候 功能模型中的数据存储，以及数据的源点/终点(在功能模型中称为动作对象)，通常是对象模型中的对象。DataStore-ER entity-Object 功能模型中的数据流，往往是对象模型中的属性值，也可能是整个对象 功能模型中的处理可能产生动态模型中的事件 对象模型描述了功能模型中的动作对象、数据存储以及数据流的结构]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（六）]]></title>
    <url>%2F2017%2F12%2F24%2F2017-12-24-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88f%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通常把编码和测试统称为实现 所谓编码就是把软件设计翻译成计算机可以理解的形式——用某种程序设计语言书写的程序 编码是设计的自然结果，程序的质量主要取决于软件设计的质量 但所选用的程序设计语言的特点和编码风格也会对程序的可靠性、可读性、可测试性和可维护性产生深远的影响。 软件测试对软件可靠性的影响是重要的（软件生命周期中，差错不可避免） 尽可能早地发现并纠正差错 测试的目的就是在软件投入生产性运行之前，尽可能多地发现软件中的错误 软件测试在软件生命周期中横跨两个阶段 单元测试（一般模块的编写者和测试者是同一个人） 综合测试（通常由专门的测试人员承担这项工作） 统计资料表明，软件测试的工作量往往占软件开发总工作量的40%以上，对于关键应用系统的测试，可能相当于软件工程其他步骤总成本的3～5倍 测试目标是发现软件中的错误，但不是最终目的。调试是诊断并改正错误，这是最终目的。调试是测试阶段最困难的工作 对测试结果进行收集和评价，确定系统的可靠性 编码 (understanding) 选择程序设计语言 总的来说，高级语言明显优于汇编语言。除了对程度执行时间和使用的空间都有很严格限制的情况；需要产生任意的甚至非法的指令序列；体系结构特殊的微处理机，以致在这类机器上通常不能实现高级语言编译程序；或者大型系统中执行时间非常关键的(或直接依赖于硬件的)一小部分代码；其他程序应该一律用高级语言书写 编码风格 源程序代码的逻辑简明清晰、易读易懂是好程序的一个重要标准，应该遵循下述规则 程序内部的文档（注释） 数据说明 语句构造 输入输出 效率 软件测试基础 (master)软件工程其他阶段都是“建设性的”，而测试阶段的目的却是为了“破坏”已经建造好的软件系统————竭力证明程序中有错误，不能按照预定要求正确工作。 测试目标 测试是为发现程序中的错误而执行程序的过程 好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案 成功的测试是发现了至今为止尚未发现的错误的测试 测试准则 所有的测试都应该能追溯到用户需求（因需制宜） 应该在测试开始之前的相当长时间，就制定出测试计划 把Pareto原理应用于软件测试：测试发现的错误中的80%很可能是由程序中20%的模块造成的（2-8定理） 测试应该从“小规模”开始，并逐步进行“大规模”测试（由小到大） 穷举测试是不可能的 为了达到最佳的测试效果，应该由独立的第三方来从事测试工作（心理学角度上来讲，让编码人员找自己的错误是不现实的） 测试方法 黑盒测试 黑盒测试又称为功能测试 是在接口层面的测试，把程序看成一个黑盒子，不考虑内部结构和处理过程 适合于程序后期测试接口 白盒测试 白盒测试又称为结构测试 把程序看成装在一个透明的白盒子里，也就是完全了解程序的结构和处理过程 按照程序内部的逻辑测试程序，检验程序中的每条通路是否都能按预定要求正确工作。 适合于早期测试模块内部逻辑 测试步骤 单元测试，也称模块测试 集成测试 确认测试 系统测试 ps: α测试：在受控环境下测试（实验室环境） β测试：在非受控环境下测试（实际工作环境） 单元测试 单元测试和编码属于软件工程过程同一阶段（同属于编码和单元测试，因为单元测试通常是在编码的过程中进行的） 在编写出源程序代码并通过了编译程序的语法检查之后，应用人工测试和计算机测试这样两种类型的测试，完成单元测试工作 这两种类型的测试各有所长，互相补充 单元测试主要采用白盒测试技术，而且对多个模块的测试可以并行地进行 测试重点 模块接口 局部数据结构 重要的执行通路 出错处理通路 边界条件 代码审查 人工测试源程序可以由编写者本人非正式地进行，也可以由审查小组正式进行，后者称为代码审查，是一种非常有效的程序验证技术，对于典型的程序来说，可以查出30%～70%的逻辑设计错误和编码错误 审查小组组成： 组长，应该是一个很有能力的程序员，而且没有直接参与这项工程 程序的设计者 程序的编写者 程序的测试者 计算机测试 模块并不是一个独立的程序，必须为每个单元测试开发驱动软件（负责调用本模块）和(或)存根软件（负责模拟被本模块调用的子模块，比如对于一个用于数据处理的子模块，本模块需要的是其输出一个数据结构，那么就可以直接用一个构造的数据实例来替代这个子模块） 驱动程序就是一个“主程序”，接收测试数据，把这些数据传送给被测试的模块，并且输出有关结果 存根程序代替被测试的模块所调用的模块，也可以称为“虚拟子程序”。（桩模块） 使用被它代替的模块的接口，做最少量的数据操作，输出对入口的检验或操作结果，并且把控制归还给调用它的模块 集成测试集成测试是测试和组装软件的系统化技术，在把模块按照设计要求组装起来的同时进行测试，主要目标是发现与接口有关的问题 非渐增式测试方法 先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序 一次性集成测试 渐增式测试把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。这种每次增加一个模块的方法称为渐增式测试 自顶向下集成 首先测试M1（需要写M2、M3、S4对应的桩模块），然后将M1作为M2、M3、S4的驱动程序，集成并测试。以此类推 不用写驱动模块，但是需要写大量桩模块 优点： 不需要测试驱动程序 能够在测试阶段的早期实现并验证系统的主要功能 能在早期发现上层模块的接口错误 缺点： 需要存根程序 低层关键模块中的错误发现较晚 早期不能充分展开人力（不利于团队分工测试） 自底向上集成 步骤： 把低层模块组合成实现某特定软件子功能的簇 写一个驱动程序(用于测试的控制程序)，协调测试数据的输入和输出 对由模块组成的子功能簇进行测试 去掉驱动程序，沿软件结构自下向上移动，把子功能簇组合起来形成更大的子功能簇，重复2~4 优缺点与自顶向下集成相反 回归测试 不是一种测试方法，也不是一个测试阶段。重新执行已经做过的测试的某个子集，以保证上述这些改变没有带来非预期的副作用 回归测试（regression）与累进测试(progression) 回归测试：用之前版本的测试方案，测试好现在的程序 累进测试：用新的测试方案，测试同一版本的程序 确认测试 确认测试也称为验收测试，目标是验证软件的有效性 使用了确认(Validation)和验证(Verification)这样两个不同的术语 验证 就是要用数据证明我们是不是在正确的制造产品。注意这里强调的是过程的正确性 确认 就是要用数据证明我们是不是制造了正确的产品。注意这里强调的是结果的正确性 确认测试的范围 软件配置复查 Alpha和Beta测试 α测试：在受控环境下测试（实验室环境） β测试：在非受控环境下测试（实际工作环境） 白盒测试技术 (master) 逻辑覆盖是设计白盒测试方案的技术。设计测试方案是测试阶段的关键技术问题 测试方案包括具体的测试目的(例如，要测试的具体功能)，应该输入的测试数据和预期的输出结果 逻辑覆盖 语句覆盖 选择足够多的测试数据，使被测程序中每个语句至少执行一次 是很弱的逻辑覆盖标准 只关心判定表达式的值，不关心表达式内部具体每个条件取哪些值 举个栗子： 只需选取一组测试数据，覆盖路径ace即可 比如可以取 测试用例的格式：【输入的(A, B, X)，输出的(A, B, X)】 满足语句覆盖的测试用例：【(2, 0, 4), (2, 0, 3)】 判定覆盖 不仅每个语句必须至少执行一次 而且每个判定的每种可能的结果都应该至少执行一次，也就是每个判定的每个分支都至少执行一次 同样只关心判定表达式的值，不关心表达式内部具体每个条件取哪些值 举个栗子： 测试用例的格式：【输入的(A, B, X)，输出的(A, B, X)】 满足判定覆盖的测试用例： 【(2, 0, 4), (2, 0, 3)】覆盖ace 【(1, 1, 1), (1, 1, 1)】覆盖abd 条件覆盖 不仅每个语句至少执行一次，而且判定表达式中每个条件都取到各种可能的结果 条件覆盖不一定比判定覆盖强，甚至可能连语句覆盖都达不到 举个栗子： 本例中b处没有逻辑代码，如果有，则上面的第二种方案就达不到语句覆盖，但是能达到条件覆盖 判定/条件覆盖 判定覆盖不一定包含条件覆盖，条件覆盖也不一定包含判定覆盖，判定/条件覆盖能同时满足这两种覆盖标准 举个栗子： 条件组合覆盖 条件组合覆盖就是设计足够的测试用例，运行被测程序，使得每个判断的所有可能的条件取值组合至少执行一次 举个栗子： 所有可能的条件组合： 一个满足条件组合覆盖的测试方案 点覆盖 边覆盖 路径覆盖 控制结构测试 基本路径测试 (master) 根据过程设计结果画出相应的流图 计算流图的环形复杂度n 确定线性独立路径的基本集合（找到n条能覆盖整个流图的独立路径） 独立路径指至少引入程序一个新处理语句集合或一个新条件的路径，用流图术语描述，独立路径至少包含一条在定义该路径之前不曾用过的边 程序的环形复杂度决定了程序中独立路径的数量 在不考虑业务逻辑的情况下找到的路径有可能是无效的（多个判定条件之间可能有一定联系，导致某个独立路径上的判定条件无法同时满足） 设计可强制执行基本集合中每条路径测试用例 举个栗子： 环形复杂度：6 路径： 路径1：1-2-10-11-13 路径2：1-2-10-12-13 路径3：1-2-3-10-11-13 路径4：1-2-3-4-5-8-9-2··· 路径5：1-2-3-4-5-6-8-9-2··· 路径6：1-2-3-4-5-6-7-8-9-2··· 路径4、5、6后面的省略号(…)表示，可以后接通过控制结构其余部分的任意路径(例如，10-11-13) 条件测试 (pass) 循环测试 (pass) 简单循环 串接循环 嵌套循环 黑盒测试技术 (master) 黑盒测试着重测试软件的功能需求，让软件工程师设计出能充分检查程序所有功能需求的输入条件集 黑盒测试和白盒测试两者互补(A代表需求，B代表实现) 白盒测试至多能覆盖实现 黑盒测试至多能覆盖需求 只有两者结合使用才能做到全方位的测试 白盒测试在测试过程的早期阶段进行，而黑盒测试主要用于测试过程的后期 黑盒测试力图发现下述类型的错误：① 功能不正确或遗漏了功能；② 界面错误；③ 数据结构错误或外部数据库访问错误；④ 性能错误；⑤ 初始化和终止错误 等价划分 目的 需要研究程序的功能说明，确定输入数据的有效等价类和无效等价类 经验 如果规定了输入值的范围，则可划分出一个有效的等价类(输入值在此范围内)，两个无效的等价类(输入值小于最小值或大于最大值) 如果规定了输入数据的个数，则类似地也可以划分出一个有效的等价类和两个无效的等价类 如果规定了输入数据的一组值，而且程序对不同输入值做不同处理，则每个允许的输入值是一个有效的等价类，此外还有一个无效的等价类(任一个不允许的输入值) 如果规定了输入数据必须遵循的规则，则可以划分出一个有效的等价类(符合规则)和若干个无效的等价类(从各种不同角度违反规则) 如果规定了输入数据为整型，则可以划分出正整数、零和负整数等三个有效类 如果程序的处理对象是表格，则应该使用空表，以及含一项或多项的表 边界值分析 处理边界情况时程序最容易发生错误 边界值处测试数据的选取 刚好等于 刚刚小于 刚刚大于 栗子： 错误推测 错误推测法在很大程度上靠直觉和经验进行 基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案 调试 调试(也称为纠错)作为成功的测试的后果而出现，即调试是在测试发现错误之后排除错误的过程 调试不是测试，但是它总是发生在测试之后 途径： 蛮干法：打印内存数据、关键输出、断点 回溯法：由症状回推可能的原因 原因排除法：对分查找、归纳、演绎等方法 软件可靠性]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（五）]]></title>
    <url>%2F2017%2F12%2F23%2F2017-12-23-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88e%EF%BC%89%2F</url>
    <content type="text"><![CDATA[详细设计阶段的任务还不是具体地编写程序，而是要设计出程序的“蓝图”，以后程序员将根据这个“蓝图”写出实际的程序代码。 结构程序设计 (master)如果一个程序的代码块仅仅通过顺序、选择和循环这三种控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。 三种基本控制结构 关于GOTO语句 上面关于结构化程序经典定义过于狭隘，结构程序设计本质上并不是无GO TO语句的编程方法，而是一种使程序代码容易阅读、容易理解的编程方法 大多数情况下，无GO TO的代码确实是容易阅读、容易理解，但在某些情况下，为达到容易阅读和容易理解的目的，需要使用GO TO语句 结构程序设计是尽可能少用GO TO语句的程序设计方法。最好仅在检测出错误时才使用GO TO语句，而且应该总是使用前向GO TO语句 但是一般题目中问一段代码为什么不是结构化程序，很大可能是使用了GOTO语句 经典的结构程序设计 如果只允许使用顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这三种基本控制结构，则称为经典的结构程序设计 扩展的结构程序设计 如果除了上述三种基本控制结构之外，还允许使用DO-CASE型多分支结构和DO-UNTIL型循环结构，则称为扩展的结构程序设计 修正的结构程序设计 如果再加上允许使用LEAVE(或BREAK)结构，则称为修正的结构程序设计。 人机界面设计 (cut)人机界面设计是接口设计的一个组成部分 设计问题 系统响应时间 用户帮助设施 出错信息处理 命令交互 设计过程 用户界面设计是一个迭代的过程，也就是说，通常先创建设计模型，再用原型实现这个设计模型，并由用户试用和评估，然后根据用户的意见进行修改 界面设计指南 一般交互指南 保持一致性 提供有意义的反馈 在执行有较大破坏性动作之前要求用户确认 允许取消大多数操作 减少在两次操作之间必须记忆的信息量 提高对话、移动和思考的效率 允许犯错误 按功能对动作分类，并据此设计屏幕布局 提供对用户工作内容敏感的帮助设施 用简单动词或名词短语作为命令名 信息显示指南 只显示与当前工作内容有关的信息。 用户在获得有关系统的特定功能的信息时，不必看到与之无关的数据、菜单和图形。 不要用数据淹没用户 使用一致的标记、标准的缩写和可预知的颜色 允许用户保持可视化的语境 产生有意义的出错信息 使用大小写、缩进和文本分组以帮助理解 使用窗口分隔不同类型的信息 使用“模拟”显示方式表示信息 高效率地使用显示屏 数据输入指南 尽量减少用户的输入动作 保持信息显示和数据输入之间的一致性 允许用户自定义输入 交互应该是灵活的 使在当前动作语境中不适用的命令不起作用 让用户控制交互流 对所有输入动作都提供帮助 消除冗余的输入 过程设计的工具 (master)图形、表格、语言 程序流程图 程序流程图又称为程序框图，是历史最悠久使用最广泛的描述过程设计的方法，然而也是用得最混乱的一种方法 缺点： 绘制随意，容易只考虑流程控制而不考虑全局结构，而破坏结构化程序设计 不容易表示数据结构 程序流程图中使用的符号 盒图（N-S图） 盒图没有箭头，因此不允许随意转移控制。坚持使用盒图作为详细设计的工具，可使程序员逐步养成用结构化的方式思考问题和解决问题的习惯 能保证设计出的程序一定是结构化的 但是绘制的时候受空间限制，难以扩充 盒图的基本符号 PAD图（Problem Analysis Diagram） 它用二维树形结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易 与盒图相比，不受空间限制，易于扩充 可保证设计出来的程序一定是结构化的 PAD图的基本符号 (a) 顺序(先执行P1后执行P2)； (b) 选择(IF C THEN P1 ELSE P2)； (c) CASE型多分支；(d) WHILE型循环(WHILE C DO P)； (e) UNTIL型循环(REPEAT P UNTIL C)； (f) 语句标号； (g) 定义 可使用PAD提供的定义功能来逐步求精 判定表 当算法中包含多重嵌套的条件选择时，判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系 判定树 比判定表直观，包含判定的先后顺序 父节点：判定条件 叶子节点：一个动作 过程设计语言（PDL: Process Design Language） 伪代码 程序复杂度的定量度量 (master)常用的方法有McCabe方法（采用流图）、Halstead方法，下面仅介绍第一种 McCabe 方法 流图 为了突出表示程序的控制流，可以使用流图(也称为程序图) 流图仅描绘程序的控制流程，完全不表现对数据的具体操作以及分支或循环的具体条件。 流图用圆表示节点，一个圆代表一条或多条语句（如果多条语句在一个顺序结构上，可以省略中间，只画两边的节点） 流图中的箭头线称为边，和程序流程图中的箭头线类似，代表控制流 由边和节点围成的面积称为区域，区域数应该包括图外部未被围起来的区域。 基本结构： 把程序流程图映射成流图(a)程序流程图；(b)流图 PDL翻译成流图 123456789101112131415procedure: sort do while records remain read record; if record field1 = 0 then process record; store in buffer; incremert counter; elseif record filed2 = 0 then reset counter; else process record; store in file; endif endif enddo end 由包含复合条件的PDL映射成的流图 流图环形复杂度的计算 流图中的区域数等于环形复杂度 流图G的环形复杂度V(G)＝E-N+2，其中E是流图中边的条数，N是流图中节点数 流图G的环形复杂度V(G)＝P+1，其中P是流图中判定节点的数目 举个栗子： 上图中共有四个区域，故环形复杂度为4 上图中共有11条边，9个点，所以环形复杂度位：11 - 9 + 2 = 4 上图中共有三个判定节点，分别为”1”, “2,3”, “6”，所以环形复杂度为：3 + 1 = 4 PS: 在计算区域数的时候别忘了包括最外围的区域 在计算判定节点的时候，不仅包括条件分支的判断，循环判定的节点也算]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（四）]]></title>
    <url>%2F2017%2F12%2F23%2F2017-12-23-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88d%EF%BC%89%2F</url>
    <content type="text"><![CDATA[结构化设计（Structured Design, SD） (整体understanding)结构化设计工作通常划分为概要设计和详细设计两个阶段 概要设计又称总体设计或初步设计 概要设计的主要任务：分析软件规格说明（来自需求分析的输出）,对软件进行功能分解，划分为模块，设计出模块结构 详细设计阶段：详细设计每个模块，确定每个模块功能的算法和数据结构 设计过程总体设计过程通常由两个主要阶段组成：系统设计阶段，确定系统的具体实现方案;结构设计阶段，确定软件结构。 设想供选择的方案 选择合理的方案 推荐最佳方案 功能分解 设计软件结构 设计数据库 制定测试计划 书写文档 复查和复审 设计原理 模块化 概念 模块是由边界元素限定的相邻的程序元素的序列，而且有一个总体标识符来代表。 面向对象范型中的对象是模块，对象内的方法也是模块。模块是构成程序的基本构件。 每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求 模块化和软件成本 每一个程序都相应地有一个最适当的模块书目M，使系统的开发成本最小 优点 结构清晰 容易阅读和理解 容易测试和调试 有助于提高软件的可靠性 可修改性 便于组织和管理 抽象 把事物、状态或过程之间存在的共性集中概括起来，暂时忽略他们之间的差异，这就是抽象 逐步求精 为了能集中精力解决主要问题而尽量推迟对问题细节的考虑 求精实际上就是细化的过程 抽象与求精是一对互补的概念 抽象使得设计者能够说明过程和数据，同时却忽略低层细节。 抽象是一种通过忽略多余的细节同时强调有关的细节，而实现逐步求精的方法。 求精则帮助设计者在设计过程中揭示出低层细节。 这两个概念都有助于设计者在设计演化过程中创造出完整的设计模型。 信息隐藏和局部化 一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的 模块独立 （master） “模块独立”概念是模块化、抽象、逐步求精和信息隐藏等概念的直接结果，也是完成有效的模块设计的基本标准。可以由两个定性标准来度量，这两个标准分别称为内聚和耦合。 耦合：耦合衡量不同模块彼此间互相依赖(连接)紧密程度 内聚：内聚衡量一个模块内部各个元素彼此结合的紧密程度 对于模块设计，我们一般追求：模块内部高内聚，模块之间低耦合 耦合 非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，非直接耦合的模块独立性最强，模块间的耦合程度最低 数据耦合：通过简单的数据参数传递产生的耦合，是一种低耦合 标记（特征）耦合： 传递参数表记录信息，如文件、数组、指针等。 当把整个数据结构当做参数传入模块，但是模块实际上只需要其中的一部分元素 控制耦合： 传递的信息中有控制信息，有可能是一个简单变量，但可能改变程序流程。 它是中等程度的耦合，增加了系统的复杂程度，适当分解可以用数据耦合替代它。 外部耦合：一组模块都访问同一全局简单变量 公共环境耦合：一组模块访问同一个公共数据环境 内容耦合： 一组模块使用另一模块内部数据；模块通过非正常渠道进入另一模块执行 这是最高程度的耦合 使用原则：尽量使用数据耦合，少用控制耦合，限制公共环境耦合的范围，完全不用内容耦合。 内聚 理想内聚的模块只做一件事情，设计模块时，通常追求模块内部是高内聚的内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合 低内聚： 偶然内聚 逻辑内聚 时间内聚 中内聚 过程内聚 通信内聚 高内聚 顺序内聚（信息内聚） 功能内聚 启发规则长期实践经验所得，有助于实现有效的模块化 改进软件结构提高模块独立性 模块规模应该适中 深度、宽度、扇出和扇入都应适当 深度：树高 宽度：某层最大模块数 扇出：直接控制的模块数 扇入：有多少个上机的模块直接指向它 模块的作用域应该在控制域之内 如图所示，A的控制域就包括BCDEF 如果G也在A的作用域之内，则就不是一个合理的设计 应该把G下放一层，放在A的控制域之内 力争降低模块接口的复杂程度 设计单入口单出口的模块 模块功能应该可以预测 相同输入，得到可预测的想通过输出 描绘软件结构的图形工具 （master）层次图、HIPO图和结构图 层次图 层次图也称H图 在层次图中一个矩形框代表一个模块，框间的连线表示调用关系(位于上方的矩形框所代表的模块调用位于下方的矩形框所代表的模块)。 HIPO图 HIPO图是美国IBM公司发明的“层次图加输入/处理/输出图”的英文缩写。 为了使HIPO图具有可追踪性，在H图(即层次图)里除了顶层的方框之外，每个方框都加了编号。 然后每个方框对应用一张IPO图来描述，IPO图中应该明显的标出其在上述改进的H图中的编号 结构图（了解） 结构图和层次图类似，也是描绘软件结构的图形工具 结构图中带注释的箭头表示模块调用过程中来回传递的信息 尾部是空心圆表示传递的是数据，实心圆表示传递的是控制信息 其它符号 判定为真时调用A，为假时调用B 模块M循环调用模块A，B，C 面向数据流的设计方法 （understanding）面向数据流的设计方法的目标是给出设计软件结构的一个系统化的途径。它定义了一些不同的“映射”，利用这些映射可以把数据流图变换成软件结构 概念 变换流 信息通常以“外部世界”的形式进入软件系统，经过处理以后再以“外部世界”的形式离开系统 事物流 接收输入数据（输入数据又称为事物） 分析每个事物，以确定它的类型 根据事务类型选取一条活动的通路 设计过程 变换分析 复查基本系统模型 复查并精化数据流图 确定数据流图具有变换特性还是事务特性 确定输入流和输出流的边界，从而孤立出变换中心 完成“第一级分解” … 完成“第二级分解” 未精化的输入结构 未精化的变换结构 未精化的输出结构 使用设计度量和启发规则对第一次分割得到的软件结构进一步精化 事务分析 虽然在任何情况下都可以使用变换分析方法设计软件结构，但是在数据流具有明显的事务特点时，也就是有一个明显的“发射中心”(事务中心)时，还是以采用事务分析方法为宜。 事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同。 对于一个大系统，常常把变换分析和事务分析应用到同一个数据流图的不同部分，由此得到的子结构形成“构件”，可以利用它们构造完整的软件结构 事务分析的映射方法： 设计优化（refactoring） P112]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（三）]]></title>
    <url>%2F2017%2F12%2F22%2F2017-12-22-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88c%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述需求分析是发现、求精、建模、规格说明和复审的过程。 准则 必须理解和表示问题的信息域，根据这条准则应该建立数据模型。 必须定义软件应完成的功能，这条准则要求建立功能模型。 必须表示作为外部事件结果的软件行为，这条准则要求建立行为模型。 必须对描述信息、功能和行为的模型进行分解，用层次的方式展示细节。 分析过程应该从要素信息移向实现细节 业务 → 技术 逻辑 → 物理 要素 → 细节 需求分析的任务 确定对系统的综合要求 数据要求 功能需求 性能需求 可靠性和可用性需求 出错处理需求 接口需求 约束 逆向需求（不应该做的） 将来可能提出的要求 分析系统的数据要求 任何软件系统本质上都是信息处理系统 建立数据模型（E-R图） 数据字典 层次方框图 Warnier图 导出系统给的逻辑模型 数据流图、E-R图、状态转换图、数据字典、算法描述 修正系统的开发计划 与用户沟通获取需求的方法 访谈 面向数据流自顶向下求精 简易的应用规格说明技术 快速建立软件模型 快速原型应该具备的第一个特性是“快速”。 快速原型应该具备的第二个特性是“容易修改”。 分析建模与规格说明实体——联系图（E-R图） (master)数据模型包含三种相互关联的信息：数据对象、描述数据对象属性及数据对象彼此间相互连接的关系 ER图中包含实体(即数据对象)、关系和属性三种基本成分。 数据规范化一、二、三范式 状态转换图 (master)状态转换图(状态图)通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为一个状态图只能描述一个对象的行为变化，包括一系列状态、事件以及状态之间的转移 状态和事件 状态：状态是任何可以被观察到的系统行为模式（当前对象属性值的集合） 事件：事件在某个特定个时刻发生的事情，引起系统从一个状态转换到另一个状态 符号 初态：实心圆 终态：一对同心圆 中间状态：用圆角矩形表示，可分为三部分：状态名、状态变量、活动表（其中状态名是必选的，其余两个是可选的） 活动表的语法格式：事件名（参数表）/ 动作表达式 entry (在进入该状态时执行) exit （退出该状态时执行） do （在该状态下一直执行） 状态转换：两个状态之间带箭头的连线，箭头指明了转换方向 连线上通常标出导致状态转化的触发事件 触发事件表达式的语法：事件说明[守卫条件]/动作表达式 事件说明：事件名（参数表） 守卫条件：一个布尔表达式 动作表达式：是一个过程表达式，当状态转换开始后时执行该表达式 栗子： 状态转换 简单转移 自转移 （自己转移到自己，需要事件触发） 自动转移 （通常是本状态需要做的一个活动完成时转换到下一个状态） 复合转移 组合状态————子状态 一个状态下可以嵌套许多子状态 顺序子状态 =&gt; 子状态是串行连续变化的 并发子状态 =&gt; 存在并发存在互不影响的子状态 补充 同步 分劈（Fork） 接合（Join） 伪状态 符号用圈里面一个*表示 用来表示并发状态的同步 在子状态图之间使用（放在分隔子状态的虚线上） 历史状态 符号用圈里面一个H表示 记录在离开某个状态时，其处于哪个子状态中 对于同一层级的状态来说，初态只有一个，终态可以有多个 其它图形工具 层次方框图 层次方框图用树形结构的一些列多层次的矩形框描绘数据的层次结构 Warnier图 IPO图 IPO图是输入、处理、输出图的简称 左边框中列出有关的输入 中间框中列出主要的处理 右边框中列出产生的输出 处理的顺序暗示了执行的顺序 箭头指出数据通信的情况 验证软件的需求（了解）验证软件的一致性、完整性、现实性和有效性]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（二）]]></title>
    <url>%2F2017%2F12%2F22%2F2017-12-22-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88b%EF%BC%89%2F</url>
    <content type="text"><![CDATA[可行性研究的任务不是解决问题，而是确定问题是否值得去解决。 分析可能的解法 判定系统规模和目标是否能够实现 效益是否可观 较高层次的系统分析和设计过程 技术可行性：开发此系统是可行的，是有好处的 经济可行性：根据系统目标衡量所需技术是否具备 操作可行性：系统是否易于使用并能够创造价值 法律可行性：是否存在侵犯、妨碍和责任等问题 可行性研究过程（understanding）了解就好 复查系统规模和目标 改正含糊或不确切的叙述 清晰地描述限制和约束 确保分析员解决正确的问题 研究目前正在使用的系统 完成现有系统的基本功能分析 解决现有系统的问题 绘制高层系统数据流图 掌握与其他系统的接口 导出新系统的高层逻辑模型 现有物理系统 → 现有系统的逻辑模型 → 目标系统逻辑模型 → 新的目标系统 高层数据流图 初步的数据字典 进一步定义问题 以数据流图和数据字典为基础 复查问题定义、工程规模和目标 分析员和用户 重复1~4步，直至提出的逻辑模型完全符合系统目标 导出和评价供选择的解法 从技术角度出发，考虑解决问题的不同方案 技术可行性，排除不现实的系统 操作可行性，排除用户不能接受的方案 经济可行性，排除利润低的方案 制定进度表 (估算生命周期每个阶段的工作量) 推荐行动方针（是否做？） 分析员：如果值得开发，则选择最好的解法 用户：成本/效益分析 草拟开发计划 工程进度表 各类开发人员、各种资源需求情况 生命周期每个阶段的成本 下一个阶段详细进度表和成本估计 书写文档提交审查 用户、客户组织负责人、评审组审查 系统流程图 （understanding）系统流程图概括描绘物理系统的传统工具用图形符号，以黑盒子形式描述组成系统的每个部件程序、文档、数据库、人工过程 符号： 栗子： 数据流图 (master)数据流图(DFD) 描绘信息流和数据从输入移动到输出的过程中所经受的变换。 数据流图的四种基本符号： 加工中常见关系的符号表示： 注意： 信息的流动 信息流不能为动词 实体到实体的信息流动 处理要有输入输出 处理名不能为名词 确保层间的一致性（确保输入输出流的量是一致的） 命名: 数据流的名字应代表整个数据流(数据存储、处理)的内容，而不是仅仅某些成分。 不要使用空洞的、缺乏具体含义的名字(如“数据”、“信息”、“输入”之类)。 处理名字最好是一个具体的及物动词。 示例：出入库管理系统 0级数据流图 1级数据流图 2级数据流图 数据字典 (master) 数据字典是关于数据的信息的集合，即对设计图中包含的元素的定义。 数据字典的用途是供人查阅不了解的条目的解释，提供分析设计过程中关于数据的描述。 只有设计图和对应的元素的精确定义放在一起，才能构成系统完整的规格说明。 定义数据的方法 = : 意思是等价于(或定义为); + : 意思是和(即，连接两个分量); [] : 意思是或(即，从方括弧内列出的若干个分量中选择一个)，用“｜”号分开供选择的分量; {} : 意思是重复(即，重复花括弧内的分量); () : 意思是可选(即，圆括弧里的分量可有可无); 使用上限和下限进一步注释表示重复的花括弧。 左边用上角标和下角标分别表明重复的上限和下限 左侧标明重复的下限，在闭括弧的右侧标明上限 例如： 举个栗子： 北京某高校可用的电话号码有以下几类:校内电话号码由4 位数字组成，第1位数字不是0;校外电话又分为本市电话和外地电话两类,拨校外电话需先拨0,若是本市电话则再接着拨8位数字(第1位不是0),若是外地电话则拨3位区码再拨8位电话号码(第1位不是0)。请用上述提到的定义数据的方法，定义上述的电话号码。1234567891011电话号码 = [ 校内电话号码 | 校外电话号码 ]校内电话号码 = 非零数字 + 3位数字校外电话号码 = [ 本市电话号码 | 外地电话号码]本市电话号码 = 数字零 + 8位数字外地电话号码 = 数字零 + 3位数字 + 8位数字非零数字 = [1|2|3|4|5|6|7|8|9]3位数字 = 3&#123;数字&#125;3数字零 = 08位数字 = 非零数字 + 7位数字7位数字 = 7&#123;数字&#125;7数字 = [0|1|2|3|4|5|6|7|8|9] 数字字典的实现 CASE工具 人工卡片 成本效益分析（了解）成本/效益分析是客户从经济角度判断是否继续投资项目的主要依据。 成本估计 代码行技术 任务分解技术 效益分析 货币的时间价值 投资回报期 纯收入 投资回报率（最重要的参考数据）]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（一）]]></title>
    <url>%2F2017%2F12%2F22%2F2017-12-22-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88a%EF%BC%89%2F</url>
    <content type="text"><![CDATA[软件危机（understanding）软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重的问题 软件危机的表现 对开发成本和进度的估计往往很不准确 用户对“已完成的”软件系统不满意的现象时常发生 软件质量差 软件通常难以维护 软件没有适当的文档资料 软件成本在计算机系统的总成本中所占的比例逐年上升（软件成本日益增长） 软件开发速度跟不上计算机发展速度 产生软件危机的原因 技术原因 软件规模越来越大 软件复杂度越来越高 管理原因 软件开发缺乏正确的理论指导，过分依赖个人技巧和创造性 对用户需求没有完整准确的认识，就匆忙着手编写程序 引入统一变动付出代价随时间变化的趋势 上图展示的就是软件开发过程中，需求变化出现在开发过程的后期将会带来巨大的修改代价 所以应该在软件开发的早期，甚至是定义的时候就尽量的接近用户的真是需求 但通常，用户的牙膏不会一下子挤完（甚至一开始，大多数用户对自己的需求都不是很明确） 如何克服软件危机？ ==&gt; 软件工程 消除软件危机的途径 对计算机软件的正确认识 1983年IEEE对软件的定义：计算机程序、方法、规则、相关的文档资料以及在计算机上运行程序时所必须的数据 软件 ≠ 程序 软件工程三要素 推广使用开发软件成功的技术和方法，并且研究探索更好有效的技术和方法 开发和使用更好的软件工具 需要组织管理措施（过程） 总之，为了解决软件危机，既要有技术措施（方法和工具），有要有必要的组织管理措施。 无章法（个人英雄主义）=&gt; 工程项目管理模式（团队合作开发） 软件工程(understanding)1968第一届NATO会议：软件工程称就是为了经济的获得可靠的且在实际机器上有效运行的软件，而建立和使用的完善的工程原理1993年IEEE： 把系统的、规范的、可度量的途径应用于软件开发、运行和维护的过程，也就是把工程应用于软件 研究1中提到的途径 主要目标：高效开发高质量软件 软件工程的基本原理 用分阶段的生命周期计划严格管理 坚持进行阶段评审 错误发现的越晚，所需付出的代价也越大 对每个已完成的阶段进行评审，以便尽早发现错误 实行严格的产品控制 软件开发过程中不应该随意改动需求，对修改意见需要经过严格的评审后才能实施 采用现代化程序设计技术 结果应该能清楚的审查 开发小组的成员应该少而精 承认不断改进软件工程实践的必要性 软件工程方法学 通常把在软件生命周期全部过程各种使用的一整套技术方法的集合称为方法学（methodology）,也称为泛型（paradigm） 软件工程方法学3要素 方法：“如何做？” 工具：“用什么做？” 过程：“如何控制、协调、保证质量？” 传统方法学（静态分析） 传统方法学也称为生命周期方法学或结构化泛型，它采用结构化技术 这种方法学把软件生命周期的全过程依次划分为若干阶段，然后顺序的完成每个阶段的任务 特点： 生命周期模型 软件过程划分为若干个阶段 每个阶段有各自的任务 阶段之间有某种顺序性 局限： 当软件规模较大，或对软件的需求是模糊的或随时间变化的时候，使用结构化泛型开发软件往往不成功 此外，使用传统方法学开发出的软件通常维护起来都很困难 面向对象方法学（动态分析） 特点： 面向对象方法学的出发点和基本原则，是尽可能模拟人类的思维方式 用面向对象方法学开发软件的过程，是一个主动多次反复迭代演化的过程 概念和表示方法上的一致性，阶段间平滑（无缝）过度 特殊到一般的归纳思维过程；一般到特殊的演绎思维过程（继承的思想） 软件生命周期 (重点)概括的说，软件生命周期由软件定义、软件开发和运行维护（也称为软件维护）3个过程 问题定义 要解决什么问题？ 可行性研究 对上一阶段确定的问题是否有行之有效的解决方案？ 需求分析 目标系统必须做什么？用正式的文档记录对目标系统的需求（规格说明） 总体设计（概要设计） 概括的说，应该怎样实现目标系统？（从此阶段开始设计实现和技术的细节）又称为初步设计、逻辑设或、概要设计或高层设计 详细设计 把上阶段提出的解决方案具体化，回答“应该如何具体的实现这个系统？”又称为模块设计、物理设计或低层设计 编码和单元测试 具体coding。写出正确的容易理解、容易维护的程序模块，并测试 综合测试 集成测试、验收测试、系统测试 软件维护 通过各种必要的维护活动使系统持久地满足用户的需要 四类维护活动 改正性维护：诊断和改正真在使用过程中发现的软件错误 适应性维护：即修改软件以适应环境的变化 完善性维护：即根据用户的要求改进或扩充软件使它更完善 预防性维护：即修改软件为将过来的维护活动预先做准备 软件过程 （重点）软件过程是为了获得赶工质量软件所需要完成的一些列的任务的框架，它规定了完成各项任务的工作步骤 瀑布模型 阶段间具有顺序性和依赖性 推迟实现的观点 清楚的区分逻辑设计与物理设计，尽可能推迟程序的物理实现 质量保证的观点 每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务 每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误 瀑布模型的成功过在很大程度上由于它基本上是一种文档驱动的模型 优点：可强迫开发人员采用规范的方法（例如，结构化技术）； 严格地规定了每个阶段必须提交的文档；要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证 缺点：瀑布模型是由文档驱动的。由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要。 适用范围：应用需求明确的项目 快速原型模型 快速建立起可以运行的程序，其功能往往是最终产品功能的子集 通过将简单的模型给用户试用，以获取到用户更多更详细的需求（努力挤牙膏） 快速原型的本质是“快速” 原型的用途是获取用户的真正需求，一旦需求确定了，原型将被抛弃（原型通常没有严格的规范化，缺少文档，难以维护）。 优点：软件产品的开发基本上是线性顺序进行的 原型系统已经通过与用户交互而得到验证，据此产生的规格说明文档正确地描述了用户需求，，不会因为规格说明文档的错误而进行较大的返工。 开发人员通过建立原型系统已经学到了许多东西，在设计编码阶段发生错误的可能性比较小，自然减少了反馈。 缺点： 缺乏丰富而强有力的软件工具和开发环境。 缺乏有效的管理机制，还未建立起自己的开发标准。 对设计开发环境要求较高。 在多次重复改变原型的过程中，程序员会感到厌倦。 系统的易变性对测试有一定影响，难于做到彻底测试，更新文档较为困难。 适用范围：有结构的系统或者需求不明确的系统 增量模型 增量模型也称为渐增模型。把软件产品作为一系列增量构件来设计、编码、集成和测试 每个构件由多个相互作用的模块构成，并且能够完成特定的功能。 使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能。(滚雪球方式) 与瀑布模型相比： 瀑布模型：力求一次性给用户完整的系统。 增量模型：逐步增加系统功能。 增量模型： 一种风险更大的增量模型 优点： 能在较短时间内向用户提交可完成部分工作的产品 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。 缺点：待解决的问题必须允许有一个可递增的软件解决方案。如果需要的软件必须将所有的功能表现出来，那么递增的模型是不合适的。还有就是为了递增模型成功，必须找出整个系统的体系结构。 适用范围：不能在设定的期限内完成产品时，先推出核心产品 使用这种方法将冒构件无法集成到一起的风险，除非密切地监控整个开过程 螺旋模型 螺旋模型的基本思想是使用原型及其他方法尽量降低风险。 简化的螺旋模型 可以在一定程度上降低风险，但对有些风险也是无能为力的 需要专业的风险评估人员 完整的螺旋模型 优点： 对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标 减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险 在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别 缺点：仅适用于内部项目，大型项目受限，需要风险分析专家。 适用范围：主要适用于内部开发的大规模软件项目。 喷泉模型 迭代是OO开发过程的主要特性。 喷泉模型是典型的面向对象生命周期模型。 “喷泉” 体现了面向对象软件开发过程迭代和无缝的特性。 为避免喷泉模型的过分无序，把一个线性过程作为总目标。 迭代：逐步求精 阶段间没有明显的界限－面向对象的思想保证了各个阶段开发的一致性。 喷泉模型： Rational统一过程 敏捷过程与极限编程 敏捷软件开发宣言 个体和交互胜过过程和工具（Individuals and interactions over processs and tools） 可以工作的软件胜过面面俱到的文档（Working software over comprehensive socumentation） 客户合作胜过合同谈判（Customer collaboration over contract negotiation） 响应变化胜过遵循计划（Responding to change over following a plan） 敏捷软件开发的原理（The principles of agile methods） 客户参与（Customer involvement） 增量交付（Incremental delivery） People not process 拥抱变化（Embrace change） 保持简单（Maintain simplicity） 极限编程有效实践（极限编程是敏捷过程中最富盛名的一个） Incremental planning Small releases Simple design Test-first development Refactoring Pair programming Collective ownership Continuous integration Sustainable pace On-site customer 适用范围： 项目团队的人数不能太多 项目经常发生变更 高风险的项目实施 开发人员可以参与决策]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（补充）——分解算法浅析]]></title>
    <url>%2F2017%2F11%2F11%2F2017-11-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面：今天笔者将会对BCNF和3NF分解算法做简要的分析，不过实际上大多数的分解用肉眼即可，以下分解算法不依赖于过多的条件可以直接讲一个满足1NF的模式分解为3NF或BCNF BCNF 分解算法 教材上关于BCNF分解算法的伪代码实现有部分印错（本科教学版） 该算法的结果是一个满足BCNF的无损分解，但可能不是保持依赖的（毕竟3NF是保持依赖并且可以满足无损分解的最高范式） 伪代码实现对满足1NF的模式R作如下处理可分解成满足BCNF范式的模式R1, R2, …, Rn 12345678910result := &#123;R&#125;; done := false; 计算F+; while(not done) do if(result中存在模式Ri不属于BCNF) then begin 令 α→β 为一个在Ri上成立的非平凡函数依赖，满足 α→β ∈ F+， 并且 α∩β = ∅; result := (result - Ri) ∪ (Ri - β) ∪ (α, β) end else done := true 先来分析一波上面的代码吧 首先令reslut = {R} 接着计算一下F的函数闭包F+（计算函数闭包还是挺麻烦的，所以在下面判断的时候挑一个函数依赖，判断一下是否被F逻辑蕴含即可） 然后判断结果集result中是否还存在哪个模式不满足BCNF范式，如果都满足，则直接跳到步骤5，如果存在某个模式 Ri ∈ result，不满足BCNF范式，则执行步骤4 选择一个在Ri上成立的非平凡函数依赖 α→β，并且 α→β 属于 F+，并且α∩β=∅。然后将模式Ri分解成两个模式，分别为 (Ri - β) 和 (α, β)。并且将Ri从result中移除，江新得到的两个模式添加到result中。接着回到步骤3继续判断 分解完成，输出结果 纸上学来终觉浅，让我们拿教材上的栗子出来刷一刷～～ 有模式class, 通过上述算法，对其进行满足BCNF范式的分解 U = {course_id, title, dept_name, credits. sec_id, semester, year, building, room_number, capticy, time_slot_id} F = {course_id → (title, dept_name, credits),(building, room_number)→capaticy,(course_id, sec_id, semester, year)→(building, room_number, time_slot_id)} 首先还是看一下上面模式的候选码是什么吧（书上的栗子是直接给出来了，但是有些题可能不给，需要自己算） 通过上一篇博客讲的候选码求解算法，容易求得模式class的候选码为{course_id, sec_id, semester, year} 接着判断模式class是否满足BCNF范式 模式R中存在依赖 course_id → (title, dept_name, credits), 但course_id并不是R的一个超码，故R不满足BCNF范式 对R做如下分解 course(course_id, title, dept_name, credits) class_1(course_id, credits. sec_id, semester, year, building, room_number, capticy, time_slot_id) 继续判断，易知course是满足BCNF范式的，而course_1同理不满足BCNF范式， 继续分解 找到非平凡依赖(building, room_number)→capaticy， 且其属于F 对class_1分解如下 classroom(building, room_number, capacity) section(course_id, credits. sec_id, semester, year, building, room_number, time_slot_id) 检测一下发现现在模式classroom和section也满足BCNF范式了 OK，原来的模式class现在分解为如下三个模式 course(course_id, title, dept_name, credits) classroom(building, room_number, capacity) section(course_id, credits. sec_id, semester, year, building, room_number, time_slot_id) 3NF分解算法以下分解算法中用到了正则覆盖的概念，这个笔者在之前的博客中也提到过，点我传送 该分解算法可以保持依赖，并且是无损分解 伪代码实现 123456789101112131415161718令Fc为F的正则覆盖;i:= 0;for each Fc 中的函数依赖 α→β i := i + 1 Ri := αβ;if 模式 Rj, j = 1, 2, ..., i 都不包含R的候选码then i := i + 1 Ri := R的任意候选码/*(以下代码可选)用来移除冗余关系，如果没有冗余关系则可以不care*/repeat if 模式 Rj包含于另一个模式Rk中 then /*删除Rj*/ Rj := Ri i := i - 1until 不再有可以删除的Rjreturn (R1, R2, ..., Ri) 老规矩，还是先分析一下上面的伪代码 首先求出F的正则覆盖Fc（实际上就是利用Amstrong公式化简原来的函数依赖集的过程） 接着将Fc中的每一个函数依赖单独分解成一个模式，得到一个模式列表S = {R1, R2, …, Ri} 如果上述模式列表S中的任意一个模式包含模式R的候选码，则跳到步骤5，否则执行步骤4 选取R的任意一个候选码，组成一个新的模式R’, 将R’添加到模式列表S中 （可选）如果模式列表中存在冗余（即某个模式被其他模式包含），则可以删除这个模式 输出S 讲真，3NF分解的步骤还是很简单的，主要还是计算一下F的正则覆盖，详细栗子就不举了，下面简单提一提 比如上面分析BCNF分解算法时用到的模式class， 利用上述算法分解之后可以得到和 利用BCNF算法分解一样的结果 所以，神奇的事情发生了，利用3NF分解算法得到的结果可能还会满足BCNF范式 实践中BCNF分解的另一种途径： 先用3NF算法分解，然后对结果中不满足BCNF范式的模式用BCNF分解算法分解，如果结果不保持依赖，则回退回3NF]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（补充）——候选码的确定方法]]></title>
    <url>%2F2017%2F11%2F10%2F2017-11-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E5%80%99%E9%80%89%E7%A0%81%E7%9A%84%E7%A1%AE%E5%AE%9A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面：前面一堆都了解了解，重点在后面一个关于求候选码的算法（要是题里面没有给主属性，就要通过这个方法求哪些是主属性，哪些不是了，所以还是挺实用的） 候选码定义: 设K为关系模式R的属性(组)，若K→FU，则称K为R的 候选码。 主码：若R有多个候选码，则可以从中选定一个作为R的主码。 主属性：包含在任一个候选码中的属性，称作主属性。 非主属性：不包含在任一个候选码中的属性，称作非主属性(或非码属性)。 全码：关系模式的码由全部属性构成。 注: 码或是某一函数依赖的左部, 或是一个属性组。 引例：求出关系模式R的所有候选码：U={ A , B , C , D , E }F={AB→C, B→D, C→E, EC→B, AC→B } 解： 验证AB是否是码, 须证明 AB→FABCDE是否成立?∵AB→C(已知), 而AB→AB(自反), ∴AB → ABC(合并)∵B→D(已知), ∴AB→AD(增广), ∴AB → ABCD(合并)∵C→E(已知), AB→C(已知), ∴AB → E(传递) 于是 AB → ABCDE(合并) 同理可证：AC也是一个候选码 上述例题实际上就是利用Amstrong公式，最后得到一个属性集可以推出U（关系模式的全集） 练习： 根据码的定义，求关系模式R的所有候选码。U={ A , B , C , D }， F={A→ B, C→B } 答：ACD 关于2NF的结论 不存在非主属性的关系模式属于2NF。 （没有非主属性） 全码关系模式属于2NF。 （没有非主属性） 码只由一个属性组成的关系模式属于2NF。（不会有部分依赖） 二目关系模式属于2NF。 （码或是一个属性，或是全码） 若R属于1NF，但R不一定属于2NF。例如, 关系模式 S(S#, SN, SD, DEAN, C#, G) 关于3NF的结论 不存在非主属性的关系模式属于3NF。 （没有非主属性） 全码关系模式属于3NF。 （没有非主属性） 二目关系模式属于3NF。 （不会存在传递依赖） 若R属于3NF，那么R也属于2NF。（可证明，反证） 若R属于2NF，但R不一定属于3NF。例如，关系模式 S_SD(S#, SN, SD, DEAN) BCNF定义：关系模式R ∈1NF，对于属性组X和Y，若X→Y且Y ∉ X时X必含有码，则R ∈BCNF 由BCNF的定义，对于非平凡的函数依赖: X → Y X包含码，或者X本身就是码（换句话说，X是一个超码） 所有非主属性对每一个码都是完全函数依赖， 即, 若R∈BCNF, 则R∈2NF。 所有的主属性对每一个不包含它的码也是完全函数依赖。 没有任何属性完全函数依赖于非码的任何一组属性。 若R∈BCNF, 则必有R∈3NF; 反之不一定成立 铛铛铛！！！敲黑板，候选码的求解算法以下算法会涉及到求属性集的闭包，函数依赖集和属性集闭包传送阵 设关系模式R 将R的所有属性分为 L、 R、N和 LR四类，并令X代表L、N两类，Y代表LR类。 L类: 仅出现在F的函数依赖左部的属性； R类: 仅出现在F的函数依赖右部的属性； N类: 在F的函数依赖左右两边都不出现的属性； LR类:在F的函数依赖左右两边都出现的属性 。 求属性集闭包X+，若 X+包含了R的全部属性则X即为R的唯一候选码, 转5; 否则, 在Y中取一属性A，求属性集闭包(XA)+，若(XA)+包含了R的全部属性，则转4；否则，调换一属性反复进行这一过程，直到试完所有Y中的属性。 如果已找出了所有的候选码，则转(5)；否则在Y中依次取2个、3个、…属性，求X与它们的属性集闭包，直到其闭包包含R的全部属性。 停止，输出结果。 例1： 设关系模式R(A, B, C, D), 其函数依赖集：F={D→B, B→D, AD→B, AC→D}，求R的所有候选码。 解: L类: A, C R类: N类: LR类: B, D因为(AC)F+=ACDB，所以AC是R的唯一候选码 例2：设关系模式R(A, B, C, D, E, P), 其函数依赖集：F={A→D, E→D, D→B, BC→D, DC→A}，求R的所有候选码。 解: L类: C, ER类:N类: PLR类: A, B, D因为(CEP)F+=CEPDBA，所以CEP是R的唯一候选码。 例3： 设关系模式R(S, D, I, B, O, Q), 其函数依赖集:F = { S→D, I→B, B→O, O→Q, Q→I }，求R的所有候选码。 解: L类(S); R类(D) ; N类(无) ; LR类(I, B, O, Q)因为S+=SD, 所以S不是R的候选码； 因为(SI)+=SIDBOQ，所以SI是一个候选码； 因为(SB)+=SBDOQI，所以SB也是一个候选码； 因为(SO)+=SODQIB，所以SO也是一个候选码； 因为(SQ)+=SQDIBO，所以SQ也是一个候选码。]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（补充）——数据库设计和E——R模型]]></title>
    <url>%2F2017%2F11%2F08%2F2017-11-08-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%92%8CE%E2%80%94%E2%80%94R%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[实体—联系模型 实体集 实体（entity）：现实世界中一个可以区别于其他对象的一个“事物”或对象 实体集（entity set）：相同类型（即具有相同性质/属性）的实体的集合 外延（extension）：属于实体集的实体的实际集合 ps: 实体集和外延的关系类似于之前讲的模式和实例的关系 属性（attribute）：实体集中每个成员所具有的描述性性质 值（value）：每个实体的每个属性都有一个值 联系集 联系（relationship）：多个实体间的相互关联 联系集（relationship set）： 相同类型联系的集合 实体集之间的关联称之为参与：实体集E1, E2, E3 参与 联系集R 联系也可以具有 描述性属性 实体在联系中扮演的功能称为角色 参与联系集的实体集的数目称为联系集的度， 二元联系集的度为2 属性 域（domain）/ 值集：每个 属性 都有一个 可取值的集合 ，称为该属性的 域 或 值集 简单（simple） 和复合（composite）属性 简单属性不可以再分成更小的部分，而复合属性可以(例如下面的name即为复合属性) 单值（single-value）和多值（multivalued）属性 单值：一个实体在的单值属性只对应一个值 多值：一个实体的多值属性可以对应多个值（如，phone_number） 派生（derived）属性 派生属性的值可以从别的相关属性或实体派生出来 eg.:银行账户的余额可以从账户的存取款明细中计算出来 派生属性在原则上是不用保存的，但是有时候保存派生属性可以节约计算时间（空间换时间） 约束 映射基数约束 一对一（one-to-one） 一对多（one-to-many） 多对一（many-to-one） 多对多（many-to-many） 参与约束 全部参与：实体集E的每一个实体都参与到联系集R的至少一个联系中 部分参与：实体集E中只有部分实体参与到联系集R的联系中 码 超码 候选码 主码 从实体集中删除冗余属性 要点： 删除其他实体的主键 其他实体的主键相当于外建的存在，一般属于联系集的属性 举个栗子： instructor(ID, name, dept_name, salary)，其中ID为主键 department(dept_name, building, budget)，其中dept_name为主键 属性dept_name在两个表中都出现了，所以它属于冗余属性，他又是department的主键，故应该将其从instructor表中移除（实际数据库实现的时候instructor表中是有一个dept_name属性的，他作为一个外建存在，实际上是两者的联系集是简单的1对多的关系，便没有单独成表，而是采用外键相联系） 实体——联系图 基本结构 分成两部分的矩形 代表 实体集 菱形 代表 联系集 未分割的矩形 代表 联系集的属性 线段 将实体集连接到联系集 虚线 将联系集属性连接到联系集 双线 显示实体在联系集中的参与度(用双线与联系集相连表示全部参与) 双菱形 代表连接到弱实体集的 标志性实体集 映射基数 一对一 一对多 多对一 多对多 balabala，图画起来太麻烦了，其他的直接看书，下面聊一聊弱实体集 弱实体集 定义：没有足够的属性以形成主码的实体集称之为 弱实体集（weak entity set） 先举个栗子：(由于简书不支持下划线的写法，所以下面表中所有的主码都用斜体表示) course (course_id, titles, credits) section (sec_id, semester, year) 对于上面的两个实体集，参与如下联系集 sec_course(course_id, sec_id, semester, year) 上面的section实体集实际上就是一个弱联系集 一个section实体如果不与一个course对相关联是毫无意义的，并且只有sec_id, semester, year三个属性也是决定不了一个section的 弱实体集必须于另一个称作标识（identifying）或属主和实体集（owner entity set）的实体集相关联才有意义 虽然弱实体集没有主码，但是本身仍要有在依赖于强实体集的基础上的进一步区分的方法，弱实体集的分辨符/部分码（discriminator）便可以用来做进一步的区分 上述例子中的sec_id, semester, year便组成了section的分辨符 在画ER图的时候，组成分辨符的属性底下画虚线（可参见教材 图7-5） 弱实体集的主码由 标识实体集的主码 加上 该弱实体集的分辨符 构成 ER图中的表示 组成分辨符的属性底下画虚线，而不是实线 关联弱实体集和标识性强实体集的联系集以双菱形表示 接着，只需要把教材图7-15的图看懂理解，ER图的绘制基本上就没有毛病了 ER图转换为关系模式这个不难下面简单列几点注意事项 复合属性 将每个子属性单独作为一个属性来处理 派生属性 不显示表示出来 多值属性 单独成表 弱实体集转换 对于从弱实体集转换而来的模式，该模式的主码由其所依赖的强实体集的主码与弱实体集的分辨符组成 联系集 多对多的情况一定单独成表 联系集拥有描述性属性的情况单独成表 其它情况下均可不单独成表 一对一情况下讲任意实体集的主键作为另一个实体集的外建均可 一对多和多对一的情况下，将“一”端的主键作为”多”端的外建]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（十二）——函数依赖理论和分解算法]]></title>
    <url>%2F2017%2F11%2F01%2F2017-11-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%90%86%E8%AE%BA%E5%92%8C%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[函数依赖理论 逻辑蕴涵 定义： 存在如下条件 关系模式：r(R) 依赖集：F （由一个或多个依赖组成） 依赖：f 若r(R)满足F ==&gt; r(R)满足f 我们称 F 逻辑蕴涵 f ps: 其中f可由F通过Armstrong公理推得 举个栗子： 给定关系模式 r(A, B, C, G, H, I) F包含如下依赖 A &rarr; B A &rarr; C CG &rarr; H CG &rarr; I B &rarr; H 函数依赖f : A &rarr; H 其中 f 被 F 逻辑蕴涵 由Amstrong传递公理可知：A &rarr; B, B &rarr; H ==&gt; A &rarr; H 函数依赖集的闭包 令 F 为一个函数依赖集。则 F的闭包 是 被 F 逻辑蕴涵的所有函数依赖的集合 记作：F+ Armstrong公理（Armstrong’s axiom） 公理是科学的客观规律，不需要自己证明，直接用就行 Armstrong 公理 自反律（reflexivity rule）。若α为一个属性集，且β⊆α， 则α&rarr;β 举个栗子：(A, B)&rarr;A 增补律（augmentation rule）。若α&rarr;β成立且γ为一属性集，则γα&rarr;γβ 举个栗子：(A, B)&rarr;C ==&gt; (A, B, D, E)&rarr;(C, D, E) 传递律（transitivity rule）。若α&rarr;β和β&rarr;γ成立，则 α&rarr;γ 成立 举个栗子：A&rarr;B, B&rarr;C ==&gt; A&rarr;C Armstrong公理是完备的，对于一个给定的函数依赖集F，通过Armstrong公理可以产生全部的F+ Armstrong公理的一些推论 可由Armstrong公理直接推得，也可以当做公理使用 合并律（union rule）。若α&rarr;β和α&rarr;γ成立，则α&rarr;βγ 举个栗子：A&rarr;B, A&rarr;C ==&gt; A&rarr;(B, C) 分解律（decomposition rule）。若α&rarr;βγ成立，则α&rarr;β和α&rarr;γ成立 举个栗子：A&rarr;(B, C) ==&gt; A&rarr;B, A&rarr;C 伪传递律（pseudotransitivity rule）。若α&rarr;β和γβ&rarr;δ成立，则αγ&rarr;δ成立 举个栗子：A&rarr;B, (B, C)&rarr;D ==&gt; (A, C)&rarr;D 属性集的闭包 令α为一个属性集，我们将函数依赖集 F 下被α集合所函数确定的所有属性的集合为称为F下α的闭包 记作：α+ 伪代码如下：1234567result := α repeat for each 函数依赖 β→γ in F do begin if β ⊆ result then result := result ∪ γ end until(result 不变) 正则覆盖（极小函数依赖集） 如果去除函数依赖中的一个属性不改变函数依赖集的闭包，则称该属性是无关的 F的正则覆盖 Fc 是一个依赖集，使得F逻辑蕴涵Fc 中的所有依赖，并且Fc 逻辑蕴涵F中的所有依赖。此外，Fc 必须具有如下性质 ： Fc 中任何函数依赖都不含无关属性 Fc 中函数依赖的左半部都是唯一的。即Fc 中不存在两个依赖α1&rarr;β1和α2&rarr;β2， 满足α1=α2 无损分解 如果用两个关系模式r1(R)和r2(R)替代r(R)时没有信息损失，则我们称该分解时无损分解（lossless decomposition） SQL 表示 123-- 下面查询的结果与r具有相同结果的元组集SELECT *FROM r1 natural join r2 关系代数表示： ∏R1(r) ⋈ ∏R2(r) = r 分解算法（下回分解） http://qjm253.cn/2017/11/11/2017-11-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（十一）—— 范式]]></title>
    <url>%2F2017%2F11%2F01%2F2017-11-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一般而言，关系数据库的设计目标是生成一组关系模式，使我们存储信息时避免不必要的冗余，并且让我们可以方便地获取信息。这是通过设计满足适当范式（normal form）的模式来实现的。 引例 首先有如下两个模式 instructor( ID, name, dept_name, salary ) department( dept_name, building, budget ) 若将上面两个模式合并成一个大的模式 inst_dept(ID, name, salary, dept_name, building, budget) 存在数据冗余（building和budget被存储了多份，实际上每个系的楼和预算只要存一次就好了） 存在插入、删除和更新异常 需要分解成更小的模式 并不是所有模式的分解都是有益的 employee(ID, name, street, city, salary) 分解成下面两个模式 employee1(ID, name) employee2(name, street, city, salary) 由于可能存在同名的可能，所以分解以后导致了数据的丢失 比如有两个叫Sunny的人，我们用其中一个Sunny的ID去查询他的地址信息的时候，因为存在两份信息相互混淆，导致得不到正确的结果，但是在分解之前通过ID是可以得到唯一的地址的 有损分解和无损分解 像上面的例子中，分解以后导致信息丢失的分解称之为有损分解（在实际进行分解时要避免这种分解） 反之则称之为无损分解（无损分解在重新合并后可以得到和分解之前一致的状态） 函数依赖 什么是函数依赖？ 有如下模式 U = {Sno, Sname, Cno, Sdept, Mname, Grade} (分别代表学号、学生姓名、课程号、系、系主任、分数) Sname = f(Sno) ==&gt;学生的姓名函数依赖于学号 记作：Sno→Sname 读作：Sno推出Sname 非平凡函数依赖和平凡函数依赖 X 和 Y 为模式U中一个或多个属性的集合 非平凡函数依赖 X→Y，但Y∉X 平凡函数依赖（包含冗余） X→Y，且Y∈X 完全函数依赖和部分函数依赖 写函数依赖时，完全函数依赖和部分函数依赖的写法中，P和F是写在箭头的正上方的，由于Markdown不能很好的展现，就标在了箭头的右上角所以用下面的表示法： &rarr;F ：完全依赖 &rarr;P ：部分依赖 完全函数依赖 在模式R(U)中X→Y，但是对于任意X的真子集X’， 都没有X‘→Y, 则称Y完全函数依赖于X，记作X&rarr;FY X实际上就是能推出Y的最小集 例如：(Sno, Cno)→FGrade 部分函数依赖 在模式R(U)中X→Y，存在某个X的真子集X’， 有X‘→Y, 则称Y部分函数依赖于X，记作X&rarr;PY 例如：(Sno, Cno)→Sdept 而实际上：Sno→Sdept 也是可行的，上面的依赖关系中，Cno是冗余的 传递函数依赖 X→Y, Y→Z ==&gt; X→Z 码 超码、候选码和主码 可以沿用SQL中码的概念 超码是可以唯一标识一个元组的属性集（可以有多个） 候选码是每个超码中去除不必要属性但是仍然能够标识一个元组的最精简属性集（可以有多个） 主码只有一个，在候选码中选一个当做主码 用函数依赖来定义 K为R&lt; U, F &gt;中的属性或属性组合，若K→FU(即U完全依赖于K)，则称K为R的候选码，若候选码多与一个，则选择其中一个作为主码 主属性与非主属性 主属性：包含于某个候选码的属性 非主属性：不被任何候选码包含的属性 范式 首先还是构造一个例子 R&lt; U, F&gt; U = {Sno, Sdept, Sloc, Cno, Grade} (分别代表学号、系、系所在楼、课程号、分数) F = {(Sno, Cno)&rarr;F Grade, Sno&rarr;Sdept, (Sno, Cno)&rarr;P Sdept, Sno&rarr;Sloc, (Sno, Cno)&rarr;PSloc} 主属性：Sno, Cno 非主属性：Sdept, Sloc, Grade 上面的依赖关系可以用下面的图示表示 第一范式（1NF） 一个域是原子的(atomic)，则该域的元素被认为是不可分的单元 比如name属性就可以不是原子的，name(first_name, middle_name, last_name) 一个关系模式R属于第一范式（1NF）==&gt;R上的所有属性都是原子的 上述例子中的每个属性都是原子的，所以满足第一范式 第二范式（2NF） R ∈ 1NF，并且每一个非主属性完全依赖于码（实际上就是在1NF的基础上，去除了非主属性对码的部分函数依赖） 上述例子中存在非主属性对码的部分函数依赖，故不满足2NF 对上述例子作出如下分解 R1&lt; {Sno, Cno, Grade}, {(Sno, Cno)&rarr;FGrade} &gt; R2&lt; {Sno, Sdept, Sloc}, {Sno&rarr;Sdept, Sdept&rarr;Sloc}&gt; ps:其中R2隐含了Sno&rarr;Sloc (由之后即将学习的AmStrong公理可以推算出来) 上面的依赖关系可以用下面的图示表示 经过上面的分解之后，每一个非主属性都完全依赖于码了，所以分解之后的模式满足2NF 第三范式（3NF） R∈2NF, 并且不存在非主属性对码的传递依赖（实际上就是在2NF的基础上去除了非主属性对码的传递依赖） 上述经过分解以后的模式中存在非主属性对码的传递依赖，故不满足3NF Sno&rarr;Sdept, Sdept&rarr;Sloc ==&gt; Sno&rarr;Sloc 对上面的模式进行进一步的分解 R1&lt; {Sno, Cno, Grade}, {(Sno, Cno)&rarr;FGrade} &gt; R2&lt; {Sno, Sdept}, {Sno&rarr;Sdept} &gt; R3&lt; {Sdept, Sloc}, {Sdept&rarr;Sloc} &gt; 上面的依赖关系可以用下面的图示表示 经过上面的进一步分解之后，就不存在非主属性对码的传递依赖了，故进一步分解之后的模式满足3NF 2NF和3NF中的约束都是针对于非主属性的。在日常开发的时候只要ER图设计好，一般都是满足到3NF的，3NF也是可以保证无损分解的最高范式 Boyce-Codd范式（BCNF） R ∈ 3NF， 并且不存在主属性间的部分函数依赖和传递函数依赖 （实际上就是在3NF的基础上，去除了主属性的部分函数依赖和传递函数依赖） 举个栗子 R&lt; U, F &gt; U = {S, T, J} F = { (S, J)&rarr;T, (S, T)&rarr;J, T&rarr;J } 从上面的函数依赖易判断出：S、T、J都是主属性 因为{S, J}， {S, T} 都是候选码 因为不存在非主属性，所以该模式已经满足到3NF 上面模式的依赖可以用下面的图示表示 上面的栗子中的模式主属性中存在部分函数依赖，所以不满足BCNF 作出如下分解 R1&lt; {S, T, J}, { (S, J)&rarr;T, (S, T)&rarr;J } &gt; R2&lt; {T, J}, { T&rarr;J } &gt; 上面的依赖关系可以用下图表示 经过分解之后的模式就不存在主属性间的部分函数依赖和传递函数依赖， 故满足BCNF 当我们分解不属于BCNF的模式的时候，产生的模式中可能有一个或多个不属于BCNF。在这种情况中，需要进一步分解，其最终结果是一个BCNF的模式集合 更高的范式还有第四范式和第五范式，但是应用较少，且考纲不要求，这里就不再赘述了]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017级Android第一次例会]]></title>
    <url>%2F2017%2F10%2F24%2F2017-10-24-2017%E7%BA%A7Android%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BE%8B%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[Android 前世今生 版本名称 版本号 发布时间 API版本 官方支持状态 Android (Alpha) 1.0 September 23, 2008 1 不支持 Beta (Internally known as “Petit Four”) 1.1 February 9, 2009 2 不支持 Cupcake（纸杯蛋糕） 1.5 April 27, 2009 3 不支持 Donut（甜甜圈） 1.6 September 15, 2009 4 不支持 Eclair（闪电泡芙） 2.0 – 2.1 October 26, 2009 5 – 7 不支持 Froyo（冻酸奶） 2.2 – 2.2.3 May 20, 2010 8 不支持 Gingerbread（姜饼） 2.3 – 2.3.7 December 6, 2010 9 – 10 不支持 Honeycomb（蜂巢） 3.0 – 3.2.6 February 22, 2011 11 – 13 不支持 Ice Cream Sandwich（冰淇淋三明治） 4.0 – 4.0.4 October 18, 2011 14 – 15 不支持 Jelly Bean（果冻豆） 4.1 – 4.3.1 July 9, 2012 16 – 18 不支持 KitKat（奇巧巧克力棒） 4.4 – 4.4.4 October 31, 2013 19 支持 Lollipop（棒棒糖） 5.0 – 5.1.1 November 12, 2014 21 – 22 支持 Marshmallow（棉花糖） 6.0 – 6.0.1 October 5, 2015 23 支持 Nougat（牛轧糖） 7.0 – 7.1.2 August 22, 2016 24 – 25 支持 O/Oreo（奥利奥） 8.0 August 22, 2017 26 支持 开发语言组里主要以Java语言为主，同时会介绍一些Kotlin开发Android。90% Java + 10% Kotlin Java Kotlin C++ … 开发环境 Eclipse（拒绝） Visual Studio Android Studio(推荐) 2.3（稳定版）==&gt;不支持Kotlin 3.0（pre）==&gt;支持Kotlin，对Java8有较好的支持 Java 环境配置：Kotlin 可以基于JVM，不需要额外配置，IDEA中可直接创建Kotlin项目 点此传送进行Java环境配置（http://www.jianshu.com/p/21abe20aadf2） 最好是下专业版IDEA（专业版需要注册码，可以用学校邮箱注册学生账号，可免费一年，过期需要手动再次激活） Java书籍推荐 入门：《Java核心技术 卷Ⅰ》、《疯狂Java讲义》 进阶：《Java编程思想》、《Java核心技术 卷Ⅱ》 强烈安利：《Effective Java》（这本书建议对Java有一定的熟悉程度，并有一定开发经验之后再看，会受益匪浅） 电子书资源： 点我下载（http://pan.baidu.com/s/1boXCxbT） Android环境配置 Google Developer （https://developers.google.cn/） Google Android Developer IDE 下载： 建议下载最新的Android Studio3.0预览版（稳定版和预览版可以共存，所以你也可以2.3和3.0都装） 官网下载 Android中文社区，可下载2.3.3和3.0预览版稳定版AS（http://www.android-studio.org/） 环境配置 CSDN教程 极客学院视频教程 极客学院视频 极客学院离线视频资源]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（十）——关系代数]]></title>
    <url>%2F2017%2F10%2F17%2F2017-10-17-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[基本运算每一种基本运算的结果都是一个新的关系，可以用这个关系继续参与运算，借此便可进行复杂的运算 选择运算（select）==&gt;相当于SQL语句中的WHERE子句的职能 格式：σ选择谓词(关系) 举个栗子： σSAL&gt;1000(EMP) 上式表示取出查询工资大于1000的所有员工的信息 等价于下面的SQL语句123SELECT *FROM EMPWHERE SAL &gt; 1000 选择谓词的分类 比较：=、≠、&lt;、≤、&gt;和≥ 连词：and(∧)、or(∨)和not(¬)==&gt;可以将多个谓词合并成一个大的谓词 可以包括两个属性（字段的比较）：σCOMM&gt;SAL(EMP)表示抽成大于工资的人 投影运算（project）==&gt;相当于SQL语句中的SELECT子句的职能 格式：∏字段序列(关系) 举个栗子 ∏ENAME,SAL(EMP) 上式表示查看所有员工的姓名和工资 等价于下面的SQL语句12SELECT ENAME, SALFROM EMP 关系的组合运算==&gt;就像SQL中select、where子句那样的组合效果 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) 上面的式子求出了所有工资大于1000的员工的名字和工资(实际上就是将σSAL&gt;1000(EMP)执行的结果当做一个临时的关系，参与了投影运算得到的) 等价于下面的SQL语句123SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000 事实关系的组合运算就是那么简单，分析的时候把每个简单运算的结果当做一个新的关系参与后面的运算，这样一层层剥开来，再复杂的语句也变得容易分析 并运算（union）==&gt;相当于SQL中UNION关键字的职能 格式：（关系r）∪（关系s） 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) ∪ ∏ENAME,SAL(σCOMM&gt;300(EMP)) 上面的式子求出了所有工资大于1000或抽成大于300的员工的姓名和工资，等价于下面的SQL语句 1234567SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000UNIONSELECT ENAME, SALFROM EMPWHERE COMM &gt; 300 几点需要额外注意的： 此处的并运算是集合运算，所以结果是去重的，结果集中不存在重复的元组（而在SQL语句中，指定UNION ALL是可以保留重复的） 关系r与关系s必须是同元的，即它们的属性的数目要求必须相同（这就和SQL语句中UNION使用的时候要求上下两个语句的字段数相同是一样的意思） 关系r和关系s对应位置的属性域应该是类型兼容的（同样和SQL中UNION使用时，每个对应位置字段类型兼容是一样的意思） 集合的差运算（set-defference）==&gt;相当于SQL语句中的EXCEPT 格式：(关系r)-(关系s) 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) - ∏ENAME,SAL(σCOMM&gt;300(EMP)) 上面的式子表示工资大于1000但抽成不大于300的员工的姓名和工资，等价于下面的SQL语句1234567SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000EXCEPTSELECT ENAME, SALFROM EMPWHERE COMM &gt; 300 几点需要额外注意的： 此处的注意同上面的并运算的注意事项 笛卡尔积运算（Cartesian-product）==&gt;等价于SQL语句中两个表进行笛卡尔积（全匹配）得到的结果，即SQL中进行多表连接时不指定连接条件的情况 格式：(关系r)×(关系) 举个栗子： EMP × DEPT 上面的式子表示两个表进行全匹配，等价于下面的SQL语句12SELECT *FROM EMP, DEPT 下面两个式子是等价的 ∏ENAME,DNAME(σEMP.DEPTNO=DEPT.DEPTNO(σJOB=”MANAGER”(EMP×DEPT))) ∏ENAME,DNAME(σEMP.DEPTNO=DEPT.DEPTNO((σJOB=”MANAGER”(EMP))×DEPT) 下面是对这两个式子的SQL转化，转化之后就一目了然了1234567891011-- 对应第一个式子SELECT ENAME, DNAMEFROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNOWHERE JOB = 'MANAGER'-- 对应第二个式子SELECT ENAME, DNAMEFROM DEPT JOIN (SELECT * FROM EMP WHERE JOB = 'MANAGER') ON EMP.DEPTNO = DEPT.DEPTNO 更名运算（rename）==&gt;等价于SQL语句中as的职能 格式：ρX(A1,A2,…,An)(E)==&gt;表示的是将关系E更名为X，Ai表示的是给E的第i个字段指定别名 举个栗子 ∏ENAME,DNAME(σe.DEPTNO=d.DEPTNO(σJOB=”MANAGER”(ρe(EMP)×ρd(DEPT)))) 上面式子含义就不解释了，是上面举的栗子，只是引入了更名运算符，它等价于下面的SQL语句123SELECT ENAME, DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNOWHERE JOB = 'MANAGER' 来，学习完上面的基本运算，来做个实际的栗子，要求找到员工表中的最高工资（因为目前还没有介绍类似SQL中组函数的操作，后面会介绍。所以通过以下方式来实现） step1: 找到所有不是最高工资的人 ∏e1.SAL(σe1.sal &lt; e2.sal(ρe1(EMP)×ρe2(EMP))) step2: 用所有的员工减去上面的员工，即得到最高工资 ∏SAL(EMP) - ∏e1.SAL(σe1.sal &lt; e2.sal(ρe1(EMP)×ρe2(EMP))) 在书写关系运算表达式的时候可以用序列号代替字段名（但是不直观，不常用，一般不用） 举个栗子 ∏$6(σ$6 &lt; $14(EMP×EMP)) 等价于下面的运算 ∏e1.SAL(σe1.sal &lt; e2.sal(ρe1(EMP)×ρe2(EMP))) 附加运算附加运算是由基本运算组成的，不能增强基本运算的运算能力，但是能简化运算 集合交运算（intersection）==&gt;相当于SQL语句中INTERSECT关键字的职能 格式：(关系r)∩(关系s) 因为集合交运算是可以由前面的基本运算组合产生的，所以把它归到附加运算 A ∩ B &lt;=&gt; A - (A - B) 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) ∩ ∏ENAME,SAL(σCOMM&gt;300(EMP)) 上面的式子表示工资大于1000并且抽成大于300的员工的姓名和工资，等价于下面的SQL语句1234567SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000INTERSECTSELECT ENAME, SALFROM EMPWHERE COMM &gt; 300 自然连接（natural join）==&gt; 相当于SQL语句中的NATURAL JOIN 格式：(关系)⋈(关系) 自然连接的形式化定义 r,s是两个关系 R，S是上面两个关系对应的关系模式（其实就是上述两个关系各自的属性列表） R ∩ S 表示r和s的同名属性列表 R ∪ S 表示出现在r或s上的属性名列表(是一个集合，不包同名属性，存在同名属性会去重) R - S 表示出现在R上，但不出现在S上的属性名列表 则可做如下定义 r⋈s = ∏R∪S(σr.A1=s.A1 ∧ r.A2=s.A2 ∧ … ∧ r.An=s.An(r×s)) ，其中 R∩S={A1, A2, …, An} 举个栗子 ∏name, course_id(instructor ⋈ teaches) 上面的式子列出了所有老师的名字以及其所授课程的id，等价于下面的SQL语句12SELECT name, course_idFROM intructor natural join teaches ps: 两个关系模式执行自然连接以后属性的排布顺序： 排在最前面的是两个关系模式相同的属性 其次是只属于第一个关系模式的属性 最后是只属于第二个关系模式的属性！！！所以所两个关系模式进行自然连接以后，总的属性的个数是减少了，具体减少的个数等于同名属性的个数 theta连接==&gt;是带限定条件的笛卡尔积 格式：(关系)⋈Θ(关系) 形式化定义： r ⋈Θ s = σΘ(r × s) 举个栗子 ∏name, course_id(instructor ⋈instructor.ID = teaches.ID ∧ instructor.salary &gt; 5000 teaches) 上面的式子表示列出所有工资大于5000的老师的名字以及其所授课程的id， 等价于下面的SQL语句1234-- 使用 join...on 的时候 on 后面写连接条件，然后将其它条件放在where里SELECT name, course_idFROM instructor join teaches on instructor.ID = teaches.IDWHERE instructor.salary &gt; 5000 除运算（division） 这个在书上没讲，是老师上课的时候补充的 格式：(关系)÷(关系) 形式化定义：R÷S = ∏R∪S( ( ∏R-S(r) × S ) - ∏R-S, S(r) ) 笔者还有一篇介绍用SQL实现关系代数中除运算的文章=&gt;点我传送 解释起来挺麻烦的，这边给出一个博客链接：点我传送 赋值运算 就是将一个关系表达式的结果赋值取一个临时的名字，就相当于定义了一个临时关系。这个操作就相当于SQL中with语句的职能 格式： temp_name ← 关系表达式 举个栗子：temp1 ← R × Stemp2 ← σr.A1=s.A1 ∧ r.A2=s.A2 ∧ … ∧ r.An=s.An(temp1)result = ∏R∪S(temp2) 上面的式子等价于： result = r⋈s 外连接运算 左外连：⟕ 右外连：⟖ 全外连：⟗ 扩展运算扩展运算是不能用基本的关系代数运算来实现的一类查询，可以满足复杂的查询需求 广义投影（Generalized-projection） 与基本运算中的投影运算相比，就是多了允许在选择列表中出现表达式（在基本运算中的投影的选择列表中只能出现字段） 格式：∏F1, F2, … , Fn(E) 其中F1, F2, … , Fn可以是字段或者是表达式 E代表一个关系 举个栗子： ∏name, sal * 1.2(instructor) 上面的式子表示查出所有老师的名字，以及涨了20%以后的工资，等价于下面的SQL语句 12SELECT name, sal * 1.2FROM instructor 聚集函数（Aggregation function） 聚集函数的符号表示是用书写体G，这边就直接用G指代了 聚集函数是输入值的一个汇聚，以多个值作为输入，将一个单一的值作为返回结果 多重集：使用聚集函数对其进行操作的汇集中，一个值可以出现多次，值出现的顺序是无关紧要的。这样的汇集称为多重集（就比方说统计一个员工表中员工的数量，然后我们通过统计员工的名字来统计，即便是同名的员工我们也是计算的） 格式： G1, G2, … , GnGF1(A1), F2(A2), …, Fn(An)(E) 其中前面的G1, G2, … , Gn表示的是分组条件 后面的F1(A1), F2(A2), …, Fn(An)是聚集函数表达式列表 Fi(i = 1, 2, …, n)表示聚集函数：sum、count、average、max、min A1, A2, … , An代表字段 举个栗子： A1, A2Gsum(A3)(∏A1, A2, …, An(σP(r1×r2×…×rm)) ) 等价于下面的SQL语句1234SELECT A1, A2, sum(A3)FROM r1, r2, ..., rmWHERE PGROUP BY A1, A2 上面的聚集函数在进行计算的时候采用的都是多重集，也就是相同的值可以多次重复计算（也就是在执行聚集函数的时候是不去重计算），如果要去重计算的话就要采用下面的几个函数写法 sum_distinct count_distinct averag_distinct max_distinct min_distinct 举个栗子： A1, A2Gsum_distinct(A3)(∏A1, A2, …, An(σP(r1×r2×…×rm)) ) 上面的式子等价于下面的SQL语句1234SELECT A1, A2, sum(distinct A3)FROM r1, r2, ..., rmWHERE PGROUP BY A1, A2]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（九）——对违反约束的处理]]></title>
    <url>%2F2017%2F10%2F15%2F2017-10-15-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E8%BF%9D%E5%8F%8D%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章的一些尾巴，然后开始讲第六章的关系代数笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们构造一些简单表 1234567891011121314151617181920212223242526272829303132333435-- 执行下面的语句构造表CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE CASCADE ON UPDATE CASCADE);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 级联操作在指定外键以后，由于存在完整性约束，所以在执行删除或更新的时候由于语句可能会破坏完整性约束而执行失败。因此可以在定义外键的时候声明为级联删除和级联更新(是一种对违反参照完整性约束时的处理方式) 使用方式1234567CREATE table 表名( ... FOREGIN KEY (字段序列) REFERENCES 表名(字段序列) ON DELETE CASCADE ON UPDATE CASCADE, ...) 级联删除（ON DELETE CASCADE） 级联删除是在定义外键时指定的，但是却会在执行删除语句时产生影响 举个栗子 我们先不指定级联 12345678910111213141516171819202122232425262728293031323334DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id));INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 然后执行下面的删除操作 123-- 下面我们试图删除中国的信息，但是在person表里有一条数据引用了中国，所以因为参照完整性约束的存在，所以这条语句会执行失败DELETE countryWHERE country_id = 1 接下来我们重新构造一遍（当然直接用DDL语句更新也是可以的）–并在构造person表时指定了级联删除 1234567891011121314151617181920212223242526272829303132333435DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE CASCADE);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 然后再次执行下面的删除操作 123-- 此时执行会发现语句成功执行了，不但删除了中国的信息，连带person表中引用了中国信息的所有数据都被删除了DELETE countryWHERE country_id = 1 上面的例子便很好的说明了级联删除的作用。如果我们视图删除外键参照键所在表（此处为country表）的某条数据A（此处是中国的信息），而这条数据又被外键所在表的一条或多条数据B所关联（此处person表中Sunny的country_id关联了country表中中国的id）。在指定了级联删除的情况下，删除A会连带着删除所有满足条件的B 当然在实际使用的时候用的还是比较少的，因为参照完整性约束在一定程度上可以防止数据的误删除，对数据库的完整性起了一定的保护作用，如果指定了级联删除，这层保护就失效了。所以还是视情况而用 级联更新（ON UPDATE CASCADE） 类似的，级联更新和级联删除一样，如果我们更新时违反了完整性约束，同样更新操作不被拒绝，而是级联更新 举个栗子（我们在上面操作的基础上执行，上面构造时指定了级联删除，但是没指定级联更新） 1234-- 我们试图执行下面的更新操作，我们把修改English的country_id， 但是由于person表中还有数据的country_id=2,如果下面的更新成功执行，则会导致person表中存在country_id=2的数据，而country中却没有对应数了，违反参照完整性约束，故下面的语句执行失败UPDATE countrySET country_id = 4WHERE country_id = 2 同样的，我们重新构造一下，此时指定级联更新 123456789101112131415161718192021222324252627282930313233343536DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE CASCADE ON UPDATE CASCADE);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 此时再执行一下上面的更新语句 1234-- 由于指定了级联更新，所以会发现下面的语句执行成功了，不但更改了country表中的数据，连带着person表中的数据也一并更新了UPDATE countrySET country_id = 4WHERE country_id = 2 上面就是级联更新的效果 另一类对违反完整性约束的处理 SET DEFAULT 一旦违反完整性约束，就将参照域（此处为country_id）设置为默认值 SET NULL 一旦违反完整性约束，就将参照域（此处为country_id）设置为NULL 举个栗子 执行下面的构造 1234567891011121314151617181920212223242526272829303132333435DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE SET NULL);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 然后执行下面的删除操作 123-- 下面的删除操作成功执行，但不是级联删除，而是把person表中原来country_id=1的数据的country_id都设成了NULLDELETE countryWHERE country_id = 1 延迟检查这是由于数据库默认是在执行每一条SQL语句的时候都进行完整性约束的检查，导致有些操作无法进行。延迟操作就将完整性约束的检查延迟到了事务结束的时候检查（大多数数据库不支持，比如SQL Server， 但Oracle数据支持） 由于不常用，SQL Server也不支持，这里就讲一下概念，不举实际的栗子了。 假设上面的例子表中没有指定延迟检查 执行下面的语句1234567-- 执行下面两条语句是会出错的，因为插入第一条数据的时候，由于完整性约束的存在，要求country表中要有country_id=4的数据，但是这个数据目前还不存在（所以只要先执行第二条语句，这两个语句才能成功执行）INSERT INTO person (person_id, name, country_id) VALUES ( 4, 'Jerry', 4);INSERT INTO country (country_id, country_name) VALUES ( 4, 'France'); 而如果指定了延迟检查呢 执行下面语句（下面两个语句处于同一个事务中）12345678-- 由于是延迟检查，所以两条数据都插入完，执行commit，事务结束时才进行完整性约束的检查，此时就不会出错，可以正常插入INSERT INTO person (person_id, name, country_id) VALUES ( 4, 'Jerry', 4);INSERT INTO country (country_id, country_name) VALUES ( 4, 'France');COMMIT 虽然SQL标准中有这个概念，但是大多数数据库没有提供支持，并且不常用]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（八）——视图 、事务]]></title>
    <url>%2F2017%2F10%2F10%2F2017-10-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%20%E3%80%81%E4%BA%8B%E5%8A%A1%20%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章(第三章的多表部分会挪到这一部分讲)笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们继续延用之前用的表(´`) 视图首先还是来谈谈笔者对视图概念的理解吧，在笔者看来视图这个数据库对象在不考虑物化的情况下就是一张虚表，本身没有实际的数据，但是可以利用视图在某个视角下观察一张或多张表的数据。所有对视图的操作最后都将转成对表的操作 视图定义（创建一个视图） 格式： 1CREATE VIEW 视图名 AS 子查询 举个栗子： 1234-- 下面的语句创建了一个简单的视图temp_view，其中包含员工名以及其所在部门名两个字段CREATE VIEW temp_view ASSELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO; 接下来我们对上面创建的视图进行查询操作 12SELECT *FROM temp_view; 得到如下结果： 数据库只存储视图的定义本身 视图通常是这样来实现的：当我们定义一个视图的时候，数据库系统就吧这个视图的定义（其实就是一个子查询语句）本身存储下来，一旦我们使用这个视图，数据库系统就会用定义中的查询语句替换视图 举个栗子123456789101112-- 我们继续沿用上面定义的视图temp_view，它的定义是这样的CREATE VIEW temp_view ASSELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO;-- 则对视图的查询操作可以作下面的等价(下面两个查询语句是等价的)SELECT *FROM temp_view;SELECT *FROM (SELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO) as temp_view; 可更新的视图 条件 FROM子句中只有一个数据库关系（即在定义视图的时候，后面的SELECT语句中只能查询一个表） SELECT子句中只包含关系的属性名，不包含任何的表达式，集聚函数或distinct声明 任何没有出现在SELECT子句中的属性可以取空值（即这些属性既没有not null 约束，也不构成主码的一部分） 查询中不含有group by 或 having 子句 满足上述条件的视图我们称作可更新的视图，在可更新视图上允许执行update、insert、delete操作 视图是在表的基础上定义的，所有对视图的操作最后都将作用在表上 视图的update、insert、delete 先定义一个视图，值包括员工的职工号、名字和工资 123CREATE VIEW emp_info ASSELECT EMPNO, ENAME, SALFROM EMP; 视图查询的结果如下： update 举个栗子123456789-- 下面的语句更新SMITH的工资UPDATE emp_infoSET SAL = 900WHERE ENAME = 'SMITH'--接下来查询表中的数据是否受到影响（查询的结果是900，就不贴图了）SELECT ENAME, SALFROM EMPWHERE ENAME = 'SMITH'; insert 举个栗子1234-- 往视图中插入一条数据（下面插入是可以执行成功的，可以自己试试，创建一个视图，只包含员工名字和工资，不包含EMPNO，这样就不能执行插入语句，违反了上面四个条件中的第三个条件）INSERT INTO emp_info (EMPNO, ENAME, SAL) VALUES ( 8888, 'Robbin', '1000'); –查询一下原表中的数据，会发现多了下面这条 视图的插入操作，最终作用到表上，并且是给视图中有的字段赋值，没有的字段都赋null值（这就解释了上面可更新视图的四个条件中的条件3） delete 举个栗子123-- 执行结果就是原表中的数据也被删除了DELETE emp_infoWHERE emp_info.EMPNO = 8888 物化视图 就是保存视图的结构，再使用时直接用保存的结果表，而不用再去将视图替换成定义，再次执行一遍查询视图的操作。这个在对视图的操作很频繁的时候是对效率很有增益的，但是同时带来的是同步的问题。就是原表中的数据更新了，但是视图物化的数据却没有更新，导致数据不一致。 一般用的很少，常用于数据仓库 视图更新检查（WITH CHECK OPTION） 默认情况下，如果一个视图满足以上可更新视图的定义，则通常的更新操作是允许被执行的 但是如果在创建视图的时候，在后面跟上 WITH CHECK OPTION,那么对视图的每一个更新操作，都会检查，更改后的结果，是否满足创建视图时WHERE子句中的限定。 举个栗子： 123456-- 我们在上面定义视图的栗子基础上改造一下，并加上WITH CHECK OPTIONCREATE VIEW emp_info ASSELECT EMPNO, ENAME, SALFROM EMPWHERE SAL &gt; 3000WITH CHECK OPTION; 上面视图的定义就是包含了工资超过3000的所有员工的员工号，名字，以及工资 这个时候如果我们执行下面的更新操作 1234-- 下面这个操作将会被拒绝执行UPDATE emp_infoSET SAL = 2000WHERE ... 由于在定义视图的时候添加了 WITH CHEKC OPTION 选项，所以在执行更新操作的时候回检查是否符合创建视图时WHERE子句中的条件，显然上面的操作不满足，故被拒绝执行。 事务 一个事务就是一个原子的，不可分割的任务，里面可能包含多条SQL语句。在事务机制下，一个事务中的多条SQL语句要么都执行，要么都不执行。 性质 原子性 事务是原子的，里面包含的一条或多条SQL语句要么都执行，要么都不执行 一致性 在隔离的执行多个事务时，用同步锁保证对数据库数据的一致性访问 隔离性 多个事务并行执行，若其中一个事务还没有结束，其他事务内是无法观察到这个事务对数据库的影响的 持久性 一旦事务正常完成，并提交，则其对数据库的修改就会持久化到数据库内。 事务的开始和终止 虽然各种关系型数据库都支持事务，但是不同的数据库的实现不同。具体的事务的开始和终止有隐式和显示之分 事务的开始 显示：begin transition （例如SQL Server数据库） 隐式：第一条DML语句（增删改查语句）开始执行就会开启一个事务 （例如Oracle数据库） 事物的终止 显示： end transition (例如SQL Server数据库) 隐式：执行 rollback、commit或者一条DDL语句 （例如Oracle数据库） 数据库加锁的范围不同 表级锁 页级锁 行级锁 举个栗子(由于使用SQL Server做的测试，所以采用显示的事务开启和关闭)12345678910111213141516-- 首先查看博客开头ALLEN的工资是1600-- 下面开启一个事务，并执行一条涨工资的操作（执行会立即完成）BEGIN TRANSACTIONUPDATE EMP SET SAL = SAL * 2WHERE ENAME = 'ALLEN';-- 与此同时，开启另一个事务，执行一条涨工资的操作（语句没有执行，一直在等待。这是因为上面那个事务对ALLEN的数据进行操作了，并且事务没有结束，由于同步锁的缘故，所以本事务中的修改语句要等上面那个事务执行完才能继续执行）BEGIN TRANSACTIONUPDATE EMP SET SAL = SAL * 3WHERE ENAME = 'ALLEN';-- 如果此时结束第一个事务，那么第二个事务的语句就能继续执行，此时提交第二个事务，最后得到的结果是，ALLEN的工资为9600COMMIT 完整性约束 主键约束 外键约束（参照完整性约束） 单关系上的约束 not null unique check(&lt;谓词&gt;)]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（七）]]></title>
    <url>%2F2017%2F09%2F29%2F2017-09-29-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章(第三章的多表部分会挪到这一部分讲)笔者接下来的代码示例会主要在SQL Server数据库中测试(由于SQL Server 数据库不支持自然连接，所以自然连接部分的将会在MySQL数据库中进行测试) 在开始今天的摸鱼大业之前，让我们继续延用之前用的表 外键约束：即具有外键约束的两张表，在进行操作时会收到一定程度的限制，如果某个操作执行后会破坏这个完整性，就将被拒绝执行。这个在之前的博客中有介绍==&gt; 传送门 自连接一个表与自身相连接的操作，其实与多表连接是一样的，只是连接的两张表用的是同一张表而已 举个栗子1234-- 下面的语句查询了所有员工的名字以及其经理的名字SELECT w.ENAME as worker_name, m.ENAME as manager_nameFROM EMP w JOIN EMP m ON w.MGR = m.EMPNO; 得到如下结果： 上面得到的结果是采用内连接得到的结果，所以对于那些MGR为null（没有经理）的员工，其信息就得不到显示，可以采用左外连接（LEFT OUTER JOIN） 员工表中MGR 和 EMPNO 字段应该有一层限制，MGR的取值应该是某一个EMPNO的取值（话句话说，一个员工的经理号应该也是同一张表中这个经理的职工号）。在定义这张表的时候可以给这两个字段加上一个外键约束。 12345678--下面的语句模拟了这一操作--只关注了EMPNO和MGR这两个字段，其他字段的描述省略了CREATE TABLE EMP( EMPNO INTEGER PRIMARY KEY , MGR INTEGER, .... FOREIGN KEY(MGR) REFERENCES EMP(EMPNO)) 还是那句话：绝大多数连接条件是建立在外键与外键的参照键之间的(自连接也不例外) 自然连接（NATURAL JOIN）其实自然连接就是写法更简单的多表连接，无需书写连接条件，让数据库自己判断应该采用什么连接条件（自然连接的语法是SQL的标准语法，但是并不是所有的数据库都支持，SQL Server就不支持自然连接的语法，但是Oracle和MySQL数据库都是支持的。。所以下面的测试就在MySQL里面测试啦，上次用IDEA连的那个数据库里面我已经建好了和在上面测试用例一样的表和数据，可以直接用） 可采用自然连接的前提条件：两个表中要有同名字段，并且同名字段的数据类型要一致 举个栗子 1234567891011-- 下面的语句就实现了查询所有的员工名字及其所在部门名-- 相当于内连接-- 因为两个表中有同名字段DEPTNO，并且数据类型相同，数据库就用这个作为连接条件SELECT e.ENAME, d.DNAMEFROM EMP e NATURAL JOIN DEPT d;-- 上面的语句等价于下面的内连接语句SELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO; 得到如下结果： 如果两个表中有同名字段，但是数据类型不一致，执行自然连接是会失败的，因为此时数据库不知道应该怎么连接两张表 当然如果想要执行外连接（左外，右外，全外）也是一样的 举个栗子 12345678910111213-- 下面几个语句是等价的，会得到相同的结果，都采用了左外连接SELECT e.ENAME, d.DNAMEFROM EMP e NATURAL LEFT OUTER JOIN DEPT d;SELECT e.ENAME, d.DNAMEFROM EMP e NATURAL LEFT JOIN DEPT d;SELECT e.ENAME, d.DNAMEFROM EMP e LEFT OUTER JOIN DEPT d ON e.DEPTNO = d.DEPTNO; 得到如下结果： 在使用自然连接时，同名字段（用于连接的字段）不能写限定名（虽然老师上课这么讲，但实际上呢？） 举个栗子 123456789101112-- 我们在上面例子的基础上，多显示一个部门号，下面的两条语句如果能执行，执行完的结果都是一样的-- 下面的语句在Oracle数据库执行会报错-- 但是在MySQL中执行是能过的SELECT e.ENAME, d.DNAME, e.DEPTNOFROM EMP e NATURAL JOIN DEPT d;-- 下面这种写法在Oracle和MySQL中都是能过的SELECT e.ENAME, d.DNAME, DEPTNOFROM EMP e NATURAL JOIN DEPT d; 让我们先分析一下，为什么在使用自然连接的时候同名字段可以不写限定名 先看看执行下面的语句有什么结果： 123SELECT *FROM EMP e NATURAL JOIN DEPT d; 得到下面结果： 可以看出来，采用自然连接以后，原本的同名字段DEPTNO只出现了一次,可以理解为采用自然连接以后FROM子句的结果就是上面那张表，同时原来的同名字段合成了一个。所以在SELECT子句中书写的时候可以不加表限定名（在Oracle数据库中不能加表限定名） 对比join操作，如果你直接用内连接或者外连接，而不是自然连接，会发现结果集里面用来连接的字段即便同名，也是会出现两次的（这也很好的解释了，为什么之前说在进行内外连操作的时候，用来连接的字段是需要用表明来限定的，不然SQL语句会有歧义，导致无法正确被解析————见数据库笔记（六））1234-- 你可以试试执行下面的SQL语句，会发现，结果集中名为DEPTNO的列有两列SELECT *FROM EMP e INNER JOIN DEPT d on e.DEPTNO = d.DEPTNO; 让我们对上面的结果小结一下 在采用自然连接的时候，对于同名字段，可以不写表限定名（但是在使用非自然连接的时候，同名字段一定要用表名来限定） 至于能不能写，得看具体是什么数据库，Oracle此种情况下就不允许在同名字段前写表限定名，而MySQL中则可以 所以推荐是在采用自然连接的时候，非同名字段都加上限定名，同名字段都不加 下面是在多表操作中的一点建议 在多表连接中，所有的字段前面都建议加上限定名 特殊的是，在使用自然连接的时候，同名字段不要写限定名 有一个问题就是，由于数据库只分析到数据字典层面，而无法分到数据层，所以就算两个表中的一组同名字段之间没有任何关系，但是数据类型一致，采用自然连接的话，这一组同名字段也会被作为连接条件。 举个栗子 12345678--下面这个栗子没有实际执行，想象一下就好-- 假设我们给部门表的部门名字段更名：DNAME--&gt;ENAME-- 然后我们仍然执行上面的例子-- 结果应该是没有数据，除非有一个员工，他的名字和他所在部门的名字是一样的。SELECT e.ENAME, d.ENMAEFROM EMP e NATURAL JOIN DEPT d 导致上面结果的原因是采用了自然连接以后，数据库会把所有同名并且类型相同的字段作为连接条件 有时候我们并不希望所有的同名字段都作为条件，这个时候我们就不能用上面的自然连接操作，就应该使用介绍的有关JOIN … USING的用法 利用JOIN … USING 可以灵活的指定用什么字段做连接条件 JOIN…USING 同样是一种自然连接，且是一种特殊的自然连接，不需要显示写明连接条件，只需要指定用什么字段连接即可 举个栗子 12345678910-- 用下面的语句同样可以实现查询所有员工名字以及其所在部门名字的需求SELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d USING (DEPTNO);-- 同样的，如果我们给部门表的部门名字段更名：DNAME--&gt;ENAME-- 为了避免上面提到的问题，我们可以只指定DEPTNO作为连接条件，就轻松解决上面的问题SELECT e.ENAME, d.ENAMEFROM EMP e JOIN DEPT d USING (DEPTNO); 得到如下结果： 其中JOIN 表名 USING (字段序列)，字段序列可以是一个或多个字段 如果两个表中存在同名字段，但是数据类型不一样，这样执行自然连接是会失败的 连接类型和连接条件(就是老师上课提到的课本上那个图) 连接类型 INNER JOIN LEFT OUTER JOIN RIGHT OUTER JOIN FULL OUTER JOIN 连接条件 NATURAL ON&lt; predicate> USING(A1, A2, …, An) 其中上面的连接类型和连接条件可以任意组合使用 但不是所有数据库都支持NATURAL 和 USING的用法，SQL Server不支持，Oracle和MySQL支持，即便支持，有一些细节还是不一样的（比如上面同名字段前面能不能加限定词的问题） ON的话是都支持的，建议用ON，有更好的可读性和灵活性 FROM子句中的子查询 如果子查询出现在FROM子句中，我们将子查询的结果当做一个临时的关系（表），奕称之为虚表 举个栗子 123456-- 下面的例子求出了工资比本部门平均工资高的员工的名字和其工资，以及其所在部门的平均工资SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) as avg_sal FROM EMP GROUP BY DEPTNO) as EWHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 得到如下结果： 分析上面的执行过程的时候，可以先分析一下子查询执行的结果是什么，然后再把它当做一张表放在上面，继续分析整个语句 可以给子查询得到的临时表取一个名字，并给里面的每个字段指定名字 最常见的是下面这种命名方法 12345SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO) as E(DEPTNO, avg_sal)WHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 直接在子查询后面用as关系指定表名以及子查询结果中每个字段的别名 但是也不是所有数据库都支持上面那种用法，Oracle数据库中就不支持用as关键字指定子查询的表名，也不支持在表名后面加上每个字段的名字，那这个时候怎么办呢？（可以在子查询里面给每个字段取别名，最后再给子查询得到的虚表用空格分隔取个表名就好了） 12345SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) as avg_sal FROM EMP GROUP BY DEPTNO) EWHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 下面提几点注意（对于FROM子句中的子查询）： 如果子查询中含有聚集函数（组函数）,一定要给它起个别名 对每个子查询得到的虚表都务必取个表名（虽然有些数据库可以不起表名，但是有些数据库不起表名是会出错的，所以建议还是都起一个表名） With 子句其实with子句的作用和在FROM子句中使用子查询时一样的，同样是得到了一张虚表，只是把FROM中冗长的子查询移到外面，可读性 更好一点 with子句的作用是定义一张临时表 WITH子句相当于把FROM中的子查询提出来，如果FROM子句中的子查询比较复杂的时候，这样做是很有好处的，可读性会好很多 WITH 的基本使用方法1WITH &lt; 临时表名 &gt; （字段别名序列）AS (子查询) 举个栗子12345678910111213141516-- 下面的例子和上面找大于本部门平均工资的例子是等效的-- 执行的结果也是相同的WITH avg_tab(DEPTNO, avg_sal)AS (SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO)SELECT e.ENAME, e.SAL, avg_tab.avg_salFROM EMP e, avg_tabWHERE e.DEPTNO = avg_tab.DEPTNO AND e.SAL &gt; avg_tab.avg_sal;-- 下面的语句和上面的等效SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO) as E(DEPTNO, avg_sal)WHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 标量子查询 把子查询的结果当做一个值，可以出现在任何可以放值的地方，比如SELECT,WHERE,HAVING 子查询的结果必须是单个元组的单个属性（即一行一列，只有单个值） 带子查询的DELETE语句 举个栗子： 12345678-- 下面的语句可以用来删除所有销售部的员工的信息DELETEFROM EMPWHERE DEPTNO = ( SELECT DEPT.DEPTNO FROM DEPT WHERE DNAME = 'SALES') 带子查询的INSERT语句 基本格式 12INSERT INTO &lt; 表名 &gt;（字段序列）子查询 举个栗子 1234567891011-- 由于SQL Server中是没有dual这张系统表的，而Oracle和MySQL数据库中是有的，所以下面的测试是在MySQL中测试的-- 下面的语句很巧妙的实现了：--如果部门表中没有部门号为666的部门的话，就将摸鱼部门的信息插入到部门表中--如果部门表中有部门号为666的部门，则不执行插入操作INSERT INTO DEPT (DEPTNO, DNAME, LOC)SELECT '666', 'MOYU', 'DUT'FROM dualWHERE NOT EXISTS(SELECT * FROM EMP WHERE DEPTNO = '666'); UPDATE语句的扩展 有下面几个扩展 可以嵌入子查询（这个不在举例，和上面的用法类似） case分支结构 case分支结构(可以有效的避免更新次序引发的问题) 第一种用法 1234567CASE WHEN &lt;条件&gt; THEN ... WHEN &lt;条件&gt; THEN ... ... ELSE ...END 第二种用法 12345CASE &lt;条件&gt;WHEN &lt;值&gt; THEN ...WHEN &lt;值&gt; THEN ......END 对比两种方法，可以将第一种方法类比成其他编程语言的if-else分支语句，而将第二种用法类比成switch语句 举个栗子123456789101112131415161718192021222324-- 我们的需求是给员工涨工资，工资大于等于3000的涨2%-- 工资大于等于两千的涨3%-- 工资小于2000的涨5%--第一种尝试UPDATE EMPSET SAL = SAL * 1.02WHERE SAL &gt;= 3000;UPDATE EMPSET SAL = SAL * 1.03WHERE SAL &gt;= 2000;UPDATE EMPSET SAL = SAL * 1.05WHERE SAL &lt; 2000;--会发现上面执行的次序不一样会导致结果不一样，如果把第三个更新语句先执行，那么可能某个工资低于2000的员工涨了一次工资后工资大于两千了，于是执行第二个更新语句的时候又给他涨了一遍工资-- 第二种尝试--下面就完美的实现了上面的需求，而且没有执行次序导致的问题UPDATE EMPSET SAL = CASE WHEN SAL &gt;= 3000 THEN SAL * 1.02 WHEN SAL &gt;= 2000 THEN SAL * 1.03 ELSE SAL * 1.05 END case分支结构不止可以用在update子句中，在select子句中也是有的 视图啊啊啊啊啊，这个内容还不是三言两语讲的玩的，下次吧下次吧。&gt;.&lt;]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（六）]]></title>
    <url>%2F2017%2F09%2F26%2F2017-09-26-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章(第三章的多表部分会挪到这一部分讲)笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们继续延用之前用的表(为了演示方便，我们在EMP表中多插入了一条数据，这个数据的部门号是空值)，用于演示下面的例子(´`) FROM 中的子查询由于FROM中的子查询涉及到多表的操作，所以准备放在后面讲，先在此处做个小提示，等学完多表操作后，会回来提这个，到时候我会在这边贴一个链接 多表查询中的笛卡尔积（全匹配问题） 如果在进行多表查询操作时没有连接条件 ，则会进行全匹配，结果集相当于两个表进行笛卡尔积 举个栗子1234-- 下面的操作本来是想输出所有的员工的姓名以及其所在的部门名-- 但是由于没有指定连接条件，所以结果将会是每一个员工与每一个部门组合的结果SELECT ENAME, DNAMEFROM EMP, DEPT; 结果如下(结果太多了，总共有52条，下面的图片中只截取了前面的一部分)： 在实际开发过程中笛卡尔积得到的结果一般是没有太大意义的，所以应当尽量避免==&gt;添加连接条件(WHERE emp.deptno = dept.deptno) 举个栗子：1234-- 这个栗子就基本完成了上面的需求SELECT ENAME, DNAMEFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 但是仔细观察会发现，上面的数据只有13条，而员工表里面的数据有14条，其中Sunny所在部门号为空值，在部门表中匹配不到结果，故没有出现在结果集当中。（这是因为采用内连接的缘故，下面将会对内外连接分别做分析） 在WHERE子句中书写连接条件的内连接这种在where子句中写连接条件的实现方式，不是SQL标准中的标准用法，但是大多数数据库都支持这种用法，所以这种用法已经成了一种事实标准。在内连接的范畴中，这种用法与SQL标准的内连接用法是等价的 等值内连 上述那个例子就是最常见的等值内连 123SELECT ENAME, DNAMEFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 等值内连就是在where中书写多表的连接条件的时候比较两个表中某一个或多个字段的值，值相等的则匹配（常见的就是用一个表的外键与另一个表中对应的外键的参照键进行比较） 必须是两张表中能够满足连接条件的数据才会出现在结果集当中（不单是等值连接，下面讲的非等值连接也是，所有内连接都应该瞒住这个） 再来举个上面举过的栗子1234-- 下面的操作得到了所有员工的名字以及其所在部门的名字SELECT ENAME, DNAMEFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 我们发现员工名为Sunny的员工数据和部门号为40的部门数据都没有出现在结果集当中。因为Sunny的部门号为空值，不等于部门表中任意一行数据的部门号，故找不到匹配；因为在员工表中没有员工的部门号为40，所以部门号为40的部门也没有出现在结果集当中。（只有满足连接条件，并且成功找到匹配的数据才会出现杂结果集当中） 这种用where书写的多表连接语句等价于SQL标准中的内连接（inner join） 上面的语句也可以写成下面这种形式1234567891011-- 下面的语句和上面例子中的语句是等价的SELECT ENAME, DNAMEFROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO-- SQL标准中还有下面这种用法（课本上有提到，但是显然SQL Server不支持这种用法）-- 表示的是利用DEPNOT这个字段来进行两表的连接（前提是这两个表中要有同名字段）-- 如果支持这种用法的数据库执行下面操作的话得到的结果和上面的是一样的（经验证，MySQL数据库是支持这种用法的）SELECT ENAME, DNAMEFROM EMP INNER JOIN DEPT USING(DEPNOT) 对于两表中的同名字段，在使用的时候必须用表名或者表别名加以限定，不然SQL语句会有歧义，导致无法正确被解析 举个栗子1234567891011121314151617181920-- 我们想在上面例子的基础上，多显示一个部门号-- 如果写成下面这样，就会报错，因为SQL解析器不知道DEPTNO指的是EMP表的还是DEPT表的SELECT ENAME, DNAME, DEPNOTFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO;-- 正确的写法应该是这样的SELECT ENAME, DNAME, EMP.DEPTNOFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO;--当然也可以用DEPT来限定SELECT ENAME, DNAME, DEPT.DEPTNOFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO;-- 不过最好用表别名来限定，比较简洁一点SELECT ENAME, DNAME, e.DEPTNOFROM EMP e, DEPT dWHERE EMP.DEPTNO = DEPT.DEPTNO; 如果对一个表起了别名之后就不能再使用原表名了，而要换成其别名 举个栗子1234-- 下面这个语句执行的话是要报大错滴，因为已经给EMP表起了别名e，就不能再用原表名EMP了SELECT ENAME, DNAME, EMP.DEPTNOFROM EMP e, DEPT dWHERE EMP.DEPTNO = DEPT.DEPTNO; 如果再考虑效率问题，在进行多表操作时，最好所有字段都用表名或者表别名限定，这样可以免去SQL解析器帮你分析某个字段属于哪个表的开销，可以在一定程度上提高执行效率 举个栗子123SELECT e.ENAME, d.DNAME, e.DEPTNOFROM EMP e, DEPT dWHERE EMP.DEPTNO = DEPT.DEPTNO; 不等值连接 举个栗子1234-- 下面的语句就查处了所有员工的姓名、工资、以及其工资等级SELECT e.ENAME, e.SAL, g.GRADEFROM EMP e, SALGRADE gWHERE e.SAL &gt;= g.LOSAL AND e.SAL &lt;= g.HISAL; 得到如下结果： 不等值连接就是内连接中除了通过比较值相同来进行连接以外的其他内连接操作 n个表相连，至少需要n-1个连接条件，要不然就会在连接过程中出现笛卡尔积 多表的连接条件一般都是建立在外键和外键的参照键之间，采用等值连接 SQL内连接的标准写法 JOIN … ON … 举个栗子123456-- 下面的语句就是SQL标准中多表内连接的写法SELECT *FROM TABLE1 t1 JOIN TABLE2 t2 ON ... JOIN TABLE3 t3 ON ... JOIN TABLE4 t4 ON ... 外连接内连接的结果是外连接结果的一个子集，外连接的结果中还可以包括只在一张表中出现，并且在另一张表种找不到匹配的结果 左外连接(LEFT OUTER JOIN) 包含JOIN关键字左表中的所有数据（即便某个数据在右表中找不到匹配） 举个栗子123456-- 下面的语句与上面的例子类似-- 同样是得到所有员工的名字以及其所在部门名-- 不同的是采用左外连接以后Suuny的数据会出现在结果集中了SELECT ENAME, DNAMEFROM EMP LEFT OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 右外连接(RIGHT OUTER JOIN) 包含JOIN关键字右表中的所有数据(即便某个数据在左表中找不到匹配 举个栗子12345-- 还是这个栗子，但不同的是我们把LEFT改成了RIGHT-- 会发现，部门号为40的部门信息显示出来了SELECT ENAME, DNAMEFROM EMP RIGHT OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 对比可以发现左外连接和右外连接的效用其实是一样的，只要吧JOIN两边表的位置对调一下，两者就可相互转换。（使用时随意，习惯怎么用就怎么用就好） 全外连接 JOIN关键字两边的表的所有数据都会出现在结果集当中，得到的结果其实就是左外连接和右外连接结果集的并集 举个栗子：123SELECT ENAME, DNAMEFROM EMP FULL OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 在进行多表连接的时候采用WHERE和ON的区别 其一，在进行外连接的时候，必须用ON 举个栗子 12345678910-- 下面的语句做了简单的外连接操作SELECT *FROM EMP LEFT OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO;-- 下面的语句执行是会报错的，因为没有加onSELECT *FROM EMP LEFT OUTER JOIN DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 其二，如果在on子句中指定连接条件，并在where子句中出现其余条件，这样的SQL插叙通常更容易让人读懂 所以在执行内连接的时候，on和where的使用是没有多大区别的，但是在执行外连接的时候就必须用on了。所以建议就是在on子句中指定连接条件，并在where子句中出现其余条件]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（五）]]></title>
    <url>%2F2017%2F09%2F22%2F2017-09-22-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章(第三章部分的多表操作没有在此处讲，准备挪到第四章再一起讨论)笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们先构造一组表，用于演示下面的例子(´`) Having 子句由于where子句中不能用聚合函数（组函数）做条件，故引入having子句 让我们先看一下各个子句的书写顺序（下面的只是我们一般在写SQL语句时候的书写顺序） SELECT FROM WHERE GROUP BY HAVING ORDER BY 上面各子句的执行顺序：FROM–&gt;WHERE– &gt; GROUP BY–&gt; HAVING–&gt;SELECT–&gt;ORDER BY 其中上面除了GROUP BY和HAVING可以互换位置外，其他位置均固定，但最好采用上面的顺序 从上面的讨论中可以看出 HAVING一般紧随GROUP BY之后，置于ORDER BY之前 而且当聚集函数（组函数）做条件时，只用用HAVING来处理 举个栗子：求所有平均工资大于2000的部门的部门号以及该部门的平均工资 先来看看每个部门的平均工资 123SELECT DEPTNO, avg(SAL) as avg_salFROM EMPGROUP BY DEPTNO 得到如下结果 接下来开始求题设的问题 1234SELECT DEPTNO, avg(SAL) as avg_salFROM EMPGROUP BY DEPTNOHAVING avg(SAL) &gt; 2000; 得到如下结果 聚合函数的嵌套 不同数据库对聚集函数嵌套的规定不同 Oracle数据库规定最多只能有两层嵌套 SQL Server不允许聚集函数嵌套 举个栗子： 1234567--下面的语句在Oracle数据库中执行是可以的SELECT max(avg(sal))FROM EMPGROUP BY deptno--上面的语句在SQL Server中执行会报下面的错[S0001][130] 不能对包含聚合或子查询的表达式执行聚合函数。 ┐(´•_•`)┌ 实际上二层以上的嵌套也是毫无意义的（只是瞎哔哔，不是什么重点，有助于理解为什么聚集函数多层嵌套是没有意义的） 首先回忆一下，聚集函数的操作是多行输入，得到一行输出 举个栗子 123SELECT max(max(avg(sal)))FROM EMPGROUP BY deptno 现在来分析上面语句执行的过程 （avg）首先根据部门号deptno分成若干组，并计算每组的平均工资（返回若干条记录） （max）然后取各部门最高的平均工资（返回一条记录） （max）这个时候只有一条记录，取最大值也还是那一条记录 子查询这部分是重点也是难点呀٩(๑`^´๑)۶，不用担心，让笔者带你细细解剖(≖_≖ )这部分参考了两份笔记和课本 嵌套子查询即SQL标准提供嵌套子查询机制，允许将一个完整的select-from-where查询表达式嵌入到另一个查询语句中 子查询嵌套在where和having子句中的情况（把子查询整体当做一组值，可以是0个，1个，或多个） 单行子查询 在单行子查询中，子查询语句只能返回一行数据 当where子句中用下列逻辑符号连接子查询时，便只能连接单行子查询 = &lt; > &lt;= >= &lt;&gt; 举个栗子(≖_≖ ) 我们现在要找所有员工中，拿到最高工资的人的名字以及工资1234SELECT ENAME, SALFROM EMPWHERE SAL = (SELECT max(SAL) FROM EMP); 得到如下结果 多行子查询 多行子查询中，子查询语句可以返回多行数据 当where子句中用下列关键字连接子查询时，便是多行子查询($代表上面提到的=, &gt;等符号) $ any/some $ all 举几个简单的栗子 &lt; any(…) 表示小于子查询结果集中的最大值 > any(…) 表示大于子查询结果集中的最小值 = any(…) 等价于in = all(…) 没有语法错误，但是只要子查询结果集的个数大于1，则整体的结果必然为空 &lt; all(…) 表示小于子查询结果集中的最小值 > all(…) 表示大于子查询结果集中的最大值 来举个正经的栗子 求比部门号为20的部门的所有员工的工资都要高的员工的名字和工资12345SELECT ENAME, SALFROM EMPWHERE SAL &gt; SOME (SELECT SAL FROM EMP WHERE DEPTNO = 10); 得到如下结果 还有一个要注意的问题(ㅍ_ㅍ)，就是子查询中SELECT后面的字段要根据主查询语句中的字段来确定（简单的说就是子查询语句前面，where后面，出现了什么字段，子查询语句的SELECT列表中理论上就应该出现这些字段） 举个栗子 12345678910111213--下面这个语句是匹配的SELECT ENAME, SALFROM EMPWHERE SAL &gt; SOME (SELECT SAL FROM EMP WHERE DEPTNO = 10);--下面这个语句就不匹配的--因为ENAM并没有出现在主查询语句中SELECT ENAME, SALFROM EMPWHERE SAL &gt; SOME (SELECT ENAME, SAL FROM EMP WHERE DEPTNO = 10); 其实换个角度想想，具体执行的时候是将where后面的字段与子查询语句的结果集进行比较，如果字段都不一样，就没有可比性了 对了，还有一个补充，not in + 子查询，如果子查询的结果集中包含NULL值，那整体的结果必为空。因为NULL值是不确定的值，谁也不能保证某个具体的值是否等于NULL。。。 子查询中存在性的判别可以用exists关键字 举个栗子就好1234567--下面的语句就查出了所有手底下管了人的经理的信息--其实这里已经用到了相关子查询，具体的下面将会讲到SELECT *FROM EMP as eWHERE exists(SELECT 1 FROM EMP WHERE EMP.MGR = e.EMPNO); 试思考下面两个问题，根据提示理解一下，也可以实际操作验证一下 =some 等价于 in， 然而 &lt;&gt;some不等价于not in（&lt;&gt;some表示的是只要不等于结果集中的任意元素即可，可想而知，只要结果集中有大于一个元素，这个条件是恒成立的） &lt;&gt;all 等价于 not in，然而=all不等价于in 相关子查询 慎用，因为一旦使用相关子查询，子查询语句可能会被执行很多次，很影响效率 举个栗子 123456789--下面的语句找出了所有比自己部门平均工资高的员工的信息--检索时，每检索一行数据，子查询语句就要被执行一次--（因为该子查询语句只有在某个具体的部门号下才会有结果--而，要获取部门号，就必须依赖于主查询语句中的某行具体数据）SELECT ENAME, SAL, DEPTNOFROM EMP eWHERE SAL &gt; (SELECT avg(EMP.SAL) FROM EMP WHERE e.DEPTNO = EMP.DEPTNO); 举个上面举过的栗子 1234567--下面的语句就查出了所有手底下管了人的经理的信息--用exists时，只要找到数据即会返回，不会继续向下检索SELECT *FROM EMP as eWHERE exists(SELECT 1 FROM EMP WHERE EMP.MGR = e.EMPNO); 由于exists会在找到数据后立即返回，而不是继续向下检索，所以用exists的相关子查询效率会稍微高一丢丢 可以自己验证一下下面结论 not exists 不受空值的影响 not in 受空值的影响]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（四）]]></title>
    <url>%2F2017%2F09%2F19%2F2017-09-19-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章(第三章部分的多表操作没有在此处讲，准备挪到第四章再一起讨论)下面的例子中的测试都是在MySQL数据库中测试的 集合运算此处集合运算的概念与数学中集合的概念类似，可以借助文氏图加深理解。故此处对并运算进行展开，其他啊两个自己类比，后面还会对集合运算的几个注意点进提醒。 union(集合并运算) union 默认去除重复，并升序排序（因为涉及到排序，故而会有效率上的劣势） union all 就可保留重复项，并且保留原序（不进行排序） 举个栗子（现有两张表如下） Student表 Teacher表 执行以下运算 12345SELECT ageFROM StudentUNIONSELECT ageFROM Teacher 得到如下结果(得到的结果没有重复元素，但是没有排序，说明MySQL数据库在此处没有对其进行排序输出，但是Oracle数据库是会对数据进行升序排序的) 执行以下运算 12345SELECT ageFROM StudentUNION ALLSELECT ageFROM Teacher 得到如下结果(可以知道，UNION ALL 保留了重复元素) intersect(集合交运算) except(集合差运算) Note: 参与集合运算的两个视图的列数要一致 举个栗子1234567-- 下面的语句执行就会出错-- 因为第一个视图有两个字段，而第二个视图只有一个字段，无法进行集合运算SELECT age, scoreFROM StudentUNION ALLSELECT ageFROM Teacher 参与集合运算的两个视图对应位置的字段的数据类型应该是一致的（数据类型兼容即可，字段名无需一致） 举个栗子 1234567-- 按上面的说法下面语句执行是非法的-- 因为第二个字段的数据类型不兼容，一个是浮点型，一个是字符串类型SELECT age, scoreFROM StudentUNION ALLSELECT age, tech_nameFROM Teacher 上面的书法在Oracle数据库里得到了证实，确实执行是会报错的，那MySQL数据库呢？我们执行以下，得到以下结果 说明该写法在Mysql里面竟然是合法的（所以所有的特性都要视不同的数据库，视情况而分析） 若无字段可加，又需保证列数相同，可控NULL做填充 举个栗子 12345SELECT age, scoreFROM StudentUNION ALLSELECT age, NULLFROM Teacher 得到如下结果哦 集合运算的结果视图的字段名以第一个结果集的字段名为主 举个栗子 12345SELECT stu_nameFROM StudentUNIONSELECT tech_nameFROM Teacher 得到如下结果： Oracle数据库中，差运算不是except， 而是minus；Oracle数据库union可以后面跟all， 但是interscet和minus后面不可以（不同数据库不同） 空值NULL NULL就是不确定的值，参与数值运算和字符串运算时，不同的数据库采取的处理不同； Oracle 数据库中，NULL无论参与数值运算还是字符串运算，都会使整体为NULL 获取系统时间 Oracle数据库的查询语句必须有from 故采用如下方法获取系统时间 1234-- 其中dual是Oracle数据库系统自带的一行一列的表-- 其他数据库没有这个表SELECT SYSDATEFROM dual MySQL就没有这个限制 12-- 在MySQL和SQL Server中用下面的语句就可获得系统时间SELECT SYSDATE 日期类型的运算 可与数值类型做加减运算（在Oracle数据库里面单位为天，·.·在MySQL里面竟然是秒） 举个栗子（MySQL里面测试） 1SELECT SYSDATE() - 1, SYSDATE(), SYSDATE() + 1 得到如下结果 可与日期类型做减运算，得到连个日期之前的差值 不可与日期类型做加运算（在Oracle数据库执行日期间加运算直接报错，Mysql数据库直接真的返回两个日期加以后的值，不过巨耗时，mmp） 与NULL值运算得NULL值（在Oracle和MySQL上测试结果都正确） where 子句，判断是否为空 用is NULL 和 is not NULL 判断 而不用 = NULL 和 != NULL 布尔变量有三个取值：TRUE，FALSE, NULL 三种取值以and，or相连时的结果，与并联串联电路的判断类 TRUE and NULL = NULL TRUE OR NULL = TRUE FALSE and NULL = FALSE FALSE OR NULL = NULL 举个栗子12345-- 下面的语句将会返回Student表中的所有信息-- 因为where子句后面的条件为真SELECT *FROM StudentWHERE TRUE OR NULL 去重关键字 distinct 跟在SELECT的后面，并且置于所有字段的前面 会将其后的字段都作为判断重复的条件 举个栗子123-- 下面的语句就是列出学生表中的数据，并去除stu_name和age都相同的数据重复SELECT DISTINCT stu_name, ageFROM Student 聚集函数（Aggregate Functions）多行输入，一行输出 此类函数有MIN，MAX，COUNT，AVG，SUM。其中AVG和SUM只能参与数值运算 聚集函数在使用时会忽略空值NULL 除了COUNT(*)，COUNT(*)在统计的时候是不忽略空值的 Count 在计数时，忽略空值项 默认是统计重复项的，其中ALL是默认的，顾可以不显示指明 1COUNT(ALL age) 如果统计去除重复以后的结果,可如下面写法 1COUNT(DISTINCT age) Oracle中用作对null值数据处理的函数nvl 123# 下面的语句表示对数据表中的分数做加和，如果遇到为空的项，则取其值为0SELECT SUM(NVL(score, 0))FROM Student COUNT(*)==&gt;可返回满足where子句条件的所有数据的数量 这是COUNT独有的用法，其他聚集函数里面只能放字段或表达式 SUM SUM(age) + SUM(score) &gt;= SUM(age + score) 因为聚集函数在使用时会忽略空值，而NULL值直接参与运算可能会导致整体为空，顾有上述结论 当且仅当数据中没有空值时，上述等号成立 分组聚集（Aggregation） GROUP BY 字段序列 GROUP BY 后面跟的字段序列作为分组条件，值相同的为一组 可以是多个字段（顺序不影响结果） 当SELECT列表中出现了聚集函数，select中能出现以下字段 可以放group by 后面的字段 可以放聚集函数处理了的字段或表达式 上面两种情况下的字段在每组的取值都是唯一的，故而可以保证结果集中每一项的行数是一致的 having， 解决where子句中不能包含聚集函数的问题 传送门]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（三）]]></title>
    <url>%2F2017%2F09%2F16%2F2017-09-16-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章(第三章部分的多表操作没有在此处讲，准备挪到第四章再一起讨论) SELECT * 与 SELECT 全字段 的执 行效率是有差别的 数据库在具体执行 SELECT * 的时候可以这样理解：首先把 * 替换成对应表的全字段序列，再执行。故在执行的的时候 SELECT * 的效率是会更低的 事实上 SELECT * 也是典型的低效语句 故在实际应用过程中应该尽量避免使用 SELECT * where子句 and、or、not的优先级顺序 or &lt; and &lt; not (not的优先级最高) 例如：我们要实现“年龄小于16或大于18，并且分数不小于60的所有学生” 于是写出了 123where age &gt; 18or age &lt; 16and not score &lt; 60 上面的语句实际表示的是: 分数不小于60并且年龄小于16，或者年龄大于18 实际使用的时候不要依赖于它们的优先级顺序！！ 上面的需求可用下面的语句实现：12where (age &gt; 18 or age &lt; 16)and score &gt;= 60 SQL 附加的基本运算 更名运算 as 首先存在如上表结构 需要事先申明的是，这里所说的更名并不是实际更改数据库中的表结构，更改只是在执行查询操作的过程中得到的结果视图 as 关键字可用于SELECT语句中给字段更名 执行如下语句： 12SELECT stu_name as student_name, age, scoreFROM Student 得到如下结果 as 关键字可用于FROM语句中给表更名 as可以把一个长的关系名替换成短的，这样在查询语句的其他地方用到这个关系名的时候就会方便不少 执行如下语句 1234567-- 下面两个语句实现的效果是一样的,但是显然第二种比较简洁SELECT Student.stu_name, Student.ageFROM StudentSELECT S.stu_name, S.ageFROM Student as S 还有一种情况需要用as修改表名，就是需要比较同一个关系中的元组的时候，必须要用别名，要不然无法区分 现在表中有如上数据 我们需要查询表中所有比Jane的成绩高的学生的名字 则可以用下面的语句实现： 123SELECT T.stu_nameFROM Student as T, Student as SWHERE T.score &gt; S.score and S.stu_name = 'Jane' 得到以下结果 大多数数据库中可以用空格替代as 12345678-- 下面两个语句是等价的（在Mysql数据库上测试）SELECT T.stu_nameFROM Student as T, Student as SWHERE T.score &gt; S.score and S.stu_name = 'Jane'SELECT T.stu_nameFROM Student T, Student SWHERE T.score &gt; S.score and S.stu_name = 'Jane' 注意：Oracle数据库更改表的别名不能用 as（但是改字段的别名是可以用as的）， 只能用空格，要不然会报错（比如上面的两个语句在大多数数据库执行都是可以通过而且结果一致的，但是在Oracle数据库第一条语句就不会过）** 如果别名中带空格，则别名需要用双引号引起来（因为空格也是可以替代as的，所以如果别名中含有空格而不做处理，可能会导致数据库无法解析这条语句） 首先看下面这条语句 123-- 下面这条语句想给Student表起一个别名，叫做 Student Info, 执行是会失败的SELECT Student Info.stu_nameFROM Student as Student Info 正确的操作应该是这样的 12SELECT "Student Info".stu_nameFROM Student as "Student Info" 字符串的拼接运算 不用数据库采用不同的运算符，常见的有 || 和 + 现在表中有如上数据 执行下面的语句(笔者是在Mysql下测试的，Mysql的字符串拼接是用connect函数实现的，所以略有不同) 12SELECT S.stu_name, concat('name: ', S.stu_name) as infoFROM Student as S 得到如下结果 对于null值的处理，不同的数据库采取的处理不同 Oracle会直接忽略空值，而DB2会使整体为null 下面在Mysql中测试与空值拼接，结果是会使整体为null 执行以下语句 12SELECT S.stu_name, concat('name: ', S.stu_name, NULL ) as infoFROM Student as S 结果如下 可以与字符串常量拼接 sql里面就用一对单引号包含一个字符串表示字符串常量，如’name: ‘ 上面的例子里面就用到了与字符串常量拼接，这里就不再赘述了 如果字符串常量里面需要包含单引号，可以用另一个单引号来转义 比如执行下面的语句 123# 下面的字符串常量中出现了四个单引号，其中首位两个是用来标示这个是一个字符串常量，第二个单引号是用来转义第三个单引号SELECT S.stu_name, concat('I''m ', S.stu_name) as infoFROM Student as S 结果如下： 函数 其实函数每个数据库都有各自的实现，种类和功能不尽相同 比如上面的connect函数是Mysql中的一个函数 upper(s)和lower（s）函数是用来将字符串全部变成大写/小写的函数 模糊匹配（like） 通配符（具体到某个具体的数据库可能还会有功能更强大的通配符，这里只讨论比较通用的两个） % ==&gt;匹配任意长度的字符串（字符串的长度也可以是0） _ ==&gt;匹配一个字符 举个栗子：12345-- 下面的语句标示查询条件是第三个字符是A的stu_nameWHERE stu_name LIKE '__A%'-- 下面的语句标示查询条件是第三个字符是A，且长度至少为4的stu_nameWHERE stu_name LIKE '__A_%' 现在表中还是有如上数据 执行下面操作 1234-- 下面的语句用来查询表中stu_name的值为Ja开头，且至少长度为三的所有学生名字SELECT stu_nameFROM StudentWHERE stu_name LIKE 'Ja_%' 得到如下结果 如果模式串（我们这里称like后面的串为模式串）中需要包含‘_’或者‘%’等通配符关键字，就需要用到转义，SQL里面用escape来指定转义字符 举个栗子：123-- 下面的语句在最后面定义‘\’为转义字符-- 所以实际的效果是匹配所有以 Ja_ 开头的 stu_nameWHERE stu_name LIKE 'Ja\_%' escape '\' 排序（order by） 如果没有显示指定升序还是降序，则默认是采用升序的 null 值的处理（不同的数据库采取的处理不同） Oracle 将null值当做最大 SQL Server 将null值当做最小 接下来来去测测Mysql数据库 首先表中的数据是上面酱紫的 然后执行下面操作 12345-- 下面的语句查询学生表中的所有数据，并按成绩排序（因为没有指定-- 升序还是降序，所以默认是升序的）SELECT *FROM StudentORDER BY score; 结果如下（可以看出，Mysql是将null值当做最小值） 在排序的时候可以用desc显示指定降序，asc显示指定升序 举个栗子 12-- 下面的排序条件标示先按score降序排序，如果遇到score相同的，则按age升序排序ORDER BY score desc, age asc order by 后面所跟字段，以在前面的字段为主进行排序 desc、asc 更在字段名或表达式后面，并且只能影响其前面的一个字段 举个栗子123-- 下面的排序条件表示，先以score进行升序排序（因为未指定的话默认是升序的），-- 如果遇到score相同的再按age进行降序排序order by score, age desc order by 后面可跟别名，字段名，表达式，字段的顺序号 别名、字段名 表达式 举个栗子12-- 下面排序条件标示把sal*12后按结果降序排序order by 12 * sal desc 字段的顺序号： 举个栗子1234-- 下面这条语句标示查询Sudent表中的所有数据，并按age和score进行升序排序（默认是升序排序）SELECT student_name, age, scoreFROM StudentORDER BY 2, 3 如果要查询的结果集是很大的，排序是很耗时的，会影响性能 where子句beween…and、in between…and（表示一个连续的范围） between a and b &lt;==&gt; a &lt;= x &lt;= b not between a and b &lt;==&gt; x &gt; b | x &lt; a 写的时候，小数写在前面，大数写在后面 in（表示离散的范围） 举个栗子1234# 下面的语句表示查询分数为98、99或者100的学生的信息SELECT student_name, age, scoreFROM Studentwhere score in (98, 99, 100)]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java环境简单配置+IDEA（小白版）]]></title>
    <url>%2F2017%2F09%2F16%2F2017-09-16-Java%E7%8E%AF%E5%A2%83%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2BIDEA%EF%BC%88%E5%B0%8F%E7%99%BD%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JDK配置 首先到官网下载最新版JDK：Oracle官网下载 Accept License Agreement–&gt;下载适合自己pc版本的jdk（此处以64位windows为例。x86是32位，x64是64位） 开始安装JDK 选择安装路径，可以不安装在C盘，记住安装到哪就行了，默认也行，我安装在（C:\Program Files\Java\jdk1.8.0_131） 安装过程中会跳出Jre的安装界面，你可以放到和之前JDK在同一个文件夹下，也可默认。然后直接下一步开始安装 环境变量配置 右击我的电脑–&gt;属性–&gt;高级系统设置–&gt;环境变量 新建环境变量，变量名为：JAVA_HOME，变量值为之前JDK的安装路径，此处安装在：C:\Program Files\Java\jdk1.8.0_131（可以在系统变量下新建，这样可以为每个登录该pc的用户都配置，如果在用户变量中新建，则只为当前用户配置，此处以在系统变量下新建为例） 找到Path变量–&gt;编辑 如果是win10系统，则进入后界面如下，选择新建两个环境变量，一个值为：%JAVA_HOME%\bin另一个为：%JAVA_HOME%\jre\bin（此处笔者已经配置好）配置好就如下图 如果是win7及之前的系统则进入后界面如下:在变量值最后输入 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;（注意原来Path的变量值末尾有没有;号，如果没有，先输入；号再输入上面的代码） 验证一下^-^ win + R–&gt;输入cmd，进入cmd命令行 输入：java -version 就可以查看版本信息，如果显示如下信息，则表示环境配置成功 到这里我们就可以骚操作一波，用记事本写简单Java程序（纯属骚操作，如果用IDE开发（比如我们接下来的部分要介绍的重头戏，用IDEA实现真正的骚操作）可不看这个hhhhhh，如果不想使用IDE开发的话，建议可以使用NotePad++、sublimeText或Atom进行代码编辑，不过真想用记事本敲也无可厚非） 新建一个文本文档，并修改后缀为.java修改以后如下：如果没有显示后缀名，则可通过如下方式修改： 用记事本打开，输入以下代码：12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;Oh, balabala&quot;); &#125;&#125; 直接在创建文件的文件夹下按住Shift + 右键，选择在此处打开命令窗口（环境变量的配置使得用户可以在任意目录下调用javac 和java 命令）输入：javac Hello.java （用于编译java源程序）java Hello（运行java程序） 自此JDK的配置就OK了，可以开始Java从入门到放弃的修炼了~~ 极其好用的IDE–&gt;IDEAps:如果在打开IDEA之前没有下载好JDK的道友，请先往上看详细步骤 先来一波官网的下载链接：IDEA官网下载地址我们下载社区版（别问为啥，社区版免费，如果下载左边的旗舰版也行，但是需要注册码，之前有个网上长期流传的获取注册码的路子，现在貌似不好用了，如果道友是学生就可以用学校给的邮箱百度“IDEA学生”去注册一个IDEA的学生账号（学生账号有自己的注册码，有效期为1年），如果不是就买或者用社区版吧）： 第二步我们来开始安装： 选择安装路径： 上面的是创建桌面图标，选择自己电脑对应的版本就行了；下面的可以全选，表示什么格式的文件可直接关联到IDEA，用IDEA来打开 下一步直接install 启动刚安装好的IDEA 如果第一次安装，就直接不导入设置，ok 选个喜欢的主题（此处笔者选这骚气黑），然后next 直接next 直接start 接下来新建一个项目练练手 create a project 如果显示NO SDK， 找到之前安装的JDK所在路径，然后next next 第二行选择项目的存放路径，第一行给项目取个名字，然后Finish 右击src文件夹–&gt;new–&gt;java class 给类取个名字，ok 输入以下代码：12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;Oh, balabala&quot;); &#125;&#125; 运行程序：运行成功，开始你的表演：]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（二）]]></title>
    <url>%2F2017%2F09%2F12%2F2017-09-12-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章 SQL的组成PS：其中DDL、DML、integrity有一些补充，剩下的几项都是课本内容，应该后面会讲到。现在就先放在那边吧 数据定义语言（Data-Definition Language， DDL） 提供定义关系模式，删除关系以及修改关系模式的命令 如create、drop、alter等执行以后会产生、销毁表（定义、删除关系模式）或改变表的结构（修改关系模式） 数据操纵语言（Data-Manipulation Language，DML） SQL DML提供从数据库中查询信息，以及在数据库中插入元组、删除元组、修改元组的能力 只是对表中数据的增删改查，并没有实际影响表的结构（即关系模式并没有改变，改变的只是表中的数据） 完整性约束（integrity） SQL DDL 会给每一个关系（每一张表）在定义或者修改的时候定义一定的完整性约束。之后所有的操作都应该满足这些约束，不满足的操作将不被允许执行 复习注释: 不过如果对违反约束的行为做了处理，有些违反约束的语句也是可以成功执行的。比如在定义外键的时候指定了级联删除，那么一旦删除语句违反了外键约束，数据库不是拒绝执行，而是级联删除相关数据 比如主键约束表示一个或多个字段唯一标识了一行数据，如果试图插入主键值相同的数据，就不会被允许 具体的下面会单独说明并举例 视图定义（view definition） SQL DDL 包括定义视图的命令 事务控制（transaction control） SQL包括定义事务的开始和结束的命令 嵌入式SQL和动态SQL（embedded SQL） 嵌入式和动态SQL定义SQL语句如何嵌入到通用编程语言，如C、C++、Java 授权 SQL DDL包括定义对关系和视图的访问权限的命令 基本类型这些基本数据类型不依赖于某一个具体的数据库，是SQL数据库通用的类型 char(n)——全称character 用户指定长度的字符串，所有取值的长度都固定为长度为n的char 比如身份证或者电话号码等长度固定的数据可以使用这个 一般实际用的较少 varchar(n)——全称character varying 可变长的字符串，n为串的最大允许长度 实际存的时候数据多长，就存多长，较省空间 实际应用中大多用varchar，而不是char int——integer 整数类型，没啥好讲的，Oj8k smallint 小整数类型 numeric(p, d) 定点数，这个数有p位数字，其中小数点右边有d位 例如，numberic(3, 1)可表示-99.9 ~ 99.9 下面在MySQL数据库上面的测试，举个栗子：(测试结果表明，如果定义numberic(3, 1), 则小数点前面有三位数时是无法插入的，如果小数点后面有多位小数，则通过四舍五入的方法只保留一位小数) 先简单定义一张Student表（没有定义主键，允许插入相同的数据） 123456-- 下面定义了一张学生表，其中grade的取值范围为-99.9 ~ 99.9（不合理的取值，只是为了测试）CREATE TABLE Student ( study_id VARCHAR(20) NOT NULL, age INTEGER DEFAULT 0, grade NUMERIC(3, 1)); 执行正常的插入操作 12345678910111213141516171819202122232425-- 下面两条插入语句都能正常执行，并且结果正确INSERT INTO Student(study_id, age, grade) VALUES ( '201590001', 18, 92.5)INSERT INTO Student(study_id, age, grade) VALUES ( '201590002', 18, -92.5)-- 执行下面一条插入操作，最后保存的记录是 -92.6，INSERT INTO Student(study_id, age, grade) VALUES ( '201590003', 18, -92.56)-- 执行下面一条插入操作，最后保存的记录是 -92.5，INSERT INTO Student(study_id, age, grade) VALUES ( '201590004', 18, -92.54)-- 下面的这条插入操作将会报错-- [22001][1264] Data truncation: Out of range value for column 'grade' at row 1INSERT INTO Student(study_id, age, grade) VALUES ( '201590005', 18, 192.5) 执行上面操作后的结果 study_id age grade 201590001 18 92.5 201590002 18 -92.5 201590003 18 -92.6 201590004 18 -92.5 real,double,precision 浮点数与双精度浮点数 float(n) 精度至少为n位的浮点数 Date, time, timestamp, interval 日期类型 SQL中的完整性约束下文中列举的只是部分简单约束，具体的会在后面的内容中讨论 先来简单聊一聊我对完整性约束的理解吧，其实数据库中的完整性约束讲起来就是数据库在定义一张表的时候，对其作出了一系列的约束（这些个约束可能影响一个或多个字段，甚至影响整个表结构）。如果后续的操作中（不管是DDL还是很DML），如果违背了之前定义的约束，（如果没有对违反约束行为做特殊的处理）这个操作就不会成功 primary key（A1, A2, …, An）——主键约束 该约束主要指定了以属性A1~An构成关系的主键，该主键值必须非空且唯一 即只要一个表的主键确定，那这个表中就不允许存在一行数据其主键的值为null， 也不允许存在两行数据其主键的值一样。一旦后续操作违反了这个原则（约束），则该操作就不会被执行 举个栗子： 新定义一张department表 1234567-- 下面的操作创建了一张department表，并指定dept_name为主键CREATE TABLE department ( dept_name VARCHAR(20), building VARCHAR(15), budget NUMERIC(12, 2), PRIMARY KEY (dept_name)); 下面顺序执行一系列插入操作 1234567891011121314-- 下面的操作将成功插入一条记录INSERT INTO department (dept_name, building, budget)VALUES ('Software', 'A', 100000);-- 下面再执行一次与上面一模一样的操作，会发现报错，因为之前已经有一条-- 记录的主键值为'Software'，顾无法再插入主键值相同的数据-- [23000][1062] Duplicate entry 'Software' for key 'PRIMARY'INSERT INTO department (dept_name, building, budget)VALUES ('Software', 'A', 100000);-- 下面的语句试图插入一条dept_name为空的数据，显然也是报错的-- 因为作为主键的字段是不允许为空的-- [23000][1048] Column 'dept_name' cannot be nullINSERT INTO department (dept_name, building, budget) VALUES (NULL , 'A', 100000); 执行上面操作后的结果 dept_name building budget Software A 100000 foregin key(A1, A2, …, An) references —— 外键约束 简单来讲如果一个关系（表）A中包含一个外键C，则作为外键的一个或多个字段必然是另一张表B的主键。则由于外键约束这一层关系，对A表和B表都会收一定程度的限制（现在解释的还是比较抽象，看下面的例子会比较直观一点） 如果想向A表中插入一条数据，且数据中C的值在B表中找不到对应表项，则这个操作不会成功（就像你如果向运动员表中插入一条数据，国家属性对应的标识在国家表中不存在，则这次插入操作就会失败） 如果试图删除一个表B的记录，而这条记录的主键只正好是A表中某条数据的外键，则这次删除操作不会成功 举个栗子： 先创建两张表 1234567891011121314151617-- 创建一张表department，并制定dept_name为主键CREATE TABLE department ( dept_name VARCHAR(20), building VARCHAR(15), budget NUMERIC(12, 2), PRIMARY KEY (dept_name));-- 再创建一张couese表，并指定dept_name为本表关于department表的外键CREATE TABLE course ( course_id VARCHAR(7) NOT NULL, title VARCHAR(50), dept_name VARCHAR(20), credits NUMERIC(2, 0), PRIMARY KEY (course_id), FOREIGN KEY (dept_name) REFERENCES department (dept_name)); 我们先试图插入一条course记录 1234-- 下面试图往course表中插入一条记录，但是department表中并没有-- dept_name = 'DUT'的记录，故该操作会失败INSERT INTO course (course_id, title, dept_name, credits)VALUES ('08', 'English', 'DUT', 3) 我们先往department表中插入记录，再往course表中插入记录，下面的操作就能成功插入 12345INSERT INTO department (dept_name, building, budget) VALUES ('DUT' , 'A', 100000);INSERT INTO course (course_id, title, dept_name, credits)VALUES ('08', 'English', 'DUT', 3) 执行上面操作后的结果 dept_name building budget DUT A 100000 course_id title dept_name credits 08 Endlish DUT 3 * 此时我们如果试图删除department表中dept_name = DUT的那条数据 123-- 执行下面的操作就会报错，因为course表中还有一项数据的dept_name的值为DUT，如果删除掉department中的这条数据，就会破坏其完整性，顾执行失败-- 23000][1451] Cannot delete or update a parent row: a foreign key constraint fails (`db_study`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`dept_name`) REFERENCES `department` (`dept_name`))DELETE FROM department WHERE dept_name = 'DUT'; * 同样的如果，我们试图删除department表，则只要course表中还有数据，这个操作就会失败 not null——非空约束 理解上面两个约束以后这个就很好理解了，这个约束就是指定某个字段不能为空，试图传入null值的操作都不会成功 作为主键的字段隐式拥有非空约束]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（一）]]></title>
    <url>%2F2017%2F09%2F12%2F2017-09-12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL教程 DBS（Database System） 传统的文件处理系统中存储组织信息的主要弊端 数据的冗余和不一致性（data redundancy and inconsistency） 数据访问困难（dificulty in accessing data） 数据孤立（data isolation） 完整性问题（integrity problem） 原子性问题（atomicity problem） 并发访问异常（concurrent-access anomaly） 安全性问题（security problem） 数据库系统的目标：提供一种可以方便高效地存取数据库信息的途径 数据视图数据库系统的一个主要目的是给用户提供数据的抽象视图，也就是说隐藏关于数据存储和维护的某些细节 数据抽象 物理层（physical level） 最低层次的抽象 描述了数据实际上是怎么存的（比如是都存在一个文件里还是分散在多个文件里） 逻辑层（logical level） 比物理层层次稍高的抽象 描述了数据库中存什么数据以及数据之间的关系 逻辑层的用户不需要去关系数据具体是怎么存的，这称作物理数据独立性（physical data independence） ps: 对于具有物理数据独立性的设计，即便底层的物理存储改变了，逻辑层也不需要做任何的修改 视图层（view level） 最高层次的抽象，只描述整个数据库的某个部分 简而言之，对于逻辑层的数据，我们可以通过不同的视图，以不同的视角以及视野去查看它 实例和模式 类比：模式类比于变量的声明，实例类比于变量在特定时刻的值 模式： 数据库的总体设计 数据库的模式限定了数据库中都有哪些表，表中都有哪些字段以及表与表之间的关系 实例： 特定时刻存储在数据库中的信息的集合 数据库的一个实例包含了数据库在一个时刻下的所有表的信息 数据模型 关系模型 实体—联系模型 基于对象的数据模型 半结构化的模型 网状数据模型 层次数据模型 关系型数据库的一些基本术语 relation（关系）==&gt;表 column（列）==&gt;字段（同一字段内所有数据的数据类型一致） row（行）==&gt;对应于数据库表中的一行数据（对应于数学概念中的元组） SQL（Structured Query Language）==&gt;结构化的查询语言 DDL：Data Define Language（数据定义语言）==&gt;执行 该类SQL语句会导致表结构的变化 DML：Data Manipulation Language（数据操纵（管理）语言）==&gt;执行该类SQL语句对表中的数据进行增删改查 查询语言（query language）：DML中涉及信息检索的部分称之为查询语言 tuple（元组）==&gt;对应于数据表中的一行数据 domain（域）==&gt;字段的取值范围 schema（方案/模式）==&gt;数据库中的Schema，为数据库对象的集合，一个用户一般对应一个schema Cartesian product（笛卡儿积） 百度百科对笛卡尔积的解释 一篇介绍笛卡儿积与数据库关联的博客 ps: 应当避免表与表之间相关联的时候采用全匹配（如果采用笛卡尔积的匹配方式即为全匹配） DDL （数据定义语言）数据库模式定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。一个数据库模式包含该数据库中所有实体的描述定义。DDL用来定义一个数据库的模式 执行此类语句会导致数据库结构的变化 create（创建一个表） 1234567-- 下面的语句创建了一个用户表，以id为主键，并添加了username和age字段CREATE TABLE User( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) DEFAULT "", age INT DEFAULT 18);CREATE UNIQUE INDEX User_id_uindex ON User (id); alter（修改表的结构） 12-- 下面的语句修改了user表的id属性ALTER TABLE user MODIFY id INT(11) unsigned NOT NULL AUTO_INCREMENT; drop（删除一张表） 12-- 下面的语句删除了为user表DROP TABLE demo.user; rename（用于对一张表的名字进行重命名） Oracle数据库将其划分到DDL SQL server数据库将其归到DML12-- 下面的语句将user表的表名改成new_userrename table user to new_user truncate（截断==&gt;用于删除数据表中的所有数据，但是保留表结构，不同公司的数据库实现的机制不同） DML数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令，因此有很多开发人员都把加上SQL的SELECT语句的四大指令以“CRUD”来称呼。 此类语句对数据进行增删改查（CRUD） insert 12-- 下面的语句往user用户表中插入一条记录INSERT into user(username, age) VALUES('Robbin', 18) update 12-- 下面的语句修改了user表中username为Robbin的表项（元组）的数据UPDATE user SET username = 'Robbin2', age = 17 WHERE username = 'Robbin' delete 12-- 下面的语句删除user表中username为Robbin2的表项（元组）DROP FROM user WHERE username = 'Robbin2' select DB2将select归到DML Oracle将select单独划为一类（因为select操作只是对数据库进行查询操作，没有实质改变数据库中的数据）12-- 下面的语句查询user表中的所有数据SELECT * FROM user DML和DDL的区别 DML语句支持回滚，采用事务，可以保证数据的一致性；而DDL语句采用隐式commit，是不支持回滚的（一旦执行就不可撤回） 四种SQL语句 Key（键/码） superkey（超码）==&gt;一个或多个字段的集合，可唯一标识一行数据 candidate keys（候选码）==&gt;最小的超码（即本集合为超码，且集合内除本身外的任何子集都不能作为超码） Primary key（主码/主键）==&gt;从候选码中选取一个作为主码（主键），可以由多个字段组成 Primary attribute（主属性）==&gt;包含于某个候选码的属性 Non-Prime attribute（非主属性）==&gt;不包含于某个候选码的属性 Note: 数据表中字段的个数是有限的 属性在元组中是无序的（但是设计的时候一般把主键放在前面） 设计字段的时候要保证字段的原子性 NULL==&gt;空值表示不确定的值，不代表0，也不代表空串]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
