<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SQL中实现关系代数中的除运算浅析]]></title>
    <url>%2F2018%2F05%2F04%2F2018-5-4-database-double-not-exists%2F</url>
    <content type="text"><![CDATA[准备工作 先给出构造测试表的初始化代码，有兴趣的小伙伴可以跑一跑试试 12345678910111213141516171819202122232425262728293031323334353637383940drop table R;drop table S;create table R ( X integer, Y varchar(5));create table S ( Y varchar(5), Z integer);insert into R (X, Y) values ( 1, 'A');insert into R (X, Y) values ( 2, 'B');insert into R (X, Y) values ( 3, 'C');insert into R (X, Y) values ( 1, 'B');insert into R (X, Y) values ( 1, 'C');insert into R (X, Y) values ( 2, 'A');insert into S (Y, Z) values ( 'A', 3);insert into S (Y, Z) values ( 'B', 3);insert into S (Y, Z) values ( 'C', 3); 现在整体的表结构如下 R S 解释 其中X,Y,Z都可以代表一个或多个字段 Y为两张表中的相同字段 关系代数除运算（division）扫盲 R÷S 对于某个R关系中的X的某个具体值x映射到Y的集合，如果它包含关系S中Y的集合，那么这个x就会出现在结果集当中 像上面构造的两张表R和S，R÷S的结果就是’A’了 OK，所以说了和没说差不多，我还是不懂什么是关系代数中的除运算(:з」∠)…那下面就来举一个形象一点的栗子ლ(╹◡╹ლ) 这是栗子 R表示学生的选课信息，其中X表示学号，Y表示课程号 S表示课程的信息，其中Y表示课程号，Z表示学分 好现在，上面的两种表就变成下面这样了 R S ok，现在我们要找出一部分学生的学号，他们选了所有的课 R÷S ==&gt; 选了所有课的学生（很显然，上面只有学号为1的学生选了所有的课） 结果如下： SQL实现网上常见的方式就是用双重not exists来实现，咋一看不是很好理解，笔者这里对其进行稍详尽点的分步分析 最终代码1234567891011SELECT DISTINCT R1.XFROM R R1WHERE NOT EXISTS( SELECT * FROM S WHERE NOT EXISTS( SELECT * FROM R R2 WHERE R2.X = R1.X AND R2.Y = S.Y )); 分析 我们先来对里面一层的not exists进行分析 执行下面代码： 123456789101112131415SELECT *FROM SWHERE NOT EXISTS( SELECT * FROM R R2 WHERE R2.X = 1 AND R2.Y = S.Y);SELECT *FROM SWHERE NOT EXISTS( SELECT * FROM R R2 WHERE R2.X = 2 AND R2.Y = S.Y); 第一个执行结果为空，第二个执行结果如下 分析一下可以知道，上面的SQL完成的任务是“对于某个学号的学生，求得该学生未选的课程列表” OK，我们加上外层的not exists 1234567891011SELECT DISTINCT R1.XFROM R R1WHERE NOT EXISTS( SELECT * FROM S WHERE NOT EXISTS( SELECT * FROM R R2 WHERE R2.X = R1.X AND R2.Y = S.Y )); 从上面的分析我们知道，内层的SQL求的是对于一个具体的学生，其未选课程的列表 那么外层加上一个not exists，整个SQL的含义就是求没有未选课程的学生，换句话说，就是求选了所有课的学生 当然，第一行的DISTINCT也是很有必要的，去除了重复的X，你可以试试，不加，看一下结果，会发现每一个结果都会出现S表中Y集合的大小那么多次。]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin use函数的魔法]]></title>
    <url>%2F2018%2F03%2F30%2Fkotlin_01%2F</url>
    <content type="text"><![CDATA[魔法预览 实现了Closeable接口的对象可调用use函数 use函数会自动关闭调用者（无论中间是否出现异常） Kotlin的File对象和IO流操作变得行云流水 use函数的原型 123456789101112131415161718192021222324252627282930/** * Executes the given [block] function on this resource and then closes it down correctly whether an exception * is thrown or not. * * @param block a function to process this [Closeable] resource. * @return the result of [block] function invoked on this resource. */@InlineOnly@RequireKotlin("1.2", versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = "Requires newer compiler version to be inlined correctly.")public inline fun &lt;T : Closeable?, R&gt; T.use(block: (T) -&gt; R): R &#123; var exception: Throwable? = null try &#123; return block(this) &#125; catch (e: Throwable) &#123; exception = e throw e &#125; finally &#123; when &#123; apiVersionIsAtLeast(1, 1, 0) -&gt; this.closeFinally(exception) this == null -&gt; &#123;&#125; exception == null -&gt; close() else -&gt; try &#123; close() &#125; catch (closeException: Throwable) &#123; // cause.addSuppressed(closeException) // ignored here &#125; &#125; &#125;&#125; 可以看出，use函数内部实现也是通过try-catch-finally块捕捉的方式，所以不用担心会有异常抛出导致程序退出 close操作在finally里面执行，所以无论是正常结束还是出现异常，都能正确关闭调用者 来一波对比 实现读取一个文件内每一行的功能 java实现 12345678910111213141516171819202122232425FileInputStream fis = null;DataInputStream dis = null;try &#123; fis = new FileInputStream("/home/test.txt"); dis = new DataInputStream(new BufferedInputStream(fis)); String lines = ""; while((lines = dis.readLine()) != null)&#123; System.out.println(lines); &#125;&#125; catch (IOException e)&#123; e.printStackTrace();&#125; finally &#123; try &#123; if(dis != null) dis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if(fis != null) fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; Kotlin实现 12File("/home/test.txt").readLines() .forEach &#123; println(it) &#125; 对Kotlin就是可以两行实现。 仔细翻阅readLines这个扩展函数的实现你会发现，它也是间接调用了use，这样就省去了捕捉异常和关闭的烦恼 同样的，经过包装以后你只需要关注读出来的数据本身而不需要care各种异常情况 File的一些其它有用的扩展函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*** 将文件里的所有数据以字节数组的形式读出* Tip：显然这不适用于大文件，文件过大，会导致创建一个超大数组*/public fun File.readBytes(): ByteArray/*** 与上一个函数类似，不过这个是写（如果文件存在，则覆盖）*/public fun File.writeBytes(array: ByteArray)： Unit/*** 将array数组中的数据添加到文件里（如果文件存在则在文件尾部添加）*/public fun File.appendBytes(array: ByteArray): Unit/*** 将文件以指定buffer大小，分块读出（适用于大文件，也是最常用的方法）*/public fun File.forEachBlock(action: (buffer: ByteArray, bytesRead: Int) -&gt; Unit): Unit/** * Gets the entire content of this file as a String using UTF-8 or specified [charset]. * * This method is not recommended on huge files. It has an internal limitation of 2 GB file size. * * @param charset character set to use. * @return the entire content of this file as a String. */public fun File.readText(charset: Charset = Charsets.UTF_8): String/** * Sets the content of this file as [text] encoded using UTF-8 or specified [charset]. * If this file exists, it becomes overwritten. * * @param text text to write into file. * @param charset character set to use. */public fun File.writeText(text: String, charset: Charset = Charsets.UTF_8): Unit/** * Appends [text] to the content of this file using UTF-8 or the specified [charset]. * * @param text text to append to file. * @param charset character set to use. */public fun File.appendText(text: String, charset: Charset = Charsets.UTF_8): Unit/** * Reads this file line by line using the specified [charset] and calls [action] for each line. * Default charset is UTF-8. * * You may use this function on huge files. * * @param charset character set to use. * @param action function to process file lines. */public fun File.forEachLine(charset: Charset = Charsets.UTF_8, action: (line: String) -&gt; Unit): Unit/** * Reads the file content as a list of lines. * * Do not use this function for huge files. * * @param charset character set to use. By default uses UTF-8 charset. * @return list of file lines. */public fun File.readLines(charset: Charset = Charsets.UTF_8): List&lt;String&gt;/** * Calls the [block] callback giving it a sequence of all the lines in this file and closes the reader once * the processing is complete. * @param charset character set to use. By default uses UTF-8 charset. * @return the value returned by [block]. */@RequireKotlin("1.2", versionKind = RequireKotlinVersionKind.COMPILER_VERSION, message = "Requires newer compiler version to be inlined correctly.")public inline fun &lt;T&gt; File.useLines(charset: Charset = Charsets.UTF_8, block: (Sequence&lt;String&gt;) -&gt; T): T 上面的函数都是基于use实现的，可以放心使用，而不用担心异常的发生，并且会自动关闭IO流]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android WI-FI Direct Kotlin 浅析（一）]]></title>
    <url>%2F2018%2F03%2F26%2Fandroid_wifi_direct_01%2F</url>
    <content type="text"><![CDATA[简介 百度百科：2010年10月，Wi-Fi Alliance（wi-fi联盟）发布Wi-Fi Direct白皮书，白皮书中介绍了有关于这种技术的基本信息、这种技术的特点和这种技术的功能，Wi-Fi Direct标准是指允许无线网络中的设备无需通过无线路由器即可相互连接。与蓝牙技术类似，这种标准允许无线设备以点对点形式互连，而且在传输速度与传输距离方面则比蓝牙有大幅提升 与Android开发者而言呢，Google嗅到了WI-FI直连的发展前景，整了一套WI-FI直连的API，在Android4.0+（API &gt;= 14）的设备上均能使用。这给我们进行手机之间的互联操作提供了一个新的实现思路。它可以不需要路由而让两个设备直接相连，但其传输速度可是远远超过蓝牙传输。而且它不需要热点的建立，甚至两个设备不需要在一个局域网下。想象一下，不用建立热点也可以实现像快牙，茄子一类的面对面快传的需求～》《～ 基本使用 定义一个广播接收器 每当当前设备与Wi-fi直连相关的状态发生改变，系统便会以广播的形式通知我们，所以让我们定义一个Receiver欢迎它 在下面定义的Receiver里面我们监听了4个Action，这是最常用的4个，还有其它的Action可以看官方文档，或者，来去撸一波源码 12345678910111213141516171819202122232425262728293031323334353637383940414243class WifiDirectReceiver : BroadcastReceiver() &#123; /** * 写一个便捷的注册方法，动态注册的时候就不用写intentFilter了 */ fun registerReceiver(context: Context) &#123; val intentFilter = IntentFilter() intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION) intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION) intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION) intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION) context.registerReceiver(this, intentFilter) &#125; override fun onReceive(context: Context?, intent: Intent?) &#123; when (intent?.action) &#123; /** *当Wifi功能打开或关闭的时候系统会发送 WIFI_P2P_STATE_CHANGED_ACTION 广播 * Tip: 并不是指是否已经成功连上WI-FI */ WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION -&gt; &#123; &#125; /** * 当前设备的详细信息发生变化的时候，系统会发送 WIFI_P2P_THIS_DEVICE_CHANGED_ACTION 广播 */ WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION -&gt; &#123; &#125; /** * 当可连接的对等节点列表发生改变的时候，系统会发送 WIFI_P2P_PEERS_CHANGED_ACTION 广播 * invoke when the list of peers find, register, lost */ WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION -&gt; &#123; &#125; /** * 当一个连接建立或断开的时候，系统会发送该广播 * This action received when the connection setup or dis-setup */ WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION -&gt; &#123; &#125; &#125; &#125;&#125; 接下来在Activity中动态注册12345678910111213141516171819class WifiDirectActivity : AppCompatActivity() &#123; private val wifiDirectReceiver = WifiDirectReceiver() override fun onStart() &#123; super.onStart() wifiDirectReceiver.registerReceiver(this) &#125; override fun onStop() &#123; super.onStop() unregisterReceiver(wifiDirectReceiver) &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125;&#125; 没错，直接动态注册了！！！Android8.0的新特性让Android开发喵几乎一夜之间丧失在AndroidManifest中静态注册的技能（所以为了，考虑兼容，我们就直接动态注册了） 好，接下来验证一下WIFI_P2P_STATE_CHANGED_ACTION 我们在Receiver里面加点输出（实际开发还是用Log，极不推荐直接输出，这里笔者还是决定偷懒♪(^∇^*)） 12345678910111213141516/** *当Wifi功能打开或关闭的时候系统会发送 WIFI_P2P_STATE_CHANGED_ACTION 广播 * Tip: 并不是指是否已经成功连上WI-FI */WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION -&gt; &#123; //get the state of current device val state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, WifiP2pManager.WIFI_P2P_STATE_DISABLED) if (state == WifiP2pManager.WIFI_P2P_STATE_ENABLED) &#123; //Wifi p2p enable println("wifi enable") &#125; else &#123; //wifi p2p disEnable println("wifi disEnable") &#125;&#125; 然后跑到真机上（万能的模拟器然而并不能模拟wifi功能，只能真机实测一波啦），反复开关Wifi功能 12303-26 16:26:08.744 29313-29313/com.j.ming.eupanwifidirect I/System.out: wifi enable03-26 16:26:11.098 29313-29313/com.j.ming.eupanwifidirect I/System.out: wifi disEnable03-26 16:32:16.376 29313-29313/com.j.ming.eupanwifidirect I/System.out: wifi enable OK, 得到上面的输出，我们就知道确实，这个ACTION在WI-FI功能开关的时候会触发 WIFI_P2P_THIS_DEVICE_CHANGED_ACTION 大新闻：这个ACTION携带了一团神秘数据，^``^,那就是本设备的设备信息啦～ 同样的，我们加一点输出，看一下都包含哪些信息（当然，最直接的是看WifiP2pDevice这个数据） 1234567/** * 当前设备的详细信息发生变化的时候，系统会发送 WIFI_P2P_THIS_DEVICE_CHANGED_ACTION 广播 */WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION -&gt; &#123; val device: WifiP2pDevice = intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_DEVICE) println(device)&#125; 同样真机测试，来调皮的开关一下WI-FI功能（当然，一开始也会打印出设备信息，那就是在这个Receiver被注册的时候） 12345678910111203-26 16:43:29.420 30294-30294/com.j.ming.eupanwifidirect I/System.out: wifi enable03-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: Device: 魅蓝 Note303-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: deviceAddress: 2e:57:31:98:45:3503-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: primary type: 10-0050F204-503-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: secondary type: null03-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: wps: 003-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: grpcapab: 003-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: devcapab: 003-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: status: 303-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: wfdInfo: WFD enabled: falseWFD DeviceInfo: 003-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: WFD CtrlPort: 003-26 16:43:29.436 30294-30294/com.j.ming.eupanwifidirect I/System.out: WFD MaxThroughput: 0 可以看到包括设备的名字，本设备的MAC地址，状态balabala 后面两种ACTION涉及到连接，我们等下讨论 WifiP2pManager 的异种接口 requestPeers、requestGroupInfo、discoverPeers、createGroup、removeGroup等等 当然可以直接用，不过为了简介，我们一边用一遍封装出一个管理类 获得WifiP2pManager对象 下面的操作需要添加以下权限123456&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" android:required="true" /&gt;&lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" android:required="true" /&gt; 12345678910111213object WifiDirectManager&#123; private var manager: WifiP2pManager by Delegates.notNull() private var channel: WifiP2pManager.Channel by Delegates.notNull() fun init(context: Context): WifiDirectManager&#123; //通过获取系统服务的方式获得Manager对象 manager = context.getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager channel = manager.initialize(context, Looper.getMainLooper())&#123; //初始化操作成功的回调 &#125; return this &#125;&#125; 利用Kotlin 的object关键字，快速创建一个单例对象 channel在后续的操作中要用到，这个是manager初始化成功之后返回的渠道对象 上述init方法建议在Application的onCreate中调用，至少在使用前调用 discoverPeers 在上述的WifiDirectManager类里面添加如下方法 1234567891011121314151617181920212223242526/** * discover available peer list */fun discoverPeers(): WifiDirectManager &#123; manager.discoverPeers(channel, object : WifiP2pManager.ActionListener&#123; override fun onSuccess() &#123; println("discover Peers success") &#125; override fun onFailure(reason: Int) &#123; println("discover Peers fail: $reason") &#125; &#125;) return this&#125;/** * request the peer list available */fun requestPeers(): WifiDirectManager &#123; manager.requestPeers(channel) &#123; peers -&gt; //请求对等节点列表操作成功 println(peers) &#125; return this&#125; 在Activity里面拖一个button，在点击事件里面调用这个函数 123btnSendTestBroadcast.setOnClickListener &#123; WifiDirectManager.discoverPeers()&#125; 上面的方法，望文生义，就是用来检索附近的可用对等节点列表，然后后面就是这个整套API最坑的一个回调了 WifiP2pManager.ActionListener 这个回调里面的success和failure表示的是一个操作是否执行成功，而并不能反映出这个操作的结果 所以从上面这个回调里我们只能知道，执行discoverPeers这个操作有没有成功，是无法获取到对等节点列表的 那怎么获取检索的结果呢，答案是: 在Receiver里面直接获取（API &gt;= 18） 在Receiver里面调用requestPeers()获取- 两种获取对等节点列表的方式 Tip：在调用discoverPeers之后才能获取到对等节点列表 1234567891011121314/** * 当可连接的对等节点列表发生改变的时候，系统会发送 WIFI_P2P_PEERS_CHANGED_ACTION 广播 * invoke when the list of peers find, register, lost */WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION -&gt; &#123; //api &gt; 18 have this extra info, if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123; val wifiP2pList: WifiP2pDeviceList = intent.getParcelableExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST) println(wifiP2pList) &#125; else &#123; //if the sdk version lower than 18 //get WifiP2pDeviceList by call WifiP2pManager.requestPeers to get WifiDirectManager.requestPeers() &#125;&#125; 可以看到，当可用对等节点列表变化时，系统会发送 WIFI_P2P_PEERS_CHANGED_ACTION 广播，我们有两种方式获取对等节点列表 API &gt;= 18 的时候可以直接在 intent 携带数据中获取到 WifiP2pDeviceList 对象 当 API 在[14, 18) 之间的时候，只能调用manager的requestPeers方法，在回调当中获取 其实：只要都采用第二种方式，就能保持一致性了 具体输出结果可以自己试一试 connect12345678910111213141516171819202122232425/** * connect by MAC address(hardware address) */fun connect(deviceAddress: String) &#123; val config = WifiP2pConfig() config.deviceAddress = deviceAddress config.wps.setup = WpsInfo.PBC manager.connect(channel, config, object : WifiP2pManager.ActionListener &#123; override fun onSuccess() &#123; println("connect operator success") &#125; override fun onFailure(reason: Int) &#123; println("connect operator fail: $reason") &#125; &#125;)&#125;/** * invoke this method to connect a p2p device */fun connect(device: WifiP2pDevice): WifiDirectManager &#123; connect(device.deviceAddress) return this&#125; 在前面我们已经获取到对等节点列表了，每个对等节点设备信息里面包含其mac地址，用mac地址就能连接 连接成功以后 系统就会发送 WIFI_P2P_CONNECTION_CHANGED_ACTION 广播了，你可在里面获取对方设备的信息以及群组的信息 如果两个对等节点都没有创建群组，则连接之后其中一端设备会自动成为群组，每个组员都能获取到群组的IP WIFI_P2P_CONNECTION_CHANGED_ACTION 包含的信息 给WifiDirectManager类添加几个封装函数 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * request the group info */fun requestGroup(): WifiDirectManager &#123; manager.requestGroupInfo(channel) &#123; group -&gt; &#125; return this&#125;/** * create a group */fun createGroup(): WifiDirectManager &#123; manager.createGroup(channel, object : WifiP2pManager.ActionListener &#123; override fun onFailure(reason: Int) &#123; println("create group fail: $reason") &#125; override fun onSuccess() &#123; println("create group success") &#125; &#125;) return this&#125;/** * remove a group */fun removeGroup(): WifiDirectManager &#123; manager.removeGroup(channel, object : WifiP2pManager.ActionListener &#123; override fun onSuccess() &#123; println("remove group success") &#125; override fun onFailure(reason: Int) &#123; println("remove group success: $reason") &#125; &#125;) return this&#125; 看看Receiver里面的代码 123456789101112131415/** * 当一个连接建立或断开的时候，系统会发送该广播 * This action received when the connection setup or dis-setup */ WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION -&gt; &#123; val networkInfo = intent.getParcelableExtra&lt;NetworkInfo&gt;(WifiP2pManager.EXTRA_NETWORK_INFO) val wifiP2pInfo = intent.getParcelableExtra&lt;WifiP2pInfo&gt;(WifiP2pManager.EXTRA_WIFI_P2P_INFO) if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123; val wifiP2pGroupInfo = intent.getParcelableExtra&lt;WifiP2pGroup&gt;(WifiP2pManager.EXTRA_WIFI_P2P_GROUP) &#125; else &#123; &#125; &#125;&#125; 从上面可以看出，当收到系统发送的 WIFI_P2P_CONNECTION_CHANGED_ACTION 广播的时候，我们可以获取下面信息 NetworkInfo WifiP2pInfo (对端设备的信息) WifiP2pGroup （两种方式获取， 和之前获取对等节点列表的操作类似） 应用方式 可以一个设备主动创建一个Group，然后其它设备检索后连接 一旦连接成功，这些设备就处于同一自组网下了，组员是可以直接在WifiP2pGroup里面获取到群主的ip。接下来就可以直接用Socket进行各种骚操作了 至于群主如何获取组员的IP，目前想到的一种方式是群主开一个Socket监听，组员连接成功通过socket向群主发送一个请求，然后群主就可以在请求的socket对象里面获取组员的IP了]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用ngrok实现内网穿透]]></title>
    <url>%2F2018%2F03%2F19%2Fngrok_01%2F</url>
    <content type="text"><![CDATA[实现内网穿透紫ngrok无法通过天墙之后，国内也出现了一批成熟的商业化实现方案，诸如花生壳、net123、Sunny-ngrok等。不过免费的极不稳定还有流量带宽限制，最后还是决定自己搭一个。本文利用ngrok搭建一个用于内网穿透的环境。需求是通过一层反向代理，实现通过一个外网域名访问一个部署在局域网上的服务。 准备 一个公网服务器（Linux系统）==&gt; 阿里云，腾讯云之类的都行 这个公网服务器主要用作反向代理，我们在本文中称之为VPS服务器 一个独立的域名 一个用于提供服务的本地PC 步骤 GO语言环境搭建ngrok项目是用GO语言实现的，需要先安装GOLANG开发环境，系统不限，因为GO语言是跨平台的！安装过程很简单，参考官网的教程即可！ 获取ngrok源码12345# 下面是直接去ngrok的github地址下载（待会儿make的时候还会需要装几个其它的依赖，可能会出现很多问题）git clone https://github.com/inconshreveable/ngrok.git# 下面是笔者将代码clone下来，并添加了相应依赖之后的地址，如果用上面的方式出现错误，可以clone下面的地址git clone https://github.com/SunnyQjm/ngrok.git 解析域名因为我们自己搭建，需要使用自己的域名（以 test.j.cn ）为例，我们需要做以下解析： 1234test.j.cn ------------&gt; A记录到你的VPS服务器的IP# ngrok可以指定子域名，下面的解析方式可以让任意子域名都能得到正确的解析*.test.j.cn ------------&gt; CNAME记录到 test.j.cn 生成签名证书 因为我们是自己搭建，就不能用ngrok官方的SSL证书，需要自己生成 下面生成的证书在编译项目的时候要用到，所以务必要在编译之前生成 需要注意的是，客户端和服务器的证书必须是同一份，这样在程序在认证的时候才能正确解析 1234567891011121314151617# 首先导出环境变量，将下面的值替换成你的域名export NGROK_DOMAIN="test.j.cn"#先进入到ngrok的根目录，生成证书的操作需要在根目录下进行cd ngrok# 下面的命令用于生成证书openssl genrsa -out rootCA.key 2048openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=$NGROK_DOMAIN" -days 5000 -out rootCA.pemopenssl genrsa -out device.key 2048openssl req -new -key device.key -subj "/CN=$NGROK_DOMAIN" -out device.csropenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000# 下面的命令用于将我们生成的证书替换ngrok默认的证书cp rootCA.pem assets/client/tls/ngrokroot.crtcp device.crt assets/server/tls/snakeoil.crtcp device.key assets/server/tls/snakeoil.key 编译运行 服务端（VPS服务器一端） 首先指定一下环境变量，在不同的操作系统下需要指定不同的环境变量，才能正确编译(默认是Linux 64位的配置，如果你的服务器是64位的Linux系统，也可以不指定，直接用默认的就行) 123GOOS=linux GOARCH=amd64#如果是32位系统，这里 GOARCH=386#如果是windows系统，GOOS=windows 然后make出服务端程序 1make release-server 如果编译成功，你会在bin目录下看到ngrokd程序 1234cd bin# 查看使用帮助./ngrokd -h 查看使用帮助 123456789101112131415161718# 查看使用帮助./ngrokd -h -domain string Domain where the tunnels are hosted (default "ngrok.com") -httpAddr string Public address for HTTP connections, empty string to disable (default ":80") -httpsAddr string Public address listening for HTTPS connections, emptry string to disable (default ":443") -log string Write log messages to this file. 'stdout' and 'none' have special meanings (default "stdout") -log-level string The level of messages to log. One of: DEBUG, INFO, WARNING, ERROR (default "DEBUG") -tlsCrt string Path to a TLS certificate file -tlsKey string Path to a TLS key file -tunnelAddr string Public address listening for ngrok client (default ":4443") 启动服务端 12345# 如果不能执行，你可能需要用 sudo chmod +x ngrokd 给它执行权限# domain域输入之前生成证书时指定的域名# httpAddr 指定转发http协议的哪个端口# httpAddrs 指定转发https协议的哪个端口（如果不需要可以省略）./ngrokd -domain="$NGROK_DOMAIN" -httpAddr=":8000" -httpsAddr=":4433" 如果执行成功，你会看到类似以下界面： 12345[16:23:40 CST 2018/03/19] [INFO] (ngrok/log.(*PrefixLogger).Info:83) [registry] [tun] No affinity cache specified[16:23:40 CST 2018/03/19] [INFO] (ngrok/log.Info:112) Listening for public http connections on [::]:9748[16:23:40 CST 2018/03/19] [INFO] (ngrok/log.Info:112) Listening for public https connections on [::]:443[16:23:40 CST 2018/03/19] [INFO] (ngrok/log.Info:112) Listening for control and proxy connections on [::]:4443[16:23:40 CST 2018/03/19] [INFO] (ngrok/log.(*PrefixLogger).Info:83) [metrics] Reporting every 30 seconds 自此，服务端算是配置好了 客户端（部署了服务，需要内网穿透访问的主机） 客户端要做的事情就是指定把本机的那个端口暴露给VPS服务器，客户端要在该端口上部署了服务（web服务或者tomcat服务等），这样VPS就能够将请求转发到该端口对应的服务上了 12345678910111213141516171819202122232425262728293031323334# 因为前面说过，服务端和客户端的证书要是同一份，这样认证才能通过，所以好的解决方案是在服务端上把客户端程序也编译出来，然后通过scp命令拷贝到客户端# 假设我要在mac上运行客户端，需要在编译命令前加上一些参数(如果客户端服务器也是Linux 64位，则不用指定环境变量)GOOS=darwin GOARCH=amd64 make release-clientmake release-client# 编译好后scp到本地scp xxx xxx# 下面开始本地配置（下面的配置在客户端进行）# 新建一个配置文件（在ngrok/bin目录下）vim ngrok.cfg# 添加一下两行# 第一行是将要绑定的域名+4443端口（因为ngrok服务端默认有一个服务是坚挺在4443端口的，客户端会通过这个端口与之相连）==&gt; 记得将域名换成自己在生成证书时指定的server_addr: "test.j.cn:4443"trust_host_root_certs: true# 帮助信息./ngrok -hExamples: ngrok 80 ngrok -subdomain=example 8080 ngrok -proto=tcp 22 ngrok -hostname="example.com" -httpauth="user:password" 10.0.0.1# 80就是我们要转发的端口了./ngrok -config=./ngrok.cfg 80# 指定协议和端口，不指定默认是 http+https./ngrok -config=./ngrok.cfg -proto=tcp 22# 指定子域名，不指定就会随机生成./ngrok -config=./ngrok.cfg -subdomain=test 80 连接成功会显示如下状态： 在浏览器中输入http://127.0.0.1:4040，就可以看到请求的具体信息了！是不是很神奇！ 注意： 上文中所有出现域名的地方都要统一，客户端和服务端的证书要是同一份，否则在连接的时候会出现bad certification 参考： 自己建立ngrok服务器进行内网穿透 CentOS上搭建ngrok服务端（内网穿透）]]></content>
      <tags>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现监听移动端上下左右滑动事件]]></title>
    <url>%2F2018%2F01%2F24%2Fjs_01%2F</url>
    <content type="text"><![CDATA[Introduction最近刚入坑web前端，学了一点基础，便准备写个简单的2048小游戏试试手。开发过程中发现，PC端可以直接监听键盘输入，但是移动端就不得不监听屏幕上的滑动事件了。 现有的js库中没有可以直接满足上述要求的封装 在JQuery Mobile 中 可以通过 .on 的方式监听左右滑动事件，但是没有上下滑动事件（而且我想写一个PC端和移动端都通用的网页的话，就必须引入Jquery，同时引入Jquery和Jquery Mobile 使得Bootstrap中的按钮样式改变了，这显然不是想要的结果） 所以为了保持PC端和移动端的一致性，决定直接封装一下js的移动端的触摸事件，实现上述需求 2048可以在手机上打开，仍然具有不错的交互 点我体验 源码地址 JS 触摸事件（event） event的类型 touchstart: 当手指触摸屏幕时触发（相当于Android中的ACTION_DOWN事件） touchmove: 当手指在屏幕上滑动时连续触发（相当于Android中的ACTION_MOVE事件）— 期间调用preventDefault()可以屏蔽事件的默认行为，达到阻止滚动的效果 touchend: 当手指从屏幕上移开时触发（相当与Android中的ACTION_UP） touchcancel: 当系统停止跟踪触摸时触发。关于此事件的触发时机，文档中没有明确说明（我们在接下来的过程中也用不到） event用于跟踪触摸的属性 touches: 表示当前跟踪的触摸操作的Touch对象的数组 targetTouches: 特定于事件目标的Touch对象数组 changeTouches: 表示子上次触摸以来发生了什么改变的Touch对象的数组 注意： 在touchend事件发生时，event的touches对象中就没有元素了，需要到changeTouches中去获取触摸离开时的位置信息 Touch对象包含的数组 clentX: 触摸目标在窗口中的x坐标 clientY: 触摸目标在窗口中的y坐标 identifier: 标识触摸的唯一ID pageX： 触摸目标在页面中的x坐标 pageY： 触摸目标在页面中的y坐标 screenX： 触摸目标在屏幕中的x坐标 screenY： 触摸目标在屏幕中的y坐标 target：触摸的DOM节点目标 封装一个操作对象该对象的封装，前两个函数参考书籍《JavaScript 高级程序设计》（第三版） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var EventUtil = &#123; addHandler: function (element, type, handler) &#123; if (element.addEventListener) element.addEventListener(type, handler, false); else if (element.attachEvent) element.attachEvent("on" + type, handler); else element["on" + type] = handler; &#125;, removeHandler: function (element, type, handler) &#123; if(element.removeEventListener) element.removeEventListener(type, handler, false); else if(element.detachEvent) element.detachEvent("on" + type, handler); else element["on" + type] = handler; &#125;, /** * 监听触摸的方向 * @param target 要绑定监听的目标元素 * @param isPreventDefault 是否屏蔽掉触摸滑动的默认行为（例如页面的上下滚动，缩放等） * @param upCallback 向上滑动的监听回调（若不关心，可以不传，或传false） * @param rightCallback 向右滑动的监听回调（若不关心，可以不传，或传false） * @param downCallback 向下滑动的监听回调（若不关心，可以不传，或传false） * @param leftCallback 向左滑动的监听回调（若不关心，可以不传，或传false） */ listenTouchDirection: function (target, isPreventDefault, upCallback, rightCallback, downCallback, leftCallback) &#123; this.addHandler(target, "touchstart", handleTouchEvent); this.addHandler(target, "touchend", handleTouchEvent); this.addHandler(target, "touchmove", handleTouchEvent); var startX; var startY; function handleTouchEvent(event) &#123; switch (event.type)&#123; case "touchstart": startX = event.touches[0].pageX; startY = event.touches[0].pageY; break; case "touchend": var spanX = event.changedTouches[0].pageX - startX; var spanY = event.changedTouches[0].pageY - startY; if(Math.abs(spanX) &gt; Math.abs(spanY))&#123; //认定为水平方向滑动 if(spanX &gt; 30)&#123; //向右 if(rightCallback) rightCallback(); &#125; else if(spanX &lt; -30)&#123; //向左 if(leftCallback) leftCallback(); &#125; &#125; else &#123; //认定为垂直方向滑动 if(spanY &gt; 30)&#123; //向下 if(downCallback) downCallback(); &#125; else if (spanY &lt; -30) &#123;//向上 if(upCallback) upCallback(); &#125; &#125; break; case "touchmove": //阻止默认行为 if(isPreventDefault) event.preventDefault(); break; &#125; &#125; &#125;&#125;; 使用1234//使用的时候很简单，只需要向下面这样调用即可//其中下面监听的是整个DOM//up, right, down, left为四个回调函数，分别处理上下左右的滑动事件EventUtil.listenTouchDirection(document, true, up， right, down, left)]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高C考试说明]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_n%2F</url>
    <content type="text"><![CDATA[说明 最后一个高C课，老师旁边围了一圈，就有了如下信息 题型 简答：50 编程：30 实验：20 （代码分析，分析哪里错了…） 以下不用看括号里是我加的，以防万一 timewait不用看 key managment不用看 （知道怎么创建一个秘钥管理套接字：socket(PF_KEY, SOCK_RAW, 0)） ioctl 不用看 老师说会考 前几章重点 大端小端代码 traceroute、ping会考（研究生学长说不考，但是今年王老师出卷，其它先复习，有时间看看ping和traceroute的源码） HDR_INCL套接字选项（原始套接字设置该选项可以自己构造IP首部） BPF、DLPI、SOCK_PACKET（三种提供链路层访问控制的方式） 掌握netstat怎么用（用于显示各个端口的状态）]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（13）—— 线程（Threads）（第26章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_m%2F</url>
    <content type="text"><![CDATA[概述 用fork实现并发要求存在的问题 fork的代价是比较昂贵的 fork返回之后父子进程之间的信息传递需要进程间通信(IPC)机制。 使用线程可以有效的解决上面的问题 线程的创建是轻量级的，线程也被称为轻权进程（lightweight process）。线程的创建可能比进程快10~100倍 同一进程内的所有线程共享全局内存，这使得线程之间易于共享信息，然后随之而来的便是同步(synchronization)问题 同一进程内的线程共享： 全局变量 进程指令（process instruction） 大多数数据（most data） 打开的文件（open file）==&gt; 即描述符 信号处理函数和信号处置（Signal handlers and signal disposition） 当前工作目录（Current working directory） 用户ID和组ID（User and group ID） 线程独享以下内容： 线程ID （thread ID） 寄存器集合，包括程序计数器和栈指针 （Set of registers， including program counter and stack pointer） 栈（用于存放局部变量和返回地址） Stack（for local variables and return address） errno ==&gt; 全局动态变量（记录最近的一次错误） 信号掩码(Signal mask) 优先级(Priority)]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（12）—— 路由套接字和秘钥管理套接字（Routing Sockets and Key Managment Sockets）（第18章，第19章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_l%2F</url>
    <content type="text"><![CDATA[概述AF_ROUTE domain: 唯一支持的套接字是原始套接字(raw socket) 一个路由套接字上支持以下的三种操作 通过往路由套接字写数据来向内核发送消息（例如: 添加或删除路由） 通过从路由套接字读数据来接收内核发送的消息（例如：内核在接收到一个ICMP重定向消息的时候，就通过这种方式通知进程） 进程可以使用sysctl函数倾泻出路由表或列出所有已配置的接口 前两种需要超级权限，最后一种操作任何进程都可以执行 前两种可以复合起来使用，比如：进程通过写一个路由套接字往内核发送一个消息，请求内核提供关于某个给定路径的所有信息，又通过这个这个路由套接字接收内核的应答 数据链路套接字地址结构 &ensp; 1234567891011struct sockaddr_dl&#123; uint8_t sdl_len; //数据链路层地址是可变长度的，这个成员即为记录地址结构的长度 sa_family_t sdl_family; //AF_LINK uint16_t sdl_index; //网络接口的正值索引，if &gt; 0 uint8_t sdl_type; //IFT_ETHER等 uint8_t sdl_nlen; //名字的长度 uint8_t sdl_alen; //链路层地址的长度 uint8_t sdl_slen; //链路层选择器的长度 char sdl_data[12]; //数据域: 0 ~ sdl_nlen - 1 ==&gt; name // sdl_len ~ sdl_alen - 1 ==&gt; link-layer address&#125; 创建一个路由套接字 12int sockfd;sockfd = socket(AF_ROUTE, SOCK_RAW, 0); Key Managment 概述 PE_KEY domain: 唯一支持的套接字是原始套接字(raw socket) 创建一个秘钥管理套接字 12int sockfd;sockfd = socket(PF_KEY, SOCK_RAW, 0);]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（11）—— 数据链路访问（Datalink Access）（第29章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_k%2F</url>
    <content type="text"><![CDATA[概述目前大多数操作系统都为应用程序提供访问数据链路层的功能，这种功能可提供如下能力 能够监视由数据链路层接收的分组，使得诸如tcpdump之类的程序能够在普通计算机系统上运行，而无需使用专门的硬件设备来监视分组。如果使网络接口进入混杂模式(promiscuous mode)，甚至可以监听本地电缆上流通的所有分组 The ability to watch the packets received by the datalink layer, allowing programs such as tcpdump to be run on normal computer systems (as opposed to dedicated hardware devices to watch packets). (promiscuous mode) 能够作为普通应用进程而不是内核的一部分运行某些程序，例如：RARP The ability to run certain programs as normal applications instead of as part of the kernel. For example, most Unix versions of an RARP server are normal applications that read RARP requests from the datalink (RARP requests are not IP datagrams) and then write the reply back to the datalink 实现数据链路层访问的三个常见方法： BSD的分组过滤器BPF SVR4的数据链路提供者接口DLPI Linux的SOCK_PACKET接口 BPF4.4BSD and many other Berkeley-derived implementations support BPF DLPISVR4 provides datalink access through DLPI(Datalink Provider Interface) SOCK_PACKET and PF_PACKETTwo methods under Linux: SOCK_PACKET: original, widely available but less flexible PF_PACKET: newer method 1234/* newer systems*/fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));/* older systems*/fd = socket(AF_INET, SOCK_PACKET, htons(ETH_P_ALL)); 相关库 libpcap: 分组捕获函数和库 libnet：分组构造与输出库 检查UDP校验和字段的栗子见课本 图29-3]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（10）—— 原始套接字（Raw Socket）（第28章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_j%2F</url>
    <content type="text"><![CDATA[概述原始套接字提供TCP和UDP所不提供的以下3个能力 有了原始套接字，进程可以读与写ICMPv4、IGMPv4和ICMPv6分组 Raw sockets let us read and write ICMPv4, IGMPv4, and ICMPv6 packets. (ping, mrouted) 有了原始套接字，进程可以读写内核不处理其协议字段的IPv4数据报 With a raw socket, a process can read and write IPv4 datagrams with an IPV4 protocol field that is not processed by the kernel. 有了原始套接字，进程还可以使用IP_HDRINCL套接字选项（IP header include），自行构造IPv4首部 With a raw socket, a process can build its own IPv4 header using the IP_HDRINCL socket option 原始套接字的创建 创建 调用socket函数创建，而且函数的第二个参数必须是SOCK_RAW 123//下面以创建一个IPv4原始套接字为例int sockfd;sockfd = socket(AF_INET, SOCK_RAW, protocol); protocol参数通常不为0，是形如IPPROTO_xxx的某个常值 只有超级用户才能创建原始套接字（防止普通用户自行构造IP数据报） 可按以下方式开启IP_HDRINCL选项 123const int on = 1;if(setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &amp;on, sizeof(on)) &lt; 0) 出错处理 可在原始套接字上调用bind，但比较少见 可在原始套接字上调用connect，但比较少见 原始套接字输出原始套接字的输出遵循以下规则： 普通输出通过调用sendto或sendmsg并指定IP地址完成，如果套接字已连接，也可以调用write，writev，send Normal output is performed by calling sendto or sendmsg and specifying the destination IP address 如果IP_HDRINCL选项未开启，进程发送数据的起始地址是IP首部之后的第一个字节，IP首部由内核自行构造，并把socket中第三个参数的值设置进IP首部的协议字段 If the IP_HDRINCL option is not set, the starting address of the data for the kernel to send specifies the first byte following the IP header because the kernel will build the IP header and prepend it to the data from the process 如果IP_HDRINCL选项开启，进程发送数据的起始地址是IP首部的第一个字节，进程调用输出函数输出的数据中必须包括IP首部，整个IP首部自行构造 If the IP_HDRINCL option is set, the starting address of the data for the kernel to send specifies the first byte of the IP header IPv4标识字段可置为0，告诉内核设置该值 IPv4首部校验和字段总是由内核计算并存储 IPv4选项字段是可选的 内核会对超出外出接口MTU的原始分组进行分片 The kernel fragments raw packets that exceed the outgoing interface MTU 原始套接字输入内核把哪些接收到的IP数据报传递到原始套接字？遵循一下规则 规则 接收到的UDP和TCP分组绝不传递到任何原始套接字(如果一个进程想要读取，必须在数据链路层读取) Received UDP packets and received TCP packets are never passed to a raw socket. (must be read at the datalink layer) 大多数ICMP分组在内核处理完其中的ICMP消息后传递到原始套接字 Most ICMP packets are passed to a raw socket after the kernel has finished processing the ICMP message 所有的IGMP分组在内核完处理完其中的IGMP消息后传递到原始套接字 All IGMP packets are passed to a raw socket after the kernel has finished processing the IGMP message 内核无法识别其协议字段的所有IP数据报传递到原始套接字 All IP datagrams with a protocol field that the kernel does not understand are passed to a raw socket 如果某个数据报是以片段的形式到达，那么在它的所有片段均到达且重组之前，不传递任何片段到原始套接字 If t`he datagram arrives in fragments, nothing is passed to a raw socket until all fragments have arrived and have been reassembled. 内核在分配一个IP数据报到raw socket时的处理 When the kernel has an IP datagram to pass to the raw sockets, all raw sockets for all processes are examined, looking for all matching sockets. A copy of the IP datagram is delivered to each matching socket. The following tests are performed for each raw socket and only if all three tests are true is the datagram delivered to the socket 当内核分发IP数据报给原始套接字的时候，所有进程的所有原始套接字都将检查一遍，只要匹配，便获得该IP数据报的一个备份，下面是三个判断条件，只有当三个判断条件都为真时，内核才把接收的套接字传递给这个套接字 如果该原始套接字调用socket创建的时候，第三个参数指定了protocol（即不为0），则IP数据报中的协议字段，必须和其匹配 ==&gt; 协议匹配 如果该原始套接字已经调用了bind绑定到本地的某个IP地址，那么IP数据报中的地址字段，必须和其匹配 ==&gt; 目的地址匹配 如果该原始套接字已经调用connec连接了，则IP数据报的源端地址必须是connect所连接的对端设备的地址 ==&gt; 源端地址匹配 ping Program原理：往目的IP发送一个ICMP回射请求，该节点则以一个ICMP回射应答响应。由于ICMP规则要求回射应答中返回来自回射请求的标识符，序列号，以及可选数据。可以在可选数据中存放时间戳，以便在收到应答的时候就算RTT。（一般系统发送ICMP都有默认的TTL值大小（例如linux/unix 默认是64或255），提取出应答包中的TTL对当前主机和目的主机之间的跳数有一定指导意义） 一个没有特性蔓延（creeping featurism）的ping程序 自行阅读书上ping程序的源码 ping程序的概貌 traceroute Program 原理：一开始向目的节点发送一个TTL为1的 traceroute 可以用来测量本机到一个目的主机的路径 实现的原理是利用了IPv4的TTL字段或IPv6的跳限字段，一开始设置为1，然后中间节点会返回一个ICMP”time exceeded in transmit”（传输中超时）错误，接着逐渐增大TTL，从而逐步确定下一跳路由地址。直至目的节点返回一个ICMP”port unreachable”（端口不可达）错误，则表示到达目的节点（这要求目的节点没有在该端口上开启服务，即发送ICMP包时，目的端口号应该选择一个未被目的主机使用的端口号 ==&gt; traceroute选择了一个大于30000值作为目的端口号，因为UDP协议要求端口号必须小于30000，所以目的主机如果接收到必然会会一个ICMP端口不可达错误）。 早期用IP_HDRINCL来达到修改TTL的目的，现在多用IP_TTL套接字选项来修改]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（9）—— 名字和地址转换（Name and Address Conversions）（第11章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_i%2F</url>
    <content type="text"><![CDATA[概述数值地址长而不容易记，手工键入容易出错。用名字代表数字地址的机制便应运而生点我获取本文源码 主机名和IPv4地址之间转换：gethostbyname、gethostbyaddr 服务名字和端口号之间转换：getservbyname、getservbyport 两个协议无关的转换函数：getaddrinfo、getnameinfo 域名系统（Domain Name System， DNS） 主要用于主机名字和和IP地址之间的映射 基于UDP 简单名字（simple name）和全限定域名（Fully Qualified Domain Name， FQDN） 简单名字：如 solaris或bsdi 全限定域名：如 qjm253.top 严格来说FQDN最后必须以.结尾，但通常用户会省略。例如上面个域名严格来讲为： qjm253.top. 资源记录 A：A记录把一个主机名映射成一个32位的IPv4地址 AAAA：AAAA记录把一个主机名映射成一个128位的IPv6地址 PTR：称为指针记录（pointer record）的PTR记录把IP地址映射成主机名（IPv4、IPv6） MX：MX记录把一个主机指定作为个给定主机的“邮件交换器”（mail exchanger） CNAME：CNAME代表“canonical name”（规范名字），常用作为常用的服务指派CNAME记录 解析器和名字服务器（Resolvers and Name Servers） 名字服务器：存储了域名和IP地址的对应关系 解析器：客户端通过调用解析器中的函数来实现与DNS名字服务器的交互（实现名字与IP地址的转换） gethostbyname函数 原型：1234567891011121314151617181920#include &lt;netdb.h&gt;/*** 根据名字获取IPv4地址信息** @param 待转换的名字，如：qjm253.top* @return 成功则返回非空指针，出错则返回NULL，并且设置h_errno*/struct hostent *gethostbyname(const chat *hostname);/*** host entry 结构体，该结构中包含了所查找主机的所有IPv4地址信息*/struct hostent&#123; char *h_name; //正式主机名 char **h_aliases; //主机别名 int h_addrtype; //地址类型 int h_length; //地址长度，单位：byte char **h_addr_list; //主机包含的IPv4地址列表&#125; hostent结构和它所包含的信息 错误：h_errno 当调用gethostbyname出错时，便会设置h_errno的值为下列常值之一 类型 HOST_NOT_FOUND TRY_AGAIN NO_RECOVERY NO_DATA（等同于HOST_NOT_FOUND） hstrerrno函数接收一个上述常值之一，返回错误的具体描述 栗子： 本程序与课本略有不同，简单的支持一个地址解析以及默认解析IPv4 &ensp; ghbn.c12345678910111213141516171819202122#include &lt;unp.h&gt;int main(int argc, char **argv)&#123; char *ptr, **pptr; struct hostent *hptr; char str[INET_ADDRSTRLEN]; int i = 0; if(argc != 2) err_quit("usage: ./ghbn &lt;Domain name&gt;"); if( (hptr = gethostbyname(argv[1])) == NULL)&#123; err_msg("get hostbyname error for host %s : %s", argv[1], hstrerror(h_errno)); &#125; else &#123; printf("official hostname: %s\n", hptr-&gt;h_name); for(pptr = hptr-&gt;h_aliases; *pptr != NULL; pptr++) printf("\talist: %s\n", *pptr); for(pptr = hptr-&gt;h_addr_list; *pptr != NULL; pptr++) printf("address: %s\n", Inet_ntop(AF_INET, *pptr, str, sizeof(str))); &#125;&#125; 测试： 12345678910111213141516171819//我们先来测试一下正常的情况//可以很容易看出本博客是搭建在github上的，并且使用了一个作者自己的域名指向github上的域名输入： ./ghbn qjm253.top输出： official hostname: sni.github.map.fastly.net alist: qjm253.top alist: sunnyqjm.github.io address: 151.101.77.147//再来测试一下域名不存在的情况输入： ./ghbn qjm253.top.c输出： get hostbyname error for host qjm253.top.c : Unknown host//测试一下域名存在，但是没有映射地址的情况//qjm253.cn是笔者的一个保留域名，目前还没有解析到任何地址输入： ./ghbn qjm253.cn输出： get hostbyname error for host qjm253.cn : No address associated with name gethostbyaddr函数 原型：1234567891011#include &lt;netdb.h&gt;/*** 本函数试图由一个二进制的IP地址和找到相应的主机名，与gethostbyname的行为相反** @param addr addr参数实际上不是一个char *类型的指针，而是一个指向in_addr结构的指针* @param len len实际上就是in_addr结构体的大小* @param family 由于本函数只支持IPv4，所以family为AF_INET* @return 成功则返回非空指针，失败则返回NULL，并且设置h_errno**/struct hostent *gethostbyaddr(const char *addr, socklen_t len, int family); 栗子&ensp; ghba.c12345678910111213141516171819202122232425#include &lt;unp.h&gt;int main(int argc, char **argv)&#123; char *ptr, **pptr; struct hostent *hptr; char str[INET_ADDRSTRLEN]; struct sockaddr_in ia; if(argc != 2) err_quit("usage: ./ghbn &lt;IPAddress&gt;"); Inet_pton(AF_INET, argv[1], &amp;ia.sin_addr); if( (hptr = gethostbyaddr(&amp;ia.sin_addr, sizeof(ia.sin_addr), AF_INET)) == NULL)&#123; err_msg("get hostbyname error for host %s : %s", argv[1], hstrerror(h_errno)); &#125; else &#123; printf("official hostname: %s\n", hptr-&gt;h_name); for(pptr = hptr-&gt;h_aliases; *pptr != NULL; pptr++) printf("\talist: %s\n", *pptr); for(pptr = hptr-&gt;h_addr_list; *pptr != NULL; pptr++) printf("address: %s\n", Inet_ntop(AF_INET, *pptr, str, sizeof(str))); &#125;&#125; gethostbyaddr的第一个参数虽然是in_addr的地址结构，但是传的时候不能直接用in_addr，要使用sockaddr_in里面的in_addr。（博主猜想是应用的头文件中可能包含了in_addr结构体的多种实现，而gethostbyaddr函数要求的in_addr地址结构必须时候sockaddr_in里面定义的那种，读者有兴趣可以自行验证） 测试： 1234输入： ./ghba 127.0.0.1输出： official hostname: localhost address: 127.0.0.1 上面测试的是本机的回环地址，是成功的。如果要测试其它地址则不成功，具体可点我查看 getservbyname和getservbyport getservbyname 原型：1234567891011121314151617#include &lt;netdb.h&gt;/*** 通过服务名获取服务信息** @param servname 服务名，如：domain, ftp* @param protoname 协议名，如：TCP, UDP* @return 若成功则返回非空指针，若出错则返回NULL**/struct servent *getservbyname(const char *servname, const char *protoname);struct servent&#123; char *s_name; //正式的服务名 char **s_aliases; //服务别名列表 int s_port; //网络字节序的端口号 char *s_proto; //协议名&#125; 栗子&ensp; gsbn.c1234567891011121314151617#include &lt;unp.h&gt;int main(int argc, char **argv)&#123; struct servent *sptr; char **sptrs; if(argc != 3) err_quit("usgae: ./gsbn &lt;servname&gt; &lt;protoname&gt;"); sptr = getservbyname(argv[1], argv[2]); if(sptr == NULL) err_quit("get error"); printf("official name: %s\n", sptr-&gt;s_name); for(sptrs = sptr-&gt;s_aliases; *sptrs != NULL; sptrs++) printf("\t\talias: %s\n", *sptrs); printf("port: %d\n", sptr-&gt;s_port); printf("protocol: %s\n", sptr-&gt;s_proto);&#125; 测试1234567891011输入： ./gsbn domain udp输出： official name: domain port: 13568 protocol: udp输入： ./gsbn ftp tcp输出： official name: ftp port: 5376 protocol: tcp getservbyport 原型123456789#include &lt;netdb.h&gt;/*** 通过端口号获取服务的信息* @param port 端口号* @param protoname 协议名，如：TCP, UDP* @return 若成功则返回非空指针，若出错则返回NULL*/struct servent *getservbyport(int port, const char *protoname); 栗子&ensp; gsbp.c1234567891011121314151617#include &lt;unp.h&gt;int main(int argc, char **argv)&#123; struct servent *sptr; char **sptrs; if(argc != 3) err_quit("usgae: ./gsbn &lt;port&gt; &lt;protoname&gt;"); sptr = getservbyport(atoi(argv[1]), argv[2]); if(sptr == NULL) err_quit("get error"); printf("official name: %s\n", sptr-&gt;s_name); for(sptrs = sptr-&gt;s_aliases; *sptrs != NULL; sptrs++) printf("alias: %s\n", *sptrs); printf("port: %d\n", sptr-&gt;s_port); printf("protocol: %s\n", sptr-&gt;s_proto);&#125; 测试12345678//shell 通常运行在514端口，并且采用的是tcp协议输入： ./gsbp 514 tcp输出： official name: shell alias: cmd port: 514 protocol: tcp getaddrinfo函数这是一个比以上函数更新的函数，了解即可]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（8）—— UDP套接字编程（UDP Sockets Introduction）（第八章）]]></title>
    <url>%2F2018%2F01%2F06%2Fsuper_c_h%2F</url>
    <content type="text"><![CDATA[概述UDP编程和TCP编程有着本质的差异：UDP是无连接不可靠的数据报协议，非常不同于TCP提供的面向连接的可靠字节流点我获取本文源码 UDP的适用场景 DNS（域名系统） NFS（网络文件系统） SNMP（简单网络管理协议） 典型的UDP C/S 程序的函数调用 recvfrom和sendto函数 123456789101112131415161718192021222324252627282930313233#include &lt;sys/socket.h&gt;/*** 类似read函数，通过sockfd指向的套接字读数据** @param sockfd 目标描述符* @param buff 接收缓存，用于存放收到的数据* @param nbytes 指定接收的字节数* @param flags 标志位，14章详细讨论，此处都设为0* @param from 用于存放收到消息的源端地址* @param addrlen Value-Result参数，限定from大小，存放from实际大小** @return 成功 ==&gt; 返回收到的字节数* 出错 ==&gt; 返回-1*/ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen);/*** 类似write函数，通过sockfd指向的套接字写数据** @param sockfd 目标描述符* @param buff 发送缓存，用于存放要发送的数据* @param nbytes 指定发送的字节数* @param flags 标志位，14章详细讨论，此处都设为0* @param to 要发送的目的端地址* @param addrlen to结构的大小** @return 成功 ==&gt; 返回发送的字节数* 出错 ==&gt; 返回-1*/ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t addrlen); recvfrom返回0是可以接受的（不像read函数返回0代表对端关闭），因为UDP是无连接的 recvfrom调用的时候如果不关心发送端的地址，则后两个参数from和addrlen可以置为NULL。要注意的是，如果from传的是NULL，addrlen也必须传NULL（可能是由于recvfrom函数的内部实现导致的） recvfrom和sendto都可用于TCP，但通常不这么用 UDP实现简单的回射C/S程序 服务器程序123456789101112131415161718192021222324252627282930313233343536#include &lt;unp.h&gt;void dg_echo(int sockfd, SA *cliaddr, socklen_t clilen);int main(int argc, char **argv)&#123; int sockfd; struct sockaddr_in servaddr, cliaddr; //第二个参数指定为SOCK_DGRAM，标识创建一个UDP套接字 sockfd = Socket(AF_INET, SOCK_DGRAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9748); servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //为套接字绑定众所周知的端口号，以及指定接收哪些网络接口的请求 Bind(sockfd, (SA *) &amp;servaddr, sizeof(servaddr)); dg_echo(sockfd, (SA *) &amp;cliaddr, sizeof(cliaddr));&#125;void dg_echo(int sockfd, SA *cliaddr, socklen_t clilen)&#123; int n; socklen_t len; char mesg[MAXLINE]; for( ; ; )&#123; len = clilen; //接收客户号段发送的消息 n = Recvfrom(sockfd, mesg, MAXLINE, 0, cliaddr, &amp;len); //回射 Sendto(sockfd, mesg, n, 0, cliaddr, len); &#125;&#125; 这段程序和TCP服务端回射程序的实现逻辑类似，不一样的是收发消息用的是Recvfrom和Sendto 需要注意的是：UDP是无连接的，所以如果要给客户回发消息，就必须记录下客户的地址信息，Recvfrom的后两个参数就是用来记录客户的地址信息的，回发消息给客户的时候，用这个记录的地址信息即可 UDP层中隐含排队，所有收到的包都在队列中排队，recvfrom每次从队头取出消息处理，没有消息则阻塞（消息队列长度是有限制的，可通过SO_RCVBUF套接字选项修改） 客户端程序1234567891011121314151617181920212223242526272829303132333435363738#include &lt;unp.h&gt;void dg_cli_my(FILE *fp, int sockfd, SA *servaddr, socklen_t len);int main(int argc, char **argv)&#123; int sockfd; struct sockaddr_in servaddr; if(argc != 2) err_quit("usage: ./udpcli01 &lt;IPAddress&gt;\n"); //创建一个UDP套接字 sockfd = Socket(AF_INET, SOCK_DGRAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9748); Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr); dg_cli_my(stdin, sockfd, (SA *) &amp;servaddr, sizeof(servaddr));&#125;void dg_cli_my(FILE* fp, int sockfd, SA *servaddr, socklen_t len)&#123; int n; char sendline[MAXLINE], recvline[MAXLINE]; //从控制台接收用户输入，并发送给服务器 //接着接收服务器回射的消息，并输出到控制台 while( (Fgets(sendline, MAXLINE, fp)) != NULL)&#123; Sendto(sockfd, sendline, strlen(sendline), 0, servaddr, len); n = Recvfrom(sockfd, recvline, MAXLINE, 0, NULL, NULL); recvline[n] = 0; Fputs(recvline, stdout); &#125;&#125; 本段程序和TCP回射客户端程序的实现逻辑类似，同样的区别就在于对网络数据的读写操作不同 需注意的是：UDP是无连接的，所以客户端在调用Sendto的时候并不要求一定要有一个服务器在监听。即客户端只是负责把数据发出去，不管是否有人收到 TCP和UDP回射程序对比 两个客户的TCP客户/服务器小节 服务器每收到一个客户端的连接，便派生一个子进程，并将连接交付给子进程维护，父进程接着回去监听客户端的请求。在子进程中处理特定客户端的回射服务 两个客户的UDP客户/服务器小节 UDP服务器将收到的多个数据报置于套接字接收缓冲区中，再逐个取出，并根据Datagram报文中的发送端地址分别回复 对比 UDP回射服务程序是永不终止的，不像TCP中类似EOF的东西。而TCP回射服务程序，可以通过客户关闭连接导致服务端子进程中读到EOF，进而子进程退出。 大多数TCP服务器是并发的，而大多数UDP服务器是迭代的（TCP需要用连接标识不同的客户，并与之通信，所以一般做成并发。而UDP不需要维持连接，对收到的任何一个包进行处理都可以知道是谁发出的，对应处理即可，所以一个进程里面可以处理所有的请求） TCP通信必须要一个长期在线的服务端，并且服务端要先于客户端启动，而UDP通信则不用 可以看出，利用UDP进行通信的时候，并不要求服务器在客户端之前启动（即即便客户端比服务器先启动也是不会报错的，指示发出去的消息没有响应而已），只是服务器在启动之前，客户端无法获取到服务，一旦服务器启动，客户端变可以获取到服务。 相比之下，TCP进行进行通信的的时候，必须服务端先于客户端启动。因为TCP是有连接的，其通信依赖于一个已经建立好的连接，一旦连接无法建立，变无法进行通信（虽然可以在连接失败时反复尝试，但服务器没启动之前，客户端的connect函数都是返回错误的） UDP程序栗子小节 从客户角度总结UDP客户/服务器程序 从服务器角度总结UDP客户/服务器程序 服务器可从到达的IP数据报中获取的信息]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（7）—— 套接字选项（Socket Options）（第七章）]]></title>
    <url>%2F2018%2F01%2F05%2Fsuper_c_g%2F</url>
    <content type="text"><![CDATA[获取和设置影响套接字的三种方式 getsockopt和setsockopt函数和 fcntl函数 (file control) ioctl (IO control) getsockopt 和 setsockopt 函数这两个函数仅用于套接字 12345678910111213141516171819202122232425262728#include &lt;sys/socket.h&gt;/*** 获取一个打开的套接字的选项** @param sockfd 必须指向一个打开的套接字描述符* @param level 级别* @param optname 选项名* @param optval 指向一个变量的指针，用于接收函数的结果，其长度由最后一个长度限定* @param optlen 这是一个Value-Result参数，传入时限定optval的最大长度，防止缓存溢出* 函数执行结束时，可以通过这个参数知道内核究竟往optval写了多少数据* @return 成返回0，出错返回-1*/int getsockopt(int sockfd, int level, itn optname, void *optval, socklen_t *optlen);/*** 设置一个打开的套接字的选项** @param sockfd 必须指向一个打开的套接字描述符* @param level 级别* @param optname 选项名* @param optval 指向一个变量的指针，用于向函数传递要设置的值，其长度由最后一个长度限定* @param optlen 指示了optval的长度* @return 成返回0，出错返回-1*/int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); 套接字选项汇总 ==&gt; 课本图7-1和7-2 标志 ==&gt; 表示这个选项是一个二元选项。0表示关闭，非0表示开启 IPv4套接字选项下面几个选项的等级（level）均为IPROTO_IP IP_HDRINCL 可以为一个原始套接字设置该选项，设置以后可以自己构造IP首部（即在往里面写数据的时候是从IP包的首部起始位置开始写） IP_OPTIONS 该选项允许我们在IPv4中设置IP选项 IP_RECVDSTADDR 该套接字选项导致所收到的UDP数据报的目的IP地址由recvmsg函数作为辅助数据返回 IP_RECVIF 该套接字选项导致所收到的UDP数据包的接收接口索引有recvmsg函数作为辅助数据返回 IP_TOS 该套接字选项允许我们为TCP、UDP或SCTP套接字设置IP首部中的服务类型字段 IP_TTL 我们可以使用本选项设置或获取系统改用在从某个给定套接字发送的单薄分组上的默认TTL值]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（6）—— I/O复用（I/O Multiplexing）（第六章）]]></title>
    <url>%2F2018%2F01%2F05%2Fsuper_c_f%2F</url>
    <content type="text"><![CDATA[I/O复用概述进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件就绪（也就是说输入已准备好，或这描述符已能过承接更多的输出和），他就通知进程。这种能力称为I/O复用 应用场合 当客户处理多个描述符（通常是交互式输入和网络套接字）时，必须使用I/O复用 When a client is handling multiple descriptors (normally interactive input and a network socket) 一个客户同时处理多个socket套接字是可能的，不过比较罕见 It is possible, but rare, for a client to handle multiple sockets at the same time 如果一个TCP服务器既要处理监听套接字，又要处理已连接套接字 If a TCP server handles both a listening socket and its connected sockets 如果一个服务器既要处理TCP，又要处理UDP If a server handles both TCP and UDP 如果一个服务器要处理多个服务或者多个协议 If a server handles multiple services and perhaps multiple protocols (e.g., the inetd daemon) I/O复用的引用场景不仅仅局限于网络编程 I/O模型 blocking I/O ==&gt; 阻塞式I/O nonblocking I/O ==&gt; 非阻塞式I/O I/O multiplexing(select and poll) ==&gt; I/O复用 signal driven I/O (SIGIO) ==&gt; 信号驱动式I/O asynchronous I/O (the POSIX aio_functions) ==&gt; 异步I/O 阻塞式I/O模型 非阻塞式I/O模型 ==&gt; 轮询（polling） I/O复用模型 信号驱动式I/O模型 异步I/O模型 各种I/O模型的比较 同步I/O操作（synchronous I/O operation）：导致请求进程阻塞，知道I/O操作完成 异步I/O操作（asynchronous I/O operation）：不导致请求进程阻塞 上述5种模型中，前4种是同步的，最后一种是异步的 select函数select函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的事件后才唤醒它 Allows the process to instruct the kernel to wait for any one of multiple events to occur and to wake up the process only when one or more of these events occurs or when a specified amount of time has passed. (readable, writable, expired time) 原型12345678910111213141516171819202122232425262728293031323334353637#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;/*** 调用select函数可告知内核对哪些描述符（就读、写或异常条件）感兴趣以及等待多长时间** @param maxfdl 最大文件描述符* @param readset 读监听集（当监听集内任意描述符可读，会导致select解除阻塞状态）* @param writeset 写监听集（当监听集内任意描述符可写，会导致select解除阻塞状态）* @param exceptset 异常监听集（当监听集内任意描述符出现异常，会导致select解除阻塞状态）* @param timout 最长等待时长（如果该时间过去了，select会跳出）** @return 正常返回就绪描述符的总数* 0 ==&gt; 超时返回* -1 ==&gt; 出错*/int select(int maxfdl, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);struct timeval &#123; long tv_sec; //秒 long tv_usec; //微秒&#125;//fd_set的数据结构，实际上是一long类型的数组，每一个bit都能与一打开的文件句柄//（不管是socket句柄，还是其他文件或命名管道或设备句柄）建立联系typedef struct&#123;/*XPG4.2requiresthismembername.Otherwiseavoidthenamefromtheglobalnamespace.*/#ifdef__USE_XOPEN__fd_maskfds_bits[__FD_SETSIZE/__NFDBITS];#define__FDS_BITS(set)((set)-&gt;fds_bits)#else__fd_mask__fds_bits[__FD_SETSIZE/__NFDBITS];#define__FDS_BITS(set)((set)-&gt;__fds_bits)#endif&#125;fd_set; timeout NULL: 忙等 值为0：立即返回 不为0：至多等待一段时间后返回 fd_set fd_set通常是一个整数数组，其中每个元素中的每一bit对应一个文件描述符 四个操作宏 1234567891011//将监听集清0void FD_ZERO(fd_set *fdset);//将一个描述符对应的bit置1void FD_SET(int fd, fd_set *fdset);//将一个描述符对应的bit置0void FD_CLR(int fd, fd_set *fdset);//判断一个描述符对应的bit位是否被置1void FD_ISSET(int fd, fd_set *fdset); 举个栗子： 12345678910111213141516171819假设fd_set 只有8位 ==&gt; fd_set fs执行: FD_ZERO(&amp;fs)结果: 00000000执行: FD_SET(1, &amp;fs)结果: 01000000执行：FD_SET(3, &amp;fs)结果: 01010000执行: FD_CLR(1, &amp;fs)结果: 00010000执行: FD_ISSET(3)返回: 1执行: FD_ISSET(1)返回: 0 select函数中的三个监听集，如果对哪个不感兴趣，直接设置为NULL就行了 select函数中的三个监听集参数均为Value-Result参数 maxfdpl maxfdl指定待测试后描述符的个数，它的值是待测试的最大描述符加1（因为数组的下标是从0开始的） FD_SETSIZE 常值是fd_set中描述符的总数，通常是1024，不过一般用不到那么大。指定maxfdp1可以提高select的效率 描述符就绪条件 str_cli函数修订版 各种条件下的处理 如果对端TCP发送数据，那么该套接字可读，并且read返回一个大于0的值 如果对端TCP发送一个FIN，那么该套接字可读，并且read返回0（EOF） 如果对端TCP发送一个RST，那么该套接字可读，并且read返回-1，而errno中含有确切的错误码 修订版的str_cli函数12345678910111213141516171819202122232425262728293031323334/** * 改进后的str_cli函数，可以在服务器停止后马上返回 */void str_cli(FILE* fp, int sockfd)&#123; int maxfdpl; fd_set rset; char sendline[MAXLINE], recvline[MAXLINE]; //首先清0 FD_ZERO(&amp;rset); for( ; ; )&#123; //在调用select之前，设置监听集，告知select感兴趣的描述符 FD_SET(fileno(fp), &amp;rset); FD_SET(sockfd, &amp;rset); //待测试的描述符数应该比我们要监听的最大描述符要大1（因为c语言数组是从0开始计的） maxfdpl = max(fileno(fp), sockfd) + 1; //一直阻塞，直至上述两个描述符至少其中一个可读（没有指定超时时间，所以会一直等待） Select(maxfdpl, &amp;rset, NULL, NULL, NULL); if(FD_ISSET(sockfd, &amp;rset))&#123; //socket 可读 if(Readline(sockfd, recvline, MAXLINE) == 0) err_quit("str_cli: server terminated prematurely"); Fputs(recvline, stdout); &#125; if(FD_ISSET(fileno(fp), &amp;rset))&#123; //用户从控制台输入了数据 if(Fgets(sendline, MAXLINE, fp) == NULL) return; Writen(sockfd, sendline, strlen(sendline)); &#125; &#125;&#125; 点我查看示例源码地址 rset作为一个Value-Result参数使用 在select调用之前，将感兴趣的描述符对应的bit置位。这样在调用select的时候，告知Unix内核当哪些描述符准备好时应该通知用户 在select调用之后，Unix内核将哪些描述符准备好了记录在rset当中。故在select解除阻塞之后，可以用FD_ISSET判断是哪些描述符准备好了。(这样处理即便是多个描述符同时准备好了，也可以处理) 批量输入和缓存（Batch Input and Buffering） 交互式输入： 批量输入： 以第五章最初的回射函数为例 TCP是全双工通信的 我们假设客户以网络能接受的最快速度发送，而服务器以网络能提供的最快速度应答 在时刻7的时候，网络管道就已经充满了 如果在时刻8客户输^D(EOF)，则会导致客户端调用close函数关闭连接，而此时仍然还有请求在去的路上，也还有应答在回来的路上，这些消息客户端将无法再收到。 实际上这个时候客户只是不发数据了，但是仍然还需要接收数据。所以我们需要一个能够关闭TCP连接中其中一半的连接的方法 ==&gt; shutdown函数 shutdown函数 close函数的两个限制 close把描述符的引用计数减1，仅在该计数变为0时才关闭套接字。==&gt; 而shutdown可以不管引用计数就激发TCP的正常终止序列 clse终止读和写两个方向。==&gt; shutdown可以有选择的终止读、写或读写均关闭 原型123456789#include &lt;sys.socket.h&gt;/*** howto = SHUT_RD ==&gt; 关闭读一半* SHUT_WR ==&gt; 关闭写一半* SHUT_RDWR ==&gt; 读写均关闭* @return 成功返回0，出错返回-1*/int shutdown(int sockfd, int howto); 调用shutdown关闭一半连接的图示： 在调用shutdown关闭读一半以后，四路挥手的前两步已经完成，但此时客户端仍然可以读 直到服务器发送FIN，完成四路挥手 pselect函数是select新的衍生函数，了解一下用法 1234567#include &lt;sys/select.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;int pselect(int maxfdpl, fd_set *readset, fd_set *writeset, fd_set *exceptionset, const struct timesepc *timeout, const sigset_t *sigmask); 其它参数的功能和select的一致 最后一个参数是一个信号的掩码集，表示pselect在阻塞期间，禁止掩码集内的信号被递交]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（5）—— TCP C/S程序示例（TCP Client/Server Example）（第五章）]]></title>
    <url>%2F2018%2F01%2F05%2Fsuper_c_e%2F</url>
    <content type="text"><![CDATA[简单回射程序概述 客户从标准输入读入一行文本，并写给服务器 服务器从网络输入读入这行文本，并回射给客户 客户从网络输入读入这行回射文本，并显示在标准输出上 TCP回射服务程序 &ensp;tcpserv01.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;unp.h&gt;void str_echo(int);int main(int argc, char** argv)&#123; int listenfd, connfd; pid_t pid; socklen_t clen; struct sockaddr_in cliaddr, servaddr; listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9748); //指定服务端socket的地址为通配地址 //表示接收来自本机各个网络接口的连接请求 servaddr.sin_addr.s_addr = htonl(INADDR_ANY); Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr)); Listen(listenfd, LISTENQ); for( ; ; )&#123; clen = sizeof(cliaddr); connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clen); //接受到来自客户端的请求之后，fork一个进程，在子进程中为客户提供服务 //父进程则关闭本进程内该已连接描述符（引用计数减1） //然后再返回继续accept，可以达到并发的效果 if( (pid = Fork()) == 0 )&#123; //子进程执行 Close(listenfd); str_echo(connfd); Close(connfd); exit(0); &#125; Close(connfd); //父进程执行 &#125;&#125;/** * 为客户端提供服务 * 从客户端接收一个字符串，并将字符串回射回客户端 */void str_echo(int connfd)&#123; ssize_t n; char buf[MAXLINE];again: while((n = read(connfd, buf, MAXLINE)) &gt; 0) Writen(connfd, buf, n); if(n &lt; 0 &amp;&amp; errno == EINTR) goto again; else if(n &lt; 0) err_sys("str_echo: read error");&#125; 50 ～ 55: 这里用到的是系统的read函数，没有对信号中断错误处理，需要自己处理。（收到客户的FIN或EOF将导致read返回） TCP回射客户端程序 12345678910111213141516171819202122232425262728293031323334353637#include &lt;unp.h&gt;void str_cli(FILE*, int);int main(int argc, char** argv)&#123; int sockfd; struct sockaddr_in servaddr; if(argc != 2) err_quit("usage: ./tcpserv01 &lt;IPAddress&gt;"); sockfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_port = htons(9748); servaddr.sin_family = AF_INET; //调用inet_pton函数将用户输入的点分十进制串转化成网络字节序的32为IPv4地址 Inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr); Connect(sockfd, (SA *) &amp;servaddr, sizeof(servaddr)); str_cli(stdin, sockfd); Close(sockfd);&#125;/** * 用fgets读取用户的一行输入，发送给服务器，再从服务器接收一行回复并打印到控制台 */void str_cli(FILE* fp, int sockfd)&#123; char sendbuf[MAXLINE], recvline[MAXLINE]; while(Fgets(sendbuf, MAXLINE, fp) != NULL)&#123; Writen(sockfd, sendbuf, strlen(sendbuf)); if(Readline(sockfd, recvline, MAXLINE) == 0) err_quit("str_cli: server terminated prematurely"); Fputs(recvline, stdout); &#125;&#125; 正常启动 先启动服务器123456789//后台启动服务器./tcpserv01 &amp;[1] 10186//我们查看一下端口的状态，用管道过滤，只显示9748端口的信息netstat -a | grep 9748Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:9748 0.0.0.0:* LISTEN 接着直接在本机连接服务器123456789//连接到本机的回环地址./tcpcli01 127.0.0.1//再开一个shell，查看当前的端口状态状态netstat -a | grep 9748Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:9748 0.0.0.0:* LISTENtcp 0 0 localhost:9748 localhost:32890 ESTABLISHEDtcp 0 0 localhost:32890 localhost:9748 ESTABLISHED 0.0.0.0 ==&gt; 代表通配地址 * ==&gt; 代表通配端口 客户端在收到三路握手的第二个分节的时候，connect函数就返回了。而服务器在收到三次握手的第三个分节的时候accept才返回（之前分析过，服务器在收到第二个分节的时候还处于SYN_RECV状态，只有在收到第三个分节的时候才进入ESTABLISHED状态，此时相应的socket才被扔进监听套接字的已完成队列。而accept只在已完成队列中取socket，所以accept必定是在收到第三个分节之后才返回） 正常终止 状态转换图： 进程终止： 关闭本进程打开的所有的描述符 向父进程发送一个SIGCHLD信号 123456789101112./tcpcli01 127.0.0.1hellohello //服务器回射回来的good byegood bye //服务器回射回来的^D //Ctrl + D 相当于输入EOF//在客户端程序退出后马上查看端口状态（由于是本机测试，一定要快，要不然抓不到）netstat -a | grep 9748Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:9748 0.0.0.0:* LISTENtcp 0 0 localhost:33146 localhost:9748 TIME_WAIT 键入EOF后，客户端的fgets返回NULL，导致str_cli结束，最终导致main函数执行到exit而终止 进程终止的部分任务是关闭进程打开的所有的描述符，因此客户端打开的套接字由内核关闭，这导致客户TCP向服务器发送一个FIN，服务器回一个ACK。至此，四路挥手的前两步完成。服务器处于CLOSE_WAIT状态，而客户端处于FIN_WAIT_2状态 服务器TCP收到FIN后，readline函数返回0，导致str_echo退出，接着main函数执行到exit，进而导致服务端子进程退出。 同样的，服务端子进程所打开的所有描述符随之关闭。这导致服务器向客户发送一个FIN，客户回一个ACK，至此，四路挥手结束，连接完全终止。客户套接字进入TIME_WAIT状态。 进程终止的另一部分内容是：在服务器子进程终止时，给父进程发送一个SIGCHLD信号。由于我们在代码中没有捕获该信号，而该信号的默认处理为忽略，所以就导致子进程进入僵死状态123456789//我们调用ps命令来验证一下//因为笔者在测试的时候打开了客户端两次，所以有两个僵死的子进程ps -a PID TTY TIME CMD 2720 pts/0 00:00:21 hexo10186 pts/1 00:00:00 tcpserv0111146 pts/1 00:00:00 tcpserv01 &lt;defunct&gt; //僵死进程13389 pts/1 00:00:00 tcpserv01 &lt;defunct&gt; //僵死进程18996 pts/1 00:00:00 ps POSIX信号处理信号（signal）就是告知某个进程发生了某个事件的通知，有时也称为软件中断（software interrupt）。通常是异步的 每个信号关联一个处置（deposition），或称行为（action）。在信号发生时执行 类型 一个进程发给另一个进程（可以是自身） 由内核发给进程 三种处置 自定义信号处理函数，然后用sigaction设置给信号 SIGKILL和SIGSTOP不能被捕获12//信号处理函数原型void handler(int signo); SIG_IGN ==&gt; 忽略信号 SIG_DEF ==&gt; 默认处理 signal函数 原型： 123456789101112void (*signal(int signo, void (*func)(int)))(int);//定义新类型，来化简上面的原型typedef void Sigfunc(int)/*** 为一个信号设置处理函数* @param signo 信号* @param func 信号处理函数* @return 指向信号处理函数*/Sigfunc *signal(int signo, Sigfunc *func); POSIX规定设置信号的处置必须调用sigaction，上面的signal是对signation的封装，更容易使用 处理SIGCHLD信号 僵死状态 僵死（zombie）状态的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息包括子进程的进程ID、终止状态以及资源利用信息。如果一个进程终止，而该进程有子进程处于僵死状态，那么它的所有僵死子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们 处理僵死进程1234567891011//首先定义如下信号处理函数void sig_chld(int signo)&#123; pid_t pid; int stat; pid = wait(&amp;stat); printf("child %d terminated\n", pid); return;&#125;//在上面的server端程序的Listen之后添加下面这行Signal(SIGCHLD, sig_child); 点我查看源码 在执行了上面的处理之后，再测试，就观测不到僵死进程了 处理被中断的慢系统调用 适用于慢系统调用的基本规则：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误 有些系统上会发生，有些系统做了处理，不会发生。但是为了便于移植，还是建议用类似于下面的方法处理这种错误123456789for( ; ; )&#123; clilen = sizeof(cliaddr); if( (connfd = accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0)&#123; if(errno == EINTR) continue; else err_sys("accept error"); &#125;&#125; wait和waitpid函数 123456789101112131415161718#include &lt;sys/wait.h&gt;/*** 用于在父进程中清理已终止子进程（解除子进程的僵死状态）** @param wait函数通过这个参数返回子进程的终止状态* @return 成功则返回被清理子进程的ID，错误则返回0或-1*/pid_t wait(int *statloc);/*** 用于在父进程中清理已终止子进程（解除子进程的僵死状态）* @param pid 用于指定清理那个子进程，如果传入-1则表示等待第一个终止的子进程* @param statloc 函数通过这个参数返回子进程的终止状态* @param options 可选项* @return 成功则返回被清理子进程的ID，错误则返回0或-1*/pid_t waitpid(pid_t pid, int *statloc, int options); 调用wait函数的时候如果没有已经终止的子进程，不过仍然有一个或多个子进程在执行，那么wait函数将阻塞到其中任意一个子进程终止为止 waitpid的options可选项如果制定为WNOHANG，则告知内核在没有已终止子进程时不要阻塞 wait函数和waitpid的区别 waitpid可以指定终止哪个子进程，而wait不能 waitpid可以实现在没有已终止子进程时不要阻塞，而wait不能 根据上述区别的第二点我们改进之前的信号处理函数 12345678910//由于wait不能实现在没有已终止子进程时不要阻塞，所以在下面的循环中不能调用wait，否则可能会阻塞主线程//经过下面的修改之后，就可以支持一次调用清理多个进程的要求void sig_chld(int signo)&#123; pid_t pid; int stat; while( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0) printf("chihld %d terminated\n", pid); return;&#125; 具体可以参考课本5.10介绍的同时开五个连接请求的情况]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（3）—— 套接字编程简介（Sockets Introducrion）（第三章）]]></title>
    <url>%2F2018%2F01%2F04%2Fsuper_c_c%2F</url>
    <content type="text"><![CDATA[套接字地址结构（Socket Address Structures） 大多数套接字函数（socket function）都 需要一个指向套接字地址结构（socket address structure）的指针作为参数 每个协议族（protocol suite）都定义它自己的套接字地址结构 这些结构的名字均以sockaddr_开头，并以对应每个协议族的唯一后缀结尾 IPV4套接字地址结构&ensp;网际（IPV4）套接字地址结构：sockaddr_in&nbsp;-->&nbsp;定义在&lt;netinet/in.h&gt;当中12345678910111213struct in_addr&#123; in_addr_t s_addr; //32-bit ipv4 Address, network byyte ordered //32为的ipv地址，采用网络字节序&#125;；struct sockaddr_in&#123; uint8_t sin_len; //length of structure (16) sa_family_t sin_family; //AF_INET ==&gt;本地址结构是IPV4的地址结构，他属于网际协议族 in_port_t sin_port; //16-bit TCP or UDP port, 网络字节序 struct in_addr sin_addr; //32-bit ipv4 address, 网络字节序 char sin_zero[8]; //unused ==&gt; 保留位，未使用&#125; POSIX规范要求的数据类型 IPV4地址和TCP或UDP端口号都采用网络字节序（大端序）存储 IPV4地址存在两种访问方法（因为历史原因） serv.sin_addr (结构体) serv.sin_addr.in_addr_t （通常是一个无符号的32为整数） sin_zero字段未被使用，不过在填写这种结构的时候sin_zero通常被置为0。（通常的做法是，在填写之前，用bzero将整个结构体清0，再填写，可以保证未填写的部分都是0） 套接字地址结构仅在主机上使用，虽然结构体中的某些字段（例如IP地址和端口号）用在不同主机之间的通信，但是结构体本身并不在主机之间传递 通用套接字地址结构&ensp;通用套接字地址结构：sockaddr&nbsp;-->&nbsp;定义在&lt;sys/socket.h&gt;当中12345struct sockaddr&#123; uint8_t sa_len; sa_family_t sa_family; //Address family: AF_XXX value char sa_data[14]; //protocol-specific address&#125; 前面提到过，大多数套接字函数都需要一个指向套接字地址结构的指针。但是套接字函数大多支持多个协议族，也就是说在调用的时候可能传入不同协议族的地址结构指针，那套接字函数在定义的时候就必须要有一个类型，可以接收各个协议族对应的地址结构指针。 这种需求可以用void *来解决，实际上也更方便，如果用void *来定义，可以接收任意类型的指针，而且不用显示转换。但是void *实在ANSI C中提出的，而套接字函数是在ANSI C之前定义的，所以为了解决上述需求，采用了通用套接字，下面是一个套接字函数的栗子： 1234int bind(int, struct sockaddr *, socklen_t);//调用方式如下bind(sockfd, (struct sockaddr *) &amp;serv, sizeof(serv)); 通用套接字地址结构sockaddr和其他协议族各自的地址结构sockaddr_XX规定的最小size是一样的，都是16个字节 套接字函数在具体处理的时候根据sa_family字段区分不同的地址结构，对应不同的处理 IPV6套接字地址结构&ensp;IPv6套接字地址结构：sockaddr_in6&nbsp;-->&nbsp;定义在&lt;netinet/in.h&gt;当中12345678910111213141516struct in6_addr &#123; uint8_t s6_addr[16]; //128-bit IPV6 address&#125;;#define SIN6_LEN //require for compile-time testsstruct sockaddr_in6 &#123; uint8_t sin6_len; //length of this struct, 大小为28个字节 sa_family_t sin6_family; //AF_INET6 in_port_t sin6_port; //传输层端口，网络字节序 uint32_t sin6_flowinfo; //flow information, undefined struct in6_addr sin6_addr; //IPV6 address, 网络字节序 uint32_t sin6_scope_id; //set of interfaces for a scope&#125; 值-结果参数（Value-Result Argument） 一个参数，当函数调用时，其作为一个值从函数外传入函数内，当函数返回时，该参数又存储了函数执行的部分结果，这种类型的参数称为value-result参数 value-result参数总是以引用/指针的方式传递（只能用地址传递的方式，如果用值传递方式获取不到函数的返回信息） 上文曾提到过，当往一个套接字函数传递地址结构的时候，该结构总是以引用的方式传递（即传递地址结构的指针）。该结构的长度也作为一个参数来传递，不过其传递的方式可能是传值，也可能是传指针，具体的传递方式取决于该结构的传递方向：是从进程到内核，还是从内核到进程 从进程到内核传递套接字地址结构 涉及的函数有：bind、connect、sendto 传递结构长度的时候传值就好了 举个栗子： 12345struct sockaddr_in serv;/*fill in serv&#123;&#125;*/connect(sockfd, (SA *) &amp;serv, sizeof(serv)); 图示： 从内核到进程传递套接字地址结构 涉及的函数有：accpet、recvfrom、getsockname、getpeername 传递结构长度的时候传入一个指向socklen_t的指针（而不是int，POSIX规范建议将socklen_t定义为uint32_t） 举个栗子： 12345struct sockaddr_un cli;socklen_t len;len = sizeof(cli);getpeername(unixfd, (SA *) &amp;cli, &amp;len); 图示： 当函数被调用时，结构大小是一个值（value），它告诉内核该结构的大小，这样内核在写该结构的时候不至于越界；当函数返回时，结构大小又是一个结果（result），它告诉进程内核在该结构中究竟存储了多少信息。 字节排序函数（Byte Ordering） 大端和小端（big-endian and little-endian） 小端：低字节存储在起始地址 大端：高字节存储在起始地址 举个例子：123456780x0102//从左到右为内存增大方向//在大端系统中存储00000001 00000010//在小端系统中存储00000010 00000001 测试主机是大端还是小端的实践 –&gt; click_me123./byteorderx86_64-unknown-linux-gnu: little-endian 网络字节序 不同的机器可能采用不同的存储方式（大端/小端），为了统一，便为网际协议约定了一个网络字节序 网际协议使用大端字节序来传送多字节整数 由于不同主机的差异性，便需要有一些函数来进行网络字节序和主机字节序的转换 字节转换函数12345678910111213141516171819202122232425#include &lt;netinet/in.h&gt;/*** host to network short* 将主机字节序的16位短整型转换为网络字节序的16位短整型**/uint16_t htons(uint16_t host16bitvalue);/*** host to network long* 将主机字节序的32位整型转换为网络字节序的32位整型**/uint32_t htonl(uint32_t host32bitvalue);/*** network to host short* 将网络字节序的16位短整型转换为主机字节序的16位短整型**/uint16_t ntohs(uint16_t net16bitvalue);/*** network to host long* 将网络字节序的32位整型转换为主机字节序的32位整型**/uint32_t ntohl(uint32_t net32bitvalue); 事实上，在64为的系统中，尽管长整数占64位，htonl和ntohl函数操作的仍然是32位值 字节操纵函数字节操作函数和有两组，本书中只用到了bzero 源自Berkeley的函数（b开头的字节操纵函数）1234567891011121314151617#include &lt;strings.h&gt;/*** 将以dest为起始的目标串的前nbytes个字节置为0**/void bzero(void *dest, size_t nbytes);/*** 将dst中的前nbytes个字节拷贝到src串中**/void bcopy(const void *src, void *dst, size_t nbytes);/*** 比较ptr1和ptr2串的前n个字节* @return 若相等则返回0， 否则返回非0**/void bcmp(const void *ptr1, const void *ptr2, size_t nbytes); ANSI C函数（mem开头的字节操纵函数）123456789101112131415161718192021#include &lt;string.h&gt;/*** 把dest串的前len个字节置为c**/void *memset(void *dest, int c, size_t len);/*** memcpy类似bcopy，但是两个指针的位置时候是相反的** PS：当dest串和src串重叠时，bcopy可正常处理，memcpy的处理结果不可知，此时改用memmove函数**/void *memcpy(void *dest, const void *src, size_t nbytes);/*** 比较两个串的前nbytes个字节* @rerurn 0 相等* &gt;0 第一个不相等字节，ptr1 &gt; ptr2* &lt;0 第一个不相等字节，ptr1 &lt; ptr2**/void *memcmp(const void *ptr1, const void *ptr2, size_t nbytes); 之前的文章提到过有一个叫bzero宏的东西。其实是因为笔者的系统不是源自Berkeley的，所有没有bzero函数。但是Steven考虑的比较全面，为没有bzero函数的系统定义了一个bzero宏，间接调用memset函数，但是同样可以实现bzero的效果。 地址转换函数 地址转换函数在ASCII字符串和网络字节序的二进制值之间转换网际地址 inet_aton、inet_addr、inet_ntoa在点分十进制数串（例如“192.168.1.1”）与它长度为32位的网络字节序二进制值之间转换IPv4地址。 两个比较新的函数，inet_pton和inet_ntop对于IPv4和IPv6都适用 inet_aton、inet_addr 和inet_ntoa函数12345678910111213141516#include&lt;arpa/inet.h&gt;/*** 将strptr所指c字符串转换成一个32位的网络字节序二进制值，并通过addrptr指针来存储**/int inet_aton(const char *strptr, struct in_addr *addrptr);/*** 将strptr所指c字符串转换成一个32位的网络字节序二进制值, 并返回**/in_addr_t inet_addr(const char *strptr);/*** 将一个32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。**/char *inet_ntoa(struct in_addr inaddr); inet_addr 被废弃 inet_addr函数出错时返回INADDR_NOE(通常是一个32位均为1的值) 这意味着该函数不能处理“255.255.255.255”，因为它的二进制值和INADDR_NONE的值是一样的，被用来指示函数执行失败 inet_ntoa函数返回值所指向的串驻留在静态内存当中，着意味着该函数是不可重入的 上面这些函数至支持IPv4，如果要支持IPv6，使用下面介绍的两个函数 inet_pton 和 inet_ntop 函数1234567891011121314151617181920#include &lt;arpa/inet.h&gt;/*** 尝试转换由strptr所指的字符串，并通过addrptr指针存放二进制结果** @return 1 ==&gt; 转换成功* 0 ==&gt; 输入的不是有效表达式* -1 ==&gt; 转换出错**/int inet_pton(int family, const char*strptr, void *addrptr);/*** 与inet_pton进行相反的转换，从数值格式（addrptr）转换到表达式格式（strptr）。* @param len 指定目标存储单元的大小，以免该函数溢出调用者的缓冲区* @param strptr 用来存储目标串，如果执行成功，返回值即为这个指针* （不能传递空指针，调用这必须为目标存储单元分配内存，并指定其大小）* @return NULL ==&gt; 失败* strptr ==&gt; 成功**/const char *inet_ntop(int family, void *addrptr, char *strptr, size_t len); 两个函数的family参数可以是AF_INET或AF_INET6。如果以不被支持的地址族作为family参数。这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT sock_ntop和相关函数 在使用inet_ntop的时候，对于IPv4和IPv6的调用方法不同（这使得我们的代码和协议相关了）： 1234567//IPv4struct sockaddr_in addr;inet_ntop(AF_INET, &amp;addr.sin_addr, str, sizeof(str));//IPv6struct sockaddr_in6 addr6;inet_ntop(AF_INET6, &amp;addr6.sin6_addr, str, sizeof(str)); 所以Steven针对上述问题写了下面这么个封装函数 123456789#include "unp.h"/*** 同时支持IPv4和IPv6版本的inet_ntop** @return 成功 ==&gt; 非空指针* 出错 ==&gt; NULL**/char *sock_ntop(const struct *sockaddr, socklen_t addrlen); sock_ntop的实现和其它相关函数此处不做详细讨论，有兴趣可以查看Steven的《Unix 网络编程 卷1》 readn, writen 和 readline 函数 12345678910111213141516#include "unp.h"/*** 从一个描述符中读n字节**/ssize_t readn(int filedes, void *buff, size_t nbytes);/*** 往一个描述符里写n个字节**/ssize_t writen(int filedes, const void *buff, size_t nbytes);/*** 从一个描述符中读文本行，以字节为单位**/ssize_t readline(int filedes, void *buff, size_t maxlen); 上面三个函数对read和write操作可能发生的EINTR错误做了处理，是比较安全的读写函数]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（4）—— 基本套接字函数（Elementary Sockets Functions）（第四章）]]></title>
    <url>%2F2018%2F01%2F04%2Fsuper_c_d%2F</url>
    <content type="text"><![CDATA[socket函数 1234567891011121314151617#include &lt;sys/socket.h&gt;/*** 该函数用于创建一个socket套接字* @param domin 协议族/地址族* @param type 套接字的类型* SOCK_STREAM ==&gt; TCP套接字* SOCK_DGRAM ==&gt; UDP套接字* SOCK_RAW ==&gt; 原始套接字* SOCK_PACKET ==&gt; 可用于链路层访问控制* @param protocol 指定协议** @return 返回一个socket描述符 sockfd* sockfd &lt; 0 ==&gt; 创建失败* sockfd &gt;= 0 ==&gt; 创建成功，之后可用该sockfd进行IO操作**/int socket(int family, int type, int protocol); family 常值 type 常值 protocol 常值 socket函数中的family不是任意组合都是有效的，下面是组合效果： AF_XXX 和 PF_XXX AF_前缀表示地址族，PF_前缀表示协议族 历史上曾有这样的想法：单个协议族可以支持多个地址族，PF值用来创建套接字，而AF值用于套接字地址结构。 但实际上，支持多个地址族的协议从未出现过，而且头文件 &lt;sys/socket.h&gt;中为一给定协议定义的PF值总是与此协议的AF值相等 connect函数 123456789/**T* 该函数用于建立与指定socket的连接* @param sockfd 一个未连接的socket的描述符* @param sockaddr 指向要连接的套接字的sockaddr结构体的指针* @param addrlen 上述sockaddr结构体的长度** @return 成功则返回0, 失败返回-1, 错误原因存于errno 中**/int connect(int sockfd, const struct sockaddr * servaddr, int addrlen); 如果是TCP套接字，调用connect函数将激发TCP的三路握手过程。而且仅在连接建立成功或出错时才返回 connect错误： ETIMEOUT（超时错误）: TCP客户没有收到对发出的SYN分节的响应 ECONNREFUSED（连接拒绝错误）：客户在发出SYN分节后收到RST响应 表明服务器主机在我们指定的端口上没有进程在等待与之连接（通常是服务器进程没有在运行，或者是客户端连接的时候指定了错误的端口号） 或TCP向取消一个已有的连接 或TCP接收到一个根本不存在的连接上的分节 硬错误（hard error） EHOSTUNREACH或ENETUNREACH（主机不可达或） 客户咋中间的某个路由器上引发了一个“destination unreachable”（目的地不可达）ICMP错误 并且在某个规定时间（4.4BSD规定75s）内仍未收到响应 软错误（soft error） 状态转换 TCP状态转换图 connect函数导致当前客户套接字从CLOSED状态（该套接字自从由socket函数创建以来，一直处于CLOSED状态）转移到SYN_SENT状态 如果连接成功则转移到ESTABLISHED状态 若connect失败，则该套接字不可再用，必须关闭，我们不能对这样的套接字再次调用connect函数 当循环调用函数connect为给定主机尝试各个IP地址直到有一个成功时，在每次connect失败后，都必须close当前的套接字描述符并重新调用socket bind函数 bind函数把一个本地协议地址赋予一个套接字 对于网际协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口号的组合 调用bind函数可以指定一个端口号，或指定一个IP地址，也可以两者都指定或两者都不指定 1234567891011/***** sockfd： 标识一未捆绑套接口的描述字。* my_addr： 赋予套接口的地址。sockaddr结构定义如下：* struct sockaddr&#123;* u_short sa_family;* char sa_data[14];* &#125;;* addrlen： my_addr的长度。* 返回值： 成功返回0，失败返回-1.****/int bind( int sockfd , const struct sockaddr * my_addr, socklen_t addrlen); 端口的绑定 通常用于服务器在启动的时候捆绑他们众所周知的端口 对于客户机，不调用bind绑定端口，而是在发送消息的时候由内核临时分配一个端口，这是正常的 而对于服务器而言，不绑定端口是极为罕见的 地址的绑定 进程可以把一个特定的IP地址绑定到它的套接字上，不过这个IP必须属于其所在主机的网络接口之一 对于客户端而言，绑定IP地址就相当于为该套接字上发送IP数据报指定了源IP地址 对于服务器而言，绑定IP地址就相当于限定该套接字只能接收那些目的地为这个IP地址的客户连接 给bind函数指定要捆绑的IP地址和端口号产生的结果 通配地址(wildcard address) IPv4: INADDR_ANY 123//IPv4struct sockaddr_in servaddr;servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //wildcard IPv6: in6addr_any 123//IPv6struct sockaddr_in6 serv;serv.sin6_addr = in6addr_any; //wildcard 错误 EADDRINUSE(“Address already in use”, 地址已使用) listen函数仅由TCP服务器调用，它做两件事情 当socket函数创建一个套接字时，它被假设为一个主动套接字(active socket)，也就是说，它是一个将调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，之后是内核应接收指向该套接字的连接请求。 本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数 123456/*** 将一个未连接的套接字转换成监听套接字，这样即可以用来监听来自客户端的请求了* @param sockfd 一个未连接的套接字描述符* @param backlog 等待连接队列的最大长度**/int listen( int sockfd, int backlog); 调用时机 本函数通常应该在调用socket和bind这两个函数以后，并在调用accept函数之前调用 内核为任何一个给定的监听套接字维护两个队列 未完成连接队列（incomplete connection queue）：服务器收到请求的SYN分节，并且正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态 已完成连接队列（completed connection queue）：每个已完成TCP三路握手过程的客户对应其中的一项。这些套接字处于ESTABLISHED状态 点我可查看TCP状态转换图 listen函数的第二个参数通常指的是已完成连接队列的最大长度 两个队列的建立时机 accept函数 accpet函数由TCP服务器调用，用于从已完成连接队列头返回一个已完成连接 如果已完成连接队列为空，那么进程将被投入睡眠（假定套接字为默认的阻塞方式） 12345678910/*** 在一个套接字的监听队列中取一个连接，如果没有，则死等** @param sockfd 监听描述符（在调用listen之后监听来自客户端的连接）* @param addr (可选)用来保存新连接的源端地址* @param addrlen (可选)用来保存新连接的源端地址结构的长度** @return 如果连接成功，则返回一个已连接的套接字描述符（用于和客户端通信）**/SOCKET accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 后两个参数为Value-Result参数 ==&gt; 点我查看Value-Result参数详情 fork和exec函数 fork函数12345678#include &lt;unistd.h&gt;/*** 调用fork函数创建一个新进程，与当前进程并行执行** @return 在子进程中为0，在父进程中为子进程ID，若出错返回-1**/pid_t fork(void); fork函数是Unix中派生新进程的唯一方法 调用一次，返回两次。返回值告知当前进程是子进程还是父进程 子进程可通过getppid获取父进程的id 父进程fork之前打开的所有文件描述符都会copy一份给子进程（各个描述符的引用计数加1） 两个典型用法： 创建自身副本，每个副本并行执行各自的操作 一个进程想要执行另一个程序，则fork一下，在子进程调用exec执行其它程序 exec函数1234567#include &lt;unistd.h&gt;int execl(const char* pathname, const char *arg0, ... /*(char*)*/);int execv(const char* pathname, char* const *argv[])... 存放在硬盘上的可执行程序文件能够被Unix执行的唯一方法是：由一个现有的进程调用上述6个exec函数中的一个 exec把当前进程映像替换成新的程序文件，而且该程序通常从main函数开始执行。进程ID不改变 我们称调用exec的进程为调用进程（calling process），称新执行的程序为新程序（new program） 这些函数只在出错时才返回到调用跟着，否则，控制将被传递给新程序的起始点，通常就是main函数 6个exec函数的关系 描述符引用计数 Unix系统内核为每个文件描述符（包括socket fd）维护一个引用计数,这个引用计数标识当前打开着的引用该文件或套接字的描述符的个数 当某个文件描述符或套接字描述符关闭的时候，不是直接关闭文件或套接字，而是引用计数减1，当引用计数减到0的时候执行关闭操作 需要注意的是：如果多个进程同时拥有指向同一个文件或套接字的描述符。且其中一个没有关闭（并且不再使用了），则就算其他文件描述符都关闭了，这个文件或套接字也不会关闭。就会造成内存泄露 举个栗子： 123456789101112131415161718pid_t pid;int listenfd, connfd;listenfd = Socket(...);/*fill in sockaddr_in&#123;&#125; with server's well-know port*/Bind(listenfd, ...)Listen(listenfd, LISTENQ);for( ; ; )&#123; connfd = Accept(listenfd, ...); if( (pid = Fork()) == 0 )&#123; //子进程 Close(listenfd); doit(connfd); Close(connfd); exit(0); &#125; Close(connfd); //父进程&#125; 上面的代码中，调用了fork之后，connfd和listenfd在父子进程中都有一份 所以在父进程中，只用处理listenfd，故关掉connfd 在子进程中，只用处理connfd，故关掉listenfd 试想：如果父进程中没有关闭connfd，则就算子进程执行完毕，connfd关联的套接字的引用计数还是不为0，所以一直不会释放。连接多了之后，每个连接的socket都不释放，慢慢的服务器内存就炸了。 close函数 123456789#include &lt;unistd.h&gt;/*** 通常Unix close函数也用来光比套接字，并终止TCP序列** @return 0 ==&gt; 成功* -1 ==&gt; 出错**/int close(int sockfd); 通常close函数的默认行为是把该套接字标记成已关闭，然后立即返回 被标记的套接字不能再被进程使用，即不能read/write 然后尝试将缓存或队列中所有的Message发出 接着就是正常的TCP终止序列 close函数会将读和写两个方向的连接都关掉 gesockname 和 getpeername 函数 1234567891011#include &lt;sys/socket.h&gt;/*** 返回与sockfd关联的本地协议地址**/int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);/*** 返回与sockfd关联的外地协议地址**/int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen); 其中，两个函数的后两个参数均为Value-Result参数 可以用getsockname获取内核为我们分配的地址或端口号 getsockname还可以用于获取某个套接字的协议族 上面两个函数中的第一个参数sockfd必须是已连接的套接字描述符 当服务器进程通过accept的某个进程通过调用exec执行程序时，getpeername是唯一可以用来获取对端设备地址信息的函数]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（2）—— 传输层：TCP、UDP、SCTP（第二章）]]></title>
    <url>%2F2018%2F01%2F03%2Fsuper_c_b%2F</url>
    <content type="text"><![CDATA[总图（Big Picture） UDP UDP应用程序将数据封装到UDP数据报，，并将其写到UDP socket。进而封装成IPV4或IPV6数据报（datagram），然后发送到目的地 UDP提供的是无连接的服务（connectionless service） 每个UDP数据报都有一个长度，如果一个数据报正确地到达目的地，那么数据报的长度将随数据一道传递给接收端应用程序 RFC 768 [Postel 1980] TCP 面向连接（Connection-oriented） 提供可靠传输（Reliable） TCP通过给每个字节关联一个序列号（sequence）对所发送的数据进行排序（sequencing） TCP提供流量控制（flow control）==&gt; 控制接收端收包的速率 全双工（full-duplex） TCP连接的建立和终止 三路握手 ———— Three-Way Handshake (SYN, ACK) 服务器通过socket，bind，listen创建一个监听socket，并调用accpet准备接受外来的连接（这些工作要在客户端请求来临之前做好）。 客户端通过socket函数创建一个未连接的socket，再调用connect尝试连接到服务器（此时客户端阻塞，等待服务器响应）。此时会向服务器发送一个SYN包（表明客户端欲向服务器申请服务），等待服务器的确认。 服务器收到SYN包，则向客户端发送一个ACK（告诉客户端，请求我已经收到）。同时发送一个SYN（通知客户端服务器需要知道客户端是否收到回复，收到则请回一个ACK） 客户端收到服务器发回的ACK和SYN之后，connect函数返回（表示连接服务器成功），并向服务器回一个ACK（告知服务器我已经收到你的回复） 服务器收到客户端的ACK以后accept函数返回（此时连接正式建立，可以开始后通信） ACK如果不捎带数据的话，是不占序列号的 SYN占一个序列号 四路终止 ———— Four-Way Termination (FIN, ACK) 客户端调用close（任意一端都可以发起终止，此处以客户端发起为例，发起终止的一端称为执行主动关闭）。接着向服务器发送一个FIN，表示数据发送完毕 服务器接收到FIN后回复一个ACK（此时服务器称为执行被动关闭的一端），同时服务器的read函数会读到一个EOF，导致read函数退出 一段时间后，服务器也调用close，向客户端发送一个FIN 客户端收到FIN以后回复一个ACK FIN占一个序列号 在被动关闭一端收到FIN到其调用close函数之间的间隙，称为半关闭状态（half-close），在这段时间内理论上仍然有发送数据的可能（但是通过close方式关闭的话，时无法再进行通信的，因为close会同时关闭写一端和读一端，后面接收shutdown就可以只关闭写或读） 当一个Unix进程无论自愿（调用exit或main函数返回）还是非自愿（收到一个终止本进程的信号）的终止时，所有打开的描述符都将被关闭，这也导致主机向仍然打开的任何TCP连接上发出一个FIN（对于那些描述符只被这个终止的进程持有的连接而言） TCP状态转换图 上述状态转移图中的细线表示的是可能执行的路线。粗线和虚线表示的是TCP服务器和客户端正常情况（或说大多数情况）走的状态转移路线。 当发生错误，或遇到一些比较凑巧的事件，就可能走细线指向的转移路线 举例来说：途中有一条细线是SYN_SENT ——&gt; SYN_RCVD的 这种情况可能是客户端发出了一个SYN到服务器，并希望服务器回一个ACK和一个SYN 但是由于一些不可预知的错误，服务器返回的SYN和ACK只有SYN回到了客户端，而ACK则延迟了或丢了 这个时候客户端的状态就转移到了SYN_RCVD。之后一旦收到ACK（可能是服务器发送的消息丢包后重传，也可能是延迟的消息到达了），则客户端的状态可正常转移到ESTABLISHED状态 TCP的限制 TCP同时提供可靠数据传输和严格的有序数据分发。然而有一些应用程序需要可靠数据传输，但是不需要顺序维护，而另一些应用过程序只需要部分有序即可。 TCP这种面向数据流的传输方式有时候是不方便的。应用程序必须添加自己的记录标记。 TCP套接字的范围有限，使得为多宿主主机提供高可用数据传输能力的任务变得复杂 容易受到拒绝服务攻击，例如SYN攻击 这些限制影响公共交换电话网的IP性能 端口号（Port Numbers） 众所周知（well-know）的端口：0 ~ 1023 已注册端口：1024 ～ 49151 动态或私有端口：49152 ～ 65535 TCP端口号与并发服务器]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（1）—— Introduction（第一章）]]></title>
    <url>%2F2018%2F01%2F02%2Fsuper_c_a%2F</url>
    <content type="text"><![CDATA[Introduction A Simple Daytime Client A Simple Daytime Server A Simple Daytime Client Steven源码地址 笔者加注释源码地址 功能： 实现向服务器发起一个TCP连接，请求时间信息，并将接收到的信息打印在控制台上 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;unp.h&gt;int main(int argc, char** argv)&#123; /*sockfd 套接字描述符，客户端通过该描述符与服务器进行通信（它指示一个与服务器的连接）*/ int sockfd, n; char recvline[MAXLINE + 1]; /*接收缓存*/ /*服务器地址，用来保存服务器的地址信息（该结构体专门保存IPV4地址），包括ip和端口*/ struct sockaddr_in servaddr; /*如果输入参数不够，则报错并退出*/ if(argc != 2) err_quit("usage: daytimecli &lt;IPAddress&gt;"); /*通过socket函数创建一个套接字，创建失败则退出*/ if( (sockfd = socket(AF_INET, SOCK_STREAM, 0) ) &lt; 0) err_sys("socket error"); /*清0*/ bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; /*指定协议族为网际协议族*/ servaddr.sin_port = htons(13); /*指定端口为13*/ /*将用户从命令行输入的IP存到servaddr中，如果用户输入的格式不正确*/ /*则该函数会返回小于0的错误信息，此时退出应用程序*/ if(inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0) err_quit("inet_pton error for %s", argv[1]); /*连接到servaddr指向的服务器，连接失败则退出*/ if(connect(sockfd, (SA *)&amp;servaddr, sizeof(servaddr)) &lt; 0) err_sys("connect error"); /*读取服务器发回的信息*/ while( (n = read(sockfd, recvline, MAXLINE)) &gt; 0 )&#123; recvline[n] = 0; /*输出到控制台*/ if(fputs(recvline, stdout) == EOF) err_sys("fputs error"); &#125; if(n &lt; 0) err_sys("read error"); exit(0);&#125; struct sockaddr_in 组成 12345678910111213141516/*** 下面是三个struct sockaddr_in的主要成员，数据的具体类型不同的系统不同，* 可以大概理解成下面这样，具体的定义可以查看源码**/unsigned short sin_family; /*源码中并不是直接表示成这样，用了几层宏定义，不过在*/ /*笔者的电脑上，其最原始的定义为 unsigned short*/u_16 sin_port; /*u_16表示无符号16位的数，范围为0~65535*/struct in_addr sin_addr;/*** struct in_addr 的结构如下**/struct in_addr&#123; __be32 s_addr; /*__be32 通常为 unsigned int(32位)*/&#125; 用于存储IPV4的地址信息，包括ip，端口，协议族（IPV4属于 AF_INET） socket() 百度百科–&gt; click_me click me for detail 原型123456789101112131415/*** 该函数用于创建一个socket套接字* @param domin 协议族/地址族* @param type 套接字的类型* SOCK_STREAM ==&gt; TCP套接字* SOCK_DGRAM ==&gt; UDP套接字* SOCK_RAW ==&gt; 原始套接字* SOCK_PACKET ==&gt; 可用于链路层访问控制* @param protocol 指定协议** @return 返回一个socket描述符 sockfd* sockfd &lt; 0 ==&gt; 创建失败* sockfd &gt;= 0 ==&gt; 创建成功，之后可用该sockfd进行IO操作**/int socket(int domain, int type, int protocol); 需注意的是，socket函数的后两个参数不能随意组合。比如在type = SOCK_STRAM 的时候 protocol ≠ IPPROTO_UDP。（当第三个参数为0的时候，会自动选择第二个参数类型对应的默认协议） bzero 原型 1234/*** bzero为一个宏函数，实际上调用的是memset**/#define bzero(ptr, n) memset(ptr, 0, n) void *memset(void *s, int ch, size_t n);** bzero(ptr, n) ==&gt; 以ptr所指为起始，将紧接着的n位置成 0 (可以达到清0的效果) htons() 百度百科–&gt; click_me 原型1234/*** 将一个无符号短整型从主机字节序转网络字节序**/u_short htons(u_short hostshort); 网络字节序统一为 大端（big-endian）序，而现在大部分主机采用的是小端系统，也有机器采用大端系统。为了统一，调用这个函数之后均采用大端序（协议统一） inet_pton() 百度百科–&gt; click_me 原型：12345678910111213/*** 将“点分十进制” --&gt; “二进制整数”** @param af address family(地址族)* @param src 指向一个字符串，这个字符串为一个点分十进制的串，例如："192.168.1.1"* @param dst 指向一个数据结构，用来存储转换后的结果* 如果af = AF_INET, 即为ipv4地址转换，则函数会将结果放在一个in_addr结构体中* 如果af = AF_INET6, 即为ipv6地址转换，则函数会将结果放在一个in_addr6结构体中** @return 如果函数出错则返回一个负值，并将errno置为EAFNOSUPPORT。* 如果参数af指定的地址族和src格式不对，则返回0**/int inet_pton(int af, const char *src, void *dst); inet_pton同时支持和IPV4和IPV6 connect() 百度百科–&gt; click_me click me for detail 原型：123456789/*** 该函数用于建立与指定socket的连接* @param sockfd 一个未连接的socket的描述符* @param sockaddr 指向要连接的套接字的sockaddr结构体的指针* @param addrlen 上述sockaddr结构体的长度** @return 成功则返回0, 失败返回-1, 错误原因存于errno 中**/int connect(int sockfd, const struct sockaddr * servaddr, int addrlen); 为了书写简便，原书作者对上述函数的第二个参数做了一层宏定义：1#define SA struct sockaddr 所以在上面的daytimecli.c 中调用connect的时候，用SA简化了书写，实际上 SA = struct sockaddr1connect(sockfd, (SA *)&amp;servaddr, sizeof(servaddr) read() 百度百科–&gt; click_me 原型：123456789101112/*** 从fd所指向的文件中传送count个字节到buf中** @param fd 关联一个文件的描述符（可以是socket fd）* @param buf 指向一个数组的指针，用做缓存，存取从fd中读出的数据* @param count 读取的大小** @return 返回值为实际读取到的字节数* 如果返回0，表示已到达文件尾或无可读取的数据。* 错误返回-1,并将根据不同的错误原因适当的设置错误码**/ssize_t read(int fd, void *buf, size_t count); 如果read函数中传入的文件描述符为sockfd，则表示从网络中读取count字节的数据并存到buf中。 read函数是一个阻塞函数，如果没有读够count个字节，会一直在那边死等，下面两种情况下read函数和的阻塞状态会解除 如果一个信号的到来，会导致主线程因为去执行信号的回调函数，而解除阻塞函数的阻塞状态。并将errno置成EINTR。表示因为信号中断而退出。（不过现在的系统好像做了优化处理，即便定义了某些信号的处理函数，当该信号到来时，该回调会执行，但同时却不会引发中断错误） 还有就是收到EOF（文件结束指针）。如果是tcp socket，则当对方关闭了写一端的时候，会向本机发送一个FIN，标识对方已经发完数据了。此时read的阻塞状态便会解除。同样的，如果对方给调用close函数关闭了socket，read函数也会解除阻塞（关闭socket相当于写端和读端都关闭了） 对比 write fputs() 百度百科–&gt; click_me 原型：123456789/*** 向指定的文件中写入一个字符串** @param ptr 指向待写入的字符串* @param stream 指向目标文件的一个文件指针（文件指针由fopen获得）** @return 函数返回值为一般非负整数，如果返回EOF(常值，为-1)，则标识读到文件尾**/int fputs(const char* ptr, FILE* stream) IPV6版本 上面的程序是支持IPV，点击此处有IPV6版本的代码 一些关于教材的扩展介绍 包裹函数（wrapper function） linux系统内核的c语言函数名都是小写的，如果之后的代码中出现了大写开头的函数，则表示是原书作者对内核函数做了一层包装，加了一些错误判断等，使用起来更加方便，这些即作者所说的包裹函数（wrapper function） 举个栗子：123456int Socket(int family, int type, int protocol)&#123; int n; if( (n = socket(family, type, protocol)) &lt; 0 ) err_sys("socket error"); return(n);&#125; 上面这个函数便是作者对内核的socket函数做了一层封装，功能和socket函数时候一样的，只不过在出错的时候，这个函数已经帮你将错误打印出来了，如果不需要什么其它特殊处理的话。在使用Socket函数的时候变可以不需要错误处理了 下面展示会了没有使用包裹函数和使用了包裹函数的区别123456//不使用包裹函数if( (sockfd == socket(AF_INET, SOCK_STREAM, 0) ) &lt; 0) err_sys("socket error");//使用包裹函数Socket(AF_INET, SOCK_STREAM, 0); 原书作者定义的包裹函数大致符合下列规则 名字和被包裹的函数一致，只是首字母大写 函数的参数数量和意义和被包裹的函数一致 函数的行为与被包裹的函数保持一致 Unix errno 值 error 为一个全局变量 当Unix中的函数执行过程中有错误发生，则errno就被置为一个指明该错误类型的正值，而函数本身通常返回-1 A Simple Daytime Server Steven源码地址 笔者加注释源码地址 功能： 实现在13号端口上监听来自任意IP的请求，并向客户端输出时间信息 没做并发处理，一次只能向一个客户端提供服务 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;unp.h&gt;#include &lt;time.h&gt;int main(int argc, int argv)&#123; int listenfd, connfd; struct sockaddr_in servaddr; char buff[MAXLINE]; time_t ticks; //调用包裹函数，创建一个socket listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(13); //指定socket的地址为INADDR_ANY，标识监听来自所有地址的请求 servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //将socket绑定到指定的端口，只在指定的端口监听来自客户端的请求 Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr)); //调用Lisen可将socket转换成一个监听套接字，监听套接字可用于监听其他客户端的请求 Listen(listenfd, LISTENQ); for( ; ; )&#123; //accpet函数是一个阻塞函数，死等一个连接请求。 //当监听到一个请求，就返回一个已连接描述符（该描述符用于与新连接的那个客户端通信） connfd = Accept(listenfd, (SA *) NULL, NULL); //获取当前系统的时间 ticks = time(NULL); //将当前时间输出到buff数组中 snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&amp;ticks)); //将buff中的数据发给客户端 Write(connfd, buff, strlen(buff)); //关闭socket连接 Close(connfd); &#125;&#125; bind() 百度百科–&gt; click_me click me for detail 原型：1234567891011/***** sockfd： 标识一未捆绑套接口的描述字。* my_addr： 赋予套接口的地址。sockaddr结构定义如下：* struct sockaddr&#123;* u_short sa_family;* char sa_data[14];* &#125;;* addrlen： name名字的长度。* 返回值： 成功返回0，失败返回-1.****/int bind( int sockfd , const struct sockaddr * my_addr, socklen_t addrlen); bind函数把一个本地协议地址赋予一个套接字，通常在connect或listen函数调用前使用 listen() 百度百科–&gt; click_me click me for detail 原型123456/*** 将一个未连接的套接字（主动套接字）转换成监听套接字（被动套接字），这样即可以用来监听来自客户端的请求了* @param sockfd 一个未连接的套接字描述符* @param backlog 等待连接队列的最大长度**/int listen( int sockfd, int backlog); 函数的第二个参数指定的是系统内核允许在这个监听描述符上排队的最大客户连接数（内核为listen维护两个队列，第二个参数指定的至一般认为是已连接队列的上限） 不是允许的最大并发数 在监听描述符上排队的客户 ==&gt; 客户的请求被listen到了，但是还没有被accept处理，那么这个客户的请求便在该监听描述符上排队，等待被accpet 通常情况下，accpet以后就调用新线程或新进程处理了，所以很快就可以再accept，所以一般在监听描述符上排队的客户数不会很多 accept() 百度百科–&gt; click_me click me for detail 原型：12345678910/*** 在一个套接字的监听队列中取一个连接，如果没有，则死等** @param sockfd 监听描述符（在调用listen之后监听来自客户端的连接）* @param addr (可选)用来保存新连接的源端地址* @param addrlen (可选)用来保存新连接的源端地址结构的长度** @return 如果连接成功，则返回一个已连接的套接字描述符（用于和客户端通信）**/SOCKET accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 上述函数的第二、三个参数为值-结果（value-result）参数 即在函数调用的时候，可以通过这两个参数向函数内部传递内容 同时在函数调用结束的时候，可以通过这两个参数获取到返回信息 accept函数就将新连接的地址信息保存在了后两个参数中（如果不需要可以直接传NULL） accpet为每个连接到本服务器的客户返回一个全新的描述符（唯一标识一个客户） snprintf() 百度百科–&gt; click_me 原型：1234/*** 向str指向的区域格式化输出size个字节的数据**/int snprintf(char *str, size_t size, const char *format, ...) 用法和printf基本相同 不同的是，printf是向控制台打印，而snprintf是通过地址指针，向目标区域输出 write() 百度百科–&gt; click_me 原型：1234/*** 将buf中count个字节的数据输出到fd标识的文件中**/ssize_t write (int fd,const void * buf,size_t count); 对比read close() click me for detail 关闭与客户端的连接。该调用引发正常的TCP连接终止序列：每个方向上（读方向，写方向）发送一个FIN，每个FIN又各自的对端确认]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（十一）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88k%EF%BC%89%2F</url>
    <content type="text"><![CDATA[设计原则 （understanding） 面向接口编程 依赖倒置 组合优于继承 单一职责 开放——封闭 Liskov替换 面向接口编程(Program to An interface, Not An Implementation) 使用“接口继承”，而非“实现继承” 接口关注对象的概貌，将对象中“不变”的信息抽象出来，不涉及细节，因此是“稳定”的 Example: 面向接口的好处： Client只需关注如何进行业务活动（如：驾驶），而不必关心其使用对象的具体实现 一个对象可以很容易地被（实现了相同接口的）另一个对象所替换 对象间的连接不必硬绑定（hard wire）到一个具体类的对象上，因此增加了灵活性 松散耦合，增加了重用的可能性 依赖倒置（Dependency Inversion Principle） 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 依赖倒置原则使细节和具体实现都依赖于抽象，抽象的稳定性决定了系统的稳定性 Example： 组合优于继承 （Favor Composition Over Inheritance ） 继承：OO特点之一 组合：任务委托 二者：都是面向对象设计中用于重用的方法 开发早期，继承经常被过度使用 使用继承的问题： 组合优于继承－设计改进 优先使用组合可获得重用性与简单性更佳的设计 配合使用继承，扩充可用的组合类集，加大重用的范围&lt;% img /img/se_97.jpg %&gt; 何时使用继承？ 子类表达了“是一个父类的特殊类型”，而非“是一个由父类所扮演的角色” 子类的一个实例永远不需要转化为其它类的一个对象 子类是对其父类的职责进行扩展，而非重写或废除（LSP） 单一职责——Single responsibility Principle 所谓职责，可理解为功能，就是设计的类功能应该只有一个，而不是两个或更多 职责也可以理解为引起变化的原因：当一个类中有两个以上的变化方向，会产生过多的变化点 Example: 开放封闭原则——Open For Extension, Yet Closed For Modification (OCP) OCP认为应该试图设计出永远也不需要改变的模块 可以添加新代码来扩展系统的行为；不能对已有的代码进行修改 OCP模块标准 模块的行为可以被扩展，以需要满足新的需求 模块的源代码是不允许进行改动的 一个软件系统的所有模块不可能都满足OCP，但是应该努力最小化这些不满足OCP的模块数量 OCP法则是OO设计的真正核心 符合该法则便意味着最高等级的复用性和可维护性 一个OCP栗子： 改进 Liskov替换原则 使用指向基类（超类）的引用的函数，必须能够在不知道具体派生类（子类）对象类型的情况下使用它们 ==&gt; 在任何父类出现的地方，都可以用子类替换（包括逻辑上和语义上） LSP是根据对象的“多态”而得出的 但在实现子类时必须要谨慎对待，以确保不会无意中违背了LSP 一个违背Liskov原则的栗子 对于下面的代码：12345678910111213141516171819202122232425262728293031//Rectangle类声明如下public class Rectangle&#123; protected double width; protected double height; public Rectangle()&#123;&#125; public void setWidth(double w)&#123; this.width = w; &#125; public void setHeight(double h)&#123; this.height = h; &#125; public double area()&#123; return width * height &#125;&#125;//直接用Rectangle类, 输出200Rectangle rect = new Rectangle();rect.setWidth(10);rect.setHeight(20);System.out.println(rect.area());//将Rectangle换成其子类Square，输出为400Rectangle rect = new Square(0);rect.setWidth(10);rect.setHeight(20);System.out.println(rect.area()); LSP的保证 LSP表明了ISA关系是与对象行为有关的 一个子类型不得具有比基更多的限制，这是因为可能对于基类型的某些使用是合法的，但是会因为违背子类型的其中一个额外限制，从而违背了LSP 一个简单的做法是不要将基类中子类不需要的函数暴露给子类 设计模式（understanding） Abstract Factory（抽象工厂） PROTOTYPE（原型模式） Singleton（单例模式） Adapter（适配器模式） 抽象工厂（Abstract Factory） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 原型模式（Prototype） 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 缺点是每一个类都必须配备一个克隆方法 其实是将product和factory功能合二为一了 单例模式（Singleton） 保证一个类仅有一个实例，并提供一个访问它的全局访问点 解决的主要是性能问题，而非耦合（变化）的问题 适配器模式（Adapter） 把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作 适配类可以根据参数返还一个合适的实例给客户端 桥梁模式（Bridge） 将抽象部分与它的实现部分（行为）分离，使它们都可以独立地变化 解决2个方面的变化问题：抽象与实现（行为）。即一个类中多个方向的变化问题]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（十）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88j%EF%BC%89%2F</url>
    <content type="text"><![CDATA[要求OO设计步骤，结构优化准则，对照架构模式，设计原则和设计模式 面向对象的设计准则 模块化 抽象 信息隐藏 弱耦合 强内聚 可重用 启发规则 设计结果应该清晰易懂 提高软件可维护性和可重用性重要措施 用词一致 使用已有的协议（重载） 减少消息模式的数目 避免模糊的定义 一般—特殊结构的深度应适当 应该使类等级中包含的层次数适当 设计简单的类 尽量设计小而简单的类，便于开发管理 避免包含过多的属性 有明确的定义 尽量简化对象之间的合作关系 不要提供太多服务（保持适当内聚的基础上） 使用简单的协议 使用简单的服务 把设计变动减至最小（结构稳定） 架构模式（Architecture Patterns）An architectural pattern is a proven structural organization schema for software systems（架构模式是指用于软件系统中经实践证明的机构化的组织格式化） 层次、CS、MVC、Pipe-Filter、Master-slave 层次架构 eg: 网络协议（OSI/ISO 七层模型） 每层向上层提供服务 越低层越稳定 职责分离，每层可独立开发 提供给上层高的抽象接口不容易写 低层可能做一些高层用不到的功能 MVC架构 model: 核心功能和数据（是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据） view： 向用户展示信息（是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的） controller： 处理用户的输入（是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据） 用于交互式系统 控制流程 CS架构 Server组件向多个client提供服务 客户端通过向服务器请求得到服务 请求是在进程和机器边界上完成的 采用进程间通信机制 而层级架构则是横跨进程和机器边界 Server通常是长期运行的，拥有监听来自Client的请求 Examples： Remote DB access （远程数据库接入） Remote file systems（远程文件系统） Multi-tier information system（多层信息系统） Web applications（网页应用） 通常在单独的线程中处理请求 Server和Client的交互通常包含在一个session（会话）中 Stateless servers（无状态的服务） 会话状态由client保存（例如：cookie机制） 每个请求都带上client保存的会话状态信息 Stateful servers（有状态服务） 会话状态由Server端保存 所有的Client的请求都关联到其对应的client-id Master-slave（主从模式） 主从模式支持容错和并行计算 主组件将工作分配给若干个从组件，从组件各自计算，最后主组件从这些从组件返回的结果中计算最终的结果 Examples: Process control(进程控制) Embedded systems(嵌入式系统) Large-scale parallel computations（大规模并行计算） Fault tolerant systems(容错系统) ==&gt; 比如磁盘阵列（可以用其中一块或多块硬盘做奇偶校验，可以达到容错的效果） 执行流程： 分析： 一旦Master挂掉，整个系统也就挂了 从组件之间是独立的，不共享状态 从组件之间可以并行运行 对于硬实时系统（对延迟很敏感），主从组件之间的通信延迟可能是一个问题 要解决的问题必须是可分解的 应用领域： 容错 并行计算 精确计算 Pipe-Filter(管道过滤器模式) 该架构适用于处理数据流的系统 每一个处理都封装在一个过滤器组件当中 数据通过相邻过滤器之间的管道（pipe）进行传输 pipe主要负责处理缓存和同步 Examples： Compilers（编译器） Unix shell commands 分析： 很容易插入新的过滤器 过滤器可重用 过滤器可以被独立开发 潜在数据转换开销 输入可以来自不同的数据源，输出也可以输出到不同的地方 天然的并行处理 过滤器间不共享状态 不适用于交互式系统，适用于批处理系统 Java中的管道 InputStream in = new BufferedInputStream(new DataInputStream(System.in)) Broker（代理模式） Peer-to-peer（P2P模式和） Event-bus Blackboard]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（九）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88i%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述要求： 掌握OO分析的方法和步骤，业务，能够使用UML图进行分析建模（类图、用例图、状态图、顺序图等） 面向对象分析是是辈出问题域内的对象，并分析它们相互间的关系，最终建立起问题域的简洁、精确、可理解的正确模型 在用面向对象观点建立起的三种模型中，对象模型（类图）是 最基本、最重要、最核心的 面向对象分析的过程面向该对象分析，就是抽取和整理用户或需求并建立问题域精确模型的过程 用用例图捕获需求 基于用例图构件类图 3个子模型5个层次 3个子模型：对象模型，动态模型，功能模型 5个层次 主题层（通常对应包的划分） 类与对象层 结构层 属性层 服务层 大体流程 寻找类与对象 识别结构 识别主题 定义属性 建立动态模型 建立功能模型 定义服务 需求陈述 通常，需求陈述的内容包括：问题范围，功能需求，性能需求，应用环境及假设条件等。总之，需求陈述应该阐明“做什么”而不是“怎样做” 描述用户的需求而不是提出解决问题的方法 应该避免对设计策略施加过多的约束，也不要描述系统的内部结构，这样做将限制实现的灵活性 对系统性能及系统与外界环境交互协议的描述，是合适的需求 此外，对采用的软件工程标准、模块构造准则、将来可能做的扩充以及可维护性要求等方面的描述，也都是适当的需求。 建立对象模型 确定类与对象 找出和候选的类与对象 用自然语言书写的需求陈述为依据，把陈述中的名词作为类与对象的候选者 用形容词作为确定属性的线索 把动词作为服务(操作)的候选者 筛选出正确的类与对象 冗余、无关、笼统、属性、操作、实现.. 确定关联 初步确定关联 大多数关联可以通过直接提取需求陈述中的动词词组而得出 通过分析需求陈述，还能发现一些在陈述中隐含的关联 筛选 已删去的类之间的关联 与问题无关或应在实现阶段考虑的关联 瞬时关联 三元关联 派生关联 完善 正名 分解 补充 标明重数 划分主题 在开发大型、复杂系统的过程中，为了降低复杂程度，习惯于把系统再进一步划分成几个不同的主题，也就是在概念上把系统包含的内容分解成若干个范畴 确定属性 分析 属性的确定既与问题域有关，也和目标系统的任务有关 应该仅考虑与具体应用直接相关的属性，不要考虑那些超出所要解决的问题范围的属性 在分析过程中应该首先找出最重要的属性，以后再逐渐把其余属性增添进去 在分析阶段不要考虑那些纯粹用于实现的属性 选择 认真考察经初步分析而确定下来的那些属性，从中删掉不正确的或不必要的属性 误把对象当作属性 把链属性误作为属性 把限定误当成属性 误把内部状态当成了属性 过于细化 存在不一致的属性 识别继承关系 反复修改 建立动态模型 第一步，是编写典型交互行为的脚本 第二步，从脚本中提取出事件，确定除服每个事件的动作对象以及接受事件的目标对象（画出事件跟踪图） 第三步，排雷事件发生的次序，确定每个对象可能有的状态及状态之间的转换关系，并用状态图描绘它们 建立功能模型 画出基本的系统模型图 画出功能级数据流图 EG: 对象模型参考： 动态模型参考 脚本 事件跟踪图 功能模型参考]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（八）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88h%EF%BC%89%2F</url>
    <content type="text"><![CDATA[要求掌握UML图的绘制方法，需求规范概述Unified Modeling Language(UML) 统一建模语言 1977.11.17，OMG采纳 ==&gt; ISO标准 ==&gt; 事实的工业标准 元元模型（meta_metamodel）层 由UML中最基本的元素“事物（thing）”组成 元模型（metamodel）层 这一层的每个概念都是元元模型中“事物”概念的实例 模型（model）层 用户模型（user model）层 UML的表示法 视图（view） 通常包括多个图 图（diagram） 模型元素（model element）=&gt;可以在图中使用的概念 通用机制（general mechanism） 通过通用机制可以为UML中的图附加一些额外的信息 比如：构造型，标签值，笔记（写注释）等 UML中的图 用例图 （use-case diagram） 用例是对系统提供的功能（即系统的具体用法）的描述 用例图从用户的角度描述系统功能，并指出各个功能的操作者 用例图定义了系统的功能需求 用例图描述的是一个动态的交互场景，而不是一个静态的功能 静态图（static diagram） 静态图描述系统的静态结构，包括： 类图（class diagram） 对象图（object diagram） ==&gt; 是类图的实例，有生命周期 一般说来，对象图没有类图重要，它主要用来帮助对类图的理解，也可用在协作图中，表示一组对象之间的动态协作关系 行为图（behavior diagram） 这类图描述系统的动态行为和组成系统的对象间的交互关系，包括： 状态图(state diagram) ==&gt; 描述一个类，多个场景 活动图(activity diagram) ==&gt; 描述多个类，多个场景 交互图 （interaction diagram） 这类图描述对象间的交互关系，包括 顺序图（sequence diagram） 协作图（collaboration diagram） 描述一个场景中若干个类的交互（动态协作） 实现图（implementation diagram） 这类图提供关于系统实现方面的信息，包括： 构件图（component diagram） 配置图（deployment diagram）]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（七）]]></title>
    <url>%2F2017%2F12%2F24%2F2017-12-24-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88g%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面向对象方法学概述 概念 认为客观世界是由各种对象组成的，任何事物都是对象个，复杂的对象可以由比较简单的对象以某种方式组合而成。 把所有对象都划分成各种对象类（简称为类，class），每个独享都定义了一组数据和一组方法 按照子类（或称为派生类）与父类（或称为基类）的关系，把若干个对象类组成一个层次结构的系统（也称为类等级） 对象彼此之间仅能通过传递消息互相联系 OO = objets + classes + inheritance + communication with messages 优点 与人类习惯的思维方式一致 稳定性好 可重用性好 较易开发大型软件产品 可维护性好 面向对象建模用面向对象方法开发软件，通常需要建立三种模式的模，分别是描述系统数据结构的对象模型，描述系统控制结构的动态模型和描述系统功能的功能模型 对象模型（在UML部分详细介绍） 动态模型 功能模型 三种模型之间的关系在面向对象方法学中，对象模型是最基本最重要的，为其它两种模型奠定基础，依靠对象模型完成三种模型的集成 针对每个类建立的动态模型，描述了类实例的生命周期或运行周期 状态转换驱使行为发生，行为在数据流图中被映射成处理，与对象模型中的服务相对应 功能模型中的处理对应对象模型中类提供的服务 顶层数据流图中的处理对应复杂对象提供的服务；低层数据流图中的处理对应更基本的对象(基本对象是复杂对象的组成部分)的服务 有时一个处理对应多个服务，也有一个服务对应多个处理的时候 功能模型中的数据存储，以及数据的源点/终点(在功能模型中称为动作对象)，通常是对象模型中的对象。DataStore-ER entity-Object 功能模型中的数据流，往往是对象模型中的属性值，也可能是整个对象 功能模型中的处理可能产生动态模型中的事件 对象模型描述了功能模型中的动作对象、数据存储以及数据流的结构]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（六）]]></title>
    <url>%2F2017%2F12%2F24%2F2017-12-24-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88f%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通常把编码和测试统称为实现 所谓编码就是把软件设计翻译成计算机可以理解的形式——用某种程序设计语言书写的程序 编码是设计的自然结果，程序的质量主要取决于软件设计的质量 但所选用的程序设计语言的特点和编码风格也会对程序的可靠性、可读性、可测试性和可维护性产生深远的影响。 软件测试对软件可靠性的影响是重要的（软件生命周期中，差错不可避免） 尽可能早地发现并纠正差错 测试的目的就是在软件投入生产性运行之前，尽可能多地发现软件中的错误 软件测试在软件生命周期中横跨两个阶段 单元测试（一般模块的编写者和测试者是同一个人） 综合测试（通常由专门的测试人员承担这项工作） 统计资料表明，软件测试的工作量往往占软件开发总工作量的40%以上，对于关键应用系统的测试，可能相当于软件工程其他步骤总成本的3～5倍 测试目标是发现软件中的错误，但不是最终目的。调试是诊断并改正错误，这是最终目的。调试是测试阶段最困难的工作 对测试结果进行收集和评价，确定系统的可靠性 编码 (understanding) 选择程序设计语言 总的来说，高级语言明显优于汇编语言。除了对程度执行时间和使用的空间都有很严格限制的情况；需要产生任意的甚至非法的指令序列；体系结构特殊的微处理机，以致在这类机器上通常不能实现高级语言编译程序；或者大型系统中执行时间非常关键的(或直接依赖于硬件的)一小部分代码；其他程序应该一律用高级语言书写 编码风格 源程序代码的逻辑简明清晰、易读易懂是好程序的一个重要标准，应该遵循下述规则 程序内部的文档（注释） 数据说明 语句构造 输入输出 效率 软件测试基础 (master)软件工程其他阶段都是“建设性的”，而测试阶段的目的却是为了“破坏”已经建造好的软件系统————竭力证明程序中有错误，不能按照预定要求正确工作。 测试目标 测试是为发现程序中的错误而执行程序的过程 好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案 成功的测试是发现了至今为止尚未发现的错误的测试 测试准则 所有的测试都应该能追溯到用户需求（因需制宜） 应该在测试开始之前的相当长时间，就制定出测试计划 把Pareto原理应用于软件测试：测试发现的错误中的80%很可能是由程序中20%的模块造成的（2-8定理） 测试应该从“小规模”开始，并逐步进行“大规模”测试（由小到大） 穷举测试是不可能的 为了达到最佳的测试效果，应该由独立的第三方来从事测试工作（心理学角度上来讲，让编码人员找自己的错误是不现实的） 测试方法 黑盒测试 黑盒测试又称为功能测试 是在接口层面的测试，把程序看成一个黑盒子，不考虑内部结构和处理过程 适合于程序后期测试接口 白盒测试 白盒测试又称为结构测试 把程序看成装在一个透明的白盒子里，也就是完全了解程序的结构和处理过程 按照程序内部的逻辑测试程序，检验程序中的每条通路是否都能按预定要求正确工作。 适合于早期测试模块内部逻辑 测试步骤 单元测试，也称模块测试 集成测试 确认测试 系统测试 ps: α测试：在受控环境下测试（实验室环境） β测试：在非受控环境下测试（实际工作环境） 单元测试 单元测试和编码属于软件工程过程同一阶段（同属于编码和单元测试，因为单元测试通常是在编码的过程中进行的） 在编写出源程序代码并通过了编译程序的语法检查之后，应用人工测试和计算机测试这样两种类型的测试，完成单元测试工作 这两种类型的测试各有所长，互相补充 单元测试主要采用白盒测试技术，而且对多个模块的测试可以并行地进行 测试重点 模块接口 局部数据结构 重要的执行通路 出错处理通路 边界条件 代码审查 人工测试源程序可以由编写者本人非正式地进行，也可以由审查小组正式进行，后者称为代码审查，是一种非常有效的程序验证技术，对于典型的程序来说，可以查出30%～70%的逻辑设计错误和编码错误 审查小组组成： 组长，应该是一个很有能力的程序员，而且没有直接参与这项工程 程序的设计者 程序的编写者 程序的测试者 计算机测试 模块并不是一个独立的程序，必须为每个单元测试开发驱动软件（负责调用本模块）和(或)存根软件（负责模拟被本模块调用的子模块，比如对于一个用于数据处理的子模块，本模块需要的是其输出一个数据结构，那么就可以直接用一个构造的数据实例来替代这个子模块） 驱动程序就是一个“主程序”，接收测试数据，把这些数据传送给被测试的模块，并且输出有关结果 存根程序代替被测试的模块所调用的模块，也可以称为“虚拟子程序”。（桩模块） 使用被它代替的模块的接口，做最少量的数据操作，输出对入口的检验或操作结果，并且把控制归还给调用它的模块 集成测试集成测试是测试和组装软件的系统化技术，在把模块按照设计要求组装起来的同时进行测试，主要目标是发现与接口有关的问题 非渐增式测试方法 先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序 一次性集成测试 渐增式测试把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。这种每次增加一个模块的方法称为渐增式测试 自顶向下集成 首先测试M1（需要写M2、M3、S4对应的桩模块），然后将M1作为M2、M3、S4的驱动程序，集成并测试。以此类推 不用写驱动模块，但是需要写大量桩模块 优点： 不需要测试驱动程序 能够在测试阶段的早期实现并验证系统的主要功能 能在早期发现上层模块的接口错误 缺点： 需要存根程序 低层关键模块中的错误发现较晚 早期不能充分展开人力（不利于团队分工测试） 自底向上集成 步骤： 把低层模块组合成实现某特定软件子功能的簇 写一个驱动程序(用于测试的控制程序)，协调测试数据的输入和输出 对由模块组成的子功能簇进行测试 去掉驱动程序，沿软件结构自下向上移动，把子功能簇组合起来形成更大的子功能簇，重复2~4 优缺点与自顶向下集成相反 回归测试 不是一种测试方法，也不是一个测试阶段。重新执行已经做过的测试的某个子集，以保证上述这些改变没有带来非预期的副作用 回归测试（regression）与累进测试(progression) 回归测试：用之前版本的测试方案，测试好现在的程序 累进测试：用新的测试方案，测试同一版本的程序 确认测试 确认测试也称为验收测试，目标是验证软件的有效性 使用了确认(Validation)和验证(Verification)这样两个不同的术语 验证 就是要用数据证明我们是不是在正确的制造产品。注意这里强调的是过程的正确性 确认 就是要用数据证明我们是不是制造了正确的产品。注意这里强调的是结果的正确性 确认测试的范围 软件配置复查 Alpha和Beta测试 α测试：在受控环境下测试（实验室环境） β测试：在非受控环境下测试（实际工作环境） 白盒测试技术 (master) 逻辑覆盖是设计白盒测试方案的技术。设计测试方案是测试阶段的关键技术问题 测试方案包括具体的测试目的(例如，要测试的具体功能)，应该输入的测试数据和预期的输出结果 逻辑覆盖 语句覆盖 选择足够多的测试数据，使被测程序中每个语句至少执行一次 是很弱的逻辑覆盖标准 只关心判定表达式的值，不关心表达式内部具体每个条件取哪些值 举个栗子： 只需选取一组测试数据，覆盖路径ace即可 比如可以取 测试用例的格式：【输入的(A, B, X)，输出的(A, B, X)】 满足语句覆盖的测试用例：【(2, 0, 4), (2, 0, 3)】 判定覆盖 不仅每个语句必须至少执行一次 而且每个判定的每种可能的结果都应该至少执行一次，也就是每个判定的每个分支都至少执行一次 同样只关心判定表达式的值，不关心表达式内部具体每个条件取哪些值 举个栗子： 测试用例的格式：【输入的(A, B, X)，输出的(A, B, X)】 满足判定覆盖的测试用例： 【(2, 0, 4), (2, 0, 3)】覆盖ace 【(1, 1, 1), (1, 1, 1)】覆盖abd 条件覆盖 不仅每个语句至少执行一次，而且判定表达式中每个条件都取到各种可能的结果 条件覆盖不一定比判定覆盖强，甚至可能连语句覆盖都达不到 举个栗子： 本例中b处没有逻辑代码，如果有，则上面的第二种方案就达不到语句覆盖，但是能达到条件覆盖 判定/条件覆盖 判定覆盖不一定包含条件覆盖，条件覆盖也不一定包含判定覆盖，判定/条件覆盖能同时满足这两种覆盖标准 举个栗子： 条件组合覆盖 条件组合覆盖就是设计足够的测试用例，运行被测程序，使得每个判断的所有可能的条件取值组合至少执行一次 举个栗子： 所有可能的条件组合： 一个满足条件组合覆盖的测试方案 点覆盖 边覆盖 路径覆盖 控制结构测试 基本路径测试 (master) 根据过程设计结果画出相应的流图 计算流图的环形复杂度n 确定线性独立路径的基本集合（找到n条能覆盖整个流图的独立路径） 独立路径指至少引入程序一个新处理语句集合或一个新条件的路径，用流图术语描述，独立路径至少包含一条在定义该路径之前不曾用过的边 程序的环形复杂度决定了程序中独立路径的数量 在不考虑业务逻辑的情况下找到的路径有可能是无效的（多个判定条件之间可能有一定联系，导致某个独立路径上的判定条件无法同时满足） 设计可强制执行基本集合中每条路径测试用例 举个栗子： 环形复杂度：6 路径： 路径1：1-2-10-11-13 路径2：1-2-10-12-13 路径3：1-2-3-10-11-13 路径4：1-2-3-4-5-8-9-2··· 路径5：1-2-3-4-5-6-8-9-2··· 路径6：1-2-3-4-5-6-7-8-9-2··· 路径4、5、6后面的省略号(…)表示，可以后接通过控制结构其余部分的任意路径(例如，10-11-13) 条件测试 (pass) 循环测试 (pass) 简单循环 串接循环 嵌套循环 黑盒测试技术 (master) 黑盒测试着重测试软件的功能需求，让软件工程师设计出能充分检查程序所有功能需求的输入条件集 黑盒测试和白盒测试两者互补(A代表需求，B代表实现) 白盒测试至多能覆盖实现 黑盒测试至多能覆盖需求 只有两者结合使用才能做到全方位的测试 白盒测试在测试过程的早期阶段进行，而黑盒测试主要用于测试过程的后期 黑盒测试力图发现下述类型的错误：① 功能不正确或遗漏了功能；② 界面错误；③ 数据结构错误或外部数据库访问错误；④ 性能错误；⑤ 初始化和终止错误 等价划分 目的 需要研究程序的功能说明，确定输入数据的有效等价类和无效等价类 经验 如果规定了输入值的范围，则可划分出一个有效的等价类(输入值在此范围内)，两个无效的等价类(输入值小于最小值或大于最大值) 如果规定了输入数据的个数，则类似地也可以划分出一个有效的等价类和两个无效的等价类 如果规定了输入数据的一组值，而且程序对不同输入值做不同处理，则每个允许的输入值是一个有效的等价类，此外还有一个无效的等价类(任一个不允许的输入值) 如果规定了输入数据必须遵循的规则，则可以划分出一个有效的等价类(符合规则)和若干个无效的等价类(从各种不同角度违反规则) 如果规定了输入数据为整型，则可以划分出正整数、零和负整数等三个有效类 如果程序的处理对象是表格，则应该使用空表，以及含一项或多项的表 边界值分析 处理边界情况时程序最容易发生错误 边界值处测试数据的选取 刚好等于 刚刚小于 刚刚大于 栗子： 错误推测 错误推测法在很大程度上靠直觉和经验进行 基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案 调试 调试(也称为纠错)作为成功的测试的后果而出现，即调试是在测试发现错误之后排除错误的过程 调试不是测试，但是它总是发生在测试之后 途径： 蛮干法：打印内存数据、关键输出、断点 回溯法：由症状回推可能的原因 原因排除法：对分查找、归纳、演绎等方法 软件可靠性]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（五）]]></title>
    <url>%2F2017%2F12%2F23%2F2017-12-23-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88e%EF%BC%89%2F</url>
    <content type="text"><![CDATA[详细设计阶段的任务还不是具体地编写程序，而是要设计出程序的“蓝图”，以后程序员将根据这个“蓝图”写出实际的程序代码。 结构程序设计 (master)如果一个程序的代码块仅仅通过顺序、选择和循环这三种控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。 三种基本控制结构 关于GOTO语句 上面关于结构化程序经典定义过于狭隘，结构程序设计本质上并不是无GO TO语句的编程方法，而是一种使程序代码容易阅读、容易理解的编程方法 大多数情况下，无GO TO的代码确实是容易阅读、容易理解，但在某些情况下，为达到容易阅读和容易理解的目的，需要使用GO TO语句 结构程序设计是尽可能少用GO TO语句的程序设计方法。最好仅在检测出错误时才使用GO TO语句，而且应该总是使用前向GO TO语句 但是一般题目中问一段代码为什么不是结构化程序，很大可能是使用了GOTO语句 经典的结构程序设计 如果只允许使用顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这三种基本控制结构，则称为经典的结构程序设计 扩展的结构程序设计 如果除了上述三种基本控制结构之外，还允许使用DO-CASE型多分支结构和DO-UNTIL型循环结构，则称为扩展的结构程序设计 修正的结构程序设计 如果再加上允许使用LEAVE(或BREAK)结构，则称为修正的结构程序设计。 人机界面设计 (cut)人机界面设计是接口设计的一个组成部分 设计问题 系统响应时间 用户帮助设施 出错信息处理 命令交互 设计过程 用户界面设计是一个迭代的过程，也就是说，通常先创建设计模型，再用原型实现这个设计模型，并由用户试用和评估，然后根据用户的意见进行修改 界面设计指南 一般交互指南 保持一致性 提供有意义的反馈 在执行有较大破坏性动作之前要求用户确认 允许取消大多数操作 减少在两次操作之间必须记忆的信息量 提高对话、移动和思考的效率 允许犯错误 按功能对动作分类，并据此设计屏幕布局 提供对用户工作内容敏感的帮助设施 用简单动词或名词短语作为命令名 信息显示指南 只显示与当前工作内容有关的信息。 用户在获得有关系统的特定功能的信息时，不必看到与之无关的数据、菜单和图形。 不要用数据淹没用户 使用一致的标记、标准的缩写和可预知的颜色 允许用户保持可视化的语境 产生有意义的出错信息 使用大小写、缩进和文本分组以帮助理解 使用窗口分隔不同类型的信息 使用“模拟”显示方式表示信息 高效率地使用显示屏 数据输入指南 尽量减少用户的输入动作 保持信息显示和数据输入之间的一致性 允许用户自定义输入 交互应该是灵活的 使在当前动作语境中不适用的命令不起作用 让用户控制交互流 对所有输入动作都提供帮助 消除冗余的输入 过程设计的工具 (master)图形、表格、语言 程序流程图 程序流程图又称为程序框图，是历史最悠久使用最广泛的描述过程设计的方法，然而也是用得最混乱的一种方法 缺点： 绘制随意，容易只考虑流程控制而不考虑全局结构，而破坏结构化程序设计 不容易表示数据结构 程序流程图中使用的符号 盒图（N-S图） 盒图没有箭头，因此不允许随意转移控制。坚持使用盒图作为详细设计的工具，可使程序员逐步养成用结构化的方式思考问题和解决问题的习惯 能保证设计出的程序一定是结构化的 但是绘制的时候受空间限制，难以扩充 盒图的基本符号 PAD图（Problem Analysis Diagram） 它用二维树形结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易 与盒图相比，不受空间限制，易于扩充 可保证设计出来的程序一定是结构化的 PAD图的基本符号 (a) 顺序(先执行P1后执行P2)； (b) 选择(IF C THEN P1 ELSE P2)； (c) CASE型多分支；(d) WHILE型循环(WHILE C DO P)； (e) UNTIL型循环(REPEAT P UNTIL C)； (f) 语句标号； (g) 定义 可使用PAD提供的定义功能来逐步求精 判定表 当算法中包含多重嵌套的条件选择时，判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系 判定树 比判定表直观，包含判定的先后顺序 父节点：判定条件 叶子节点：一个动作 过程设计语言（PDL: Process Design Language） 伪代码 程序复杂度的定量度量 (master)常用的方法有McCabe方法（采用流图）、Halstead方法，下面仅介绍第一种 McCabe 方法 流图 为了突出表示程序的控制流，可以使用流图(也称为程序图) 流图仅描绘程序的控制流程，完全不表现对数据的具体操作以及分支或循环的具体条件。 流图用圆表示节点，一个圆代表一条或多条语句（如果多条语句在一个顺序结构上，可以省略中间，只画两边的节点） 流图中的箭头线称为边，和程序流程图中的箭头线类似，代表控制流 由边和节点围成的面积称为区域，区域数应该包括图外部未被围起来的区域。 基本结构： 把程序流程图映射成流图(a)程序流程图；(b)流图 PDL翻译成流图 123456789101112131415procedure: sort do while records remain read record; if record field1 = 0 then process record; store in buffer; incremert counter; elseif record filed2 = 0 then reset counter; else process record; store in file; endif endif enddo end 由包含复合条件的PDL映射成的流图 流图环形复杂度的计算 流图中的区域数等于环形复杂度 流图G的环形复杂度V(G)＝E-N+2，其中E是流图中边的条数，N是流图中节点数 流图G的环形复杂度V(G)＝P+1，其中P是流图中判定节点的数目 举个栗子： 上图中共有四个区域，故环形复杂度为4 上图中共有11条边，9个点，所以环形复杂度位：11 - 9 + 2 = 4 上图中共有三个判定节点，分别为”1”, “2,3”, “6”，所以环形复杂度为：3 + 1 = 4 PS: 在计算区域数的时候别忘了包括最外围的区域 在计算判定节点的时候，不仅包括条件分支的判断，循环判定的节点也算]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（四）]]></title>
    <url>%2F2017%2F12%2F23%2F2017-12-23-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88d%EF%BC%89%2F</url>
    <content type="text"><![CDATA[结构化设计（Structured Design, SD） (整体understanding)结构化设计工作通常划分为概要设计和详细设计两个阶段 概要设计又称总体设计或初步设计 概要设计的主要任务：分析软件规格说明（来自需求分析的输出）,对软件进行功能分解，划分为模块，设计出模块结构 详细设计阶段：详细设计每个模块，确定每个模块功能的算法和数据结构 设计过程总体设计过程通常由两个主要阶段组成：系统设计阶段，确定系统的具体实现方案;结构设计阶段，确定软件结构。 设想供选择的方案 选择合理的方案 推荐最佳方案 功能分解 设计软件结构 设计数据库 制定测试计划 书写文档 复查和复审 设计原理 模块化 概念 模块是由边界元素限定的相邻的程序元素的序列，而且有一个总体标识符来代表。 面向对象范型中的对象是模块，对象内的方法也是模块。模块是构成程序的基本构件。 每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求 模块化和软件成本 每一个程序都相应地有一个最适当的模块书目M，使系统的开发成本最小 优点 结构清晰 容易阅读和理解 容易测试和调试 有助于提高软件的可靠性 可修改性 便于组织和管理 抽象 把事物、状态或过程之间存在的共性集中概括起来，暂时忽略他们之间的差异，这就是抽象 逐步求精 为了能集中精力解决主要问题而尽量推迟对问题细节的考虑 求精实际上就是细化的过程 抽象与求精是一对互补的概念 抽象使得设计者能够说明过程和数据，同时却忽略低层细节。 抽象是一种通过忽略多余的细节同时强调有关的细节，而实现逐步求精的方法。 求精则帮助设计者在设计过程中揭示出低层细节。 这两个概念都有助于设计者在设计演化过程中创造出完整的设计模型。 信息隐藏和局部化 一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的 模块独立 （master） “模块独立”概念是模块化、抽象、逐步求精和信息隐藏等概念的直接结果，也是完成有效的模块设计的基本标准。可以由两个定性标准来度量，这两个标准分别称为内聚和耦合。 耦合：耦合衡量不同模块彼此间互相依赖(连接)紧密程度 内聚：内聚衡量一个模块内部各个元素彼此结合的紧密程度 对于模块设计，我们一般追求：模块内部高内聚，模块之间低耦合 耦合 非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，非直接耦合的模块独立性最强，模块间的耦合程度最低 数据耦合：通过简单的数据参数传递产生的耦合，是一种低耦合 标记（特征）耦合： 传递参数表记录信息，如文件、数组、指针等。 当把整个数据结构当做参数传入模块，但是模块实际上只需要其中的一部分元素 控制耦合： 传递的信息中有控制信息，有可能是一个简单变量，但可能改变程序流程。 它是中等程度的耦合，增加了系统的复杂程度，适当分解可以用数据耦合替代它。 外部耦合：一组模块都访问同一全局简单变量 公共环境耦合：一组模块访问同一个公共数据环境 内容耦合： 一组模块使用另一模块内部数据；模块通过非正常渠道进入另一模块执行 这是最高程度的耦合 使用原则：尽量使用数据耦合，少用控制耦合，限制公共环境耦合的范围，完全不用内容耦合。 内聚 理想内聚的模块只做一件事情，设计模块时，通常追求模块内部是高内聚的内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合 低内聚： 偶然内聚 逻辑内聚 时间内聚 中内聚 过程内聚 通信内聚 高内聚 顺序内聚（信息内聚） 功能内聚 启发规则长期实践经验所得，有助于实现有效的模块化 改进软件结构提高模块独立性 模块规模应该适中 深度、宽度、扇出和扇入都应适当 深度：树高 宽度：某层最大模块数 扇出：直接控制的模块数 扇入：有多少个上机的模块直接指向它 模块的作用域应该在控制域之内 如图所示，A的控制域就包括BCDEF 如果G也在A的作用域之内，则就不是一个合理的设计 应该把G下放一层，放在A的控制域之内 力争降低模块接口的复杂程度 设计单入口单出口的模块 模块功能应该可以预测 相同输入，得到可预测的想通过输出 描绘软件结构的图形工具 （master）层次图、HIPO图和结构图 层次图 层次图也称H图 在层次图中一个矩形框代表一个模块，框间的连线表示调用关系(位于上方的矩形框所代表的模块调用位于下方的矩形框所代表的模块)。 HIPO图 HIPO图是美国IBM公司发明的“层次图加输入/处理/输出图”的英文缩写。 为了使HIPO图具有可追踪性，在H图(即层次图)里除了顶层的方框之外，每个方框都加了编号。 然后每个方框对应用一张IPO图来描述，IPO图中应该明显的标出其在上述改进的H图中的编号 结构图（了解） 结构图和层次图类似，也是描绘软件结构的图形工具 结构图中带注释的箭头表示模块调用过程中来回传递的信息 尾部是空心圆表示传递的是数据，实心圆表示传递的是控制信息 其它符号 判定为真时调用A，为假时调用B 模块M循环调用模块A，B，C 面向数据流的设计方法 （understanding）面向数据流的设计方法的目标是给出设计软件结构的一个系统化的途径。它定义了一些不同的“映射”，利用这些映射可以把数据流图变换成软件结构 概念 变换流 信息通常以“外部世界”的形式进入软件系统，经过处理以后再以“外部世界”的形式离开系统 事物流 接收输入数据（输入数据又称为事物） 分析每个事物，以确定它的类型 根据事务类型选取一条活动的通路 设计过程 变换分析 复查基本系统模型 复查并精化数据流图 确定数据流图具有变换特性还是事务特性 确定输入流和输出流的边界，从而孤立出变换中心 完成“第一级分解” … 完成“第二级分解” 未精化的输入结构 未精化的变换结构 未精化的输出结构 使用设计度量和启发规则对第一次分割得到的软件结构进一步精化 事务分析 虽然在任何情况下都可以使用变换分析方法设计软件结构，但是在数据流具有明显的事务特点时，也就是有一个明显的“发射中心”(事务中心)时，还是以采用事务分析方法为宜。 事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同。 对于一个大系统，常常把变换分析和事务分析应用到同一个数据流图的不同部分，由此得到的子结构形成“构件”，可以利用它们构造完整的软件结构 事务分析的映射方法： 设计优化（refactoring） P112]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（三）]]></title>
    <url>%2F2017%2F12%2F22%2F2017-12-22-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88c%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述需求分析是发现、求精、建模、规格说明和复审的过程。 准则 必须理解和表示问题的信息域，根据这条准则应该建立数据模型。 必须定义软件应完成的功能，这条准则要求建立功能模型。 必须表示作为外部事件结果的软件行为，这条准则要求建立行为模型。 必须对描述信息、功能和行为的模型进行分解，用层次的方式展示细节。 分析过程应该从要素信息移向实现细节 业务 → 技术 逻辑 → 物理 要素 → 细节 需求分析的任务 确定对系统的综合要求 数据要求 功能需求 性能需求 可靠性和可用性需求 出错处理需求 接口需求 约束 逆向需求（不应该做的） 将来可能提出的要求 分析系统的数据要求 任何软件系统本质上都是信息处理系统 建立数据模型（E-R图） 数据字典 层次方框图 Warnier图 导出系统给的逻辑模型 数据流图、E-R图、状态转换图、数据字典、算法描述 修正系统的开发计划 与用户沟通获取需求的方法 访谈 面向数据流自顶向下求精 简易的应用规格说明技术 快速建立软件模型 快速原型应该具备的第一个特性是“快速”。 快速原型应该具备的第二个特性是“容易修改”。 分析建模与规格说明实体——联系图（E-R图） (master)数据模型包含三种相互关联的信息：数据对象、描述数据对象属性及数据对象彼此间相互连接的关系 ER图中包含实体(即数据对象)、关系和属性三种基本成分。 数据规范化一、二、三范式 状态转换图 (master)状态转换图(状态图)通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为一个状态图只能描述一个对象的行为变化，包括一系列状态、事件以及状态之间的转移 状态和事件 状态：状态是任何可以被观察到的系统行为模式（当前对象属性值的集合） 事件：事件在某个特定个时刻发生的事情，引起系统从一个状态转换到另一个状态 符号 初态：实心圆 终态：一对同心圆 中间状态：用圆角矩形表示，可分为三部分：状态名、状态变量、活动表（其中状态名是必选的，其余两个是可选的） 活动表的语法格式：事件名（参数表）/ 动作表达式 entry (在进入该状态时执行) exit （退出该状态时执行） do （在该状态下一直执行） 状态转换：两个状态之间带箭头的连线，箭头指明了转换方向 连线上通常标出导致状态转化的触发事件 触发事件表达式的语法：事件说明[守卫条件]/动作表达式 事件说明：事件名（参数表） 守卫条件：一个布尔表达式 动作表达式：是一个过程表达式，当状态转换开始后时执行该表达式 栗子： 状态转换 简单转移 自转移 （自己转移到自己，需要事件触发） 自动转移 （通常是本状态需要做的一个活动完成时转换到下一个状态） 复合转移 组合状态————子状态 一个状态下可以嵌套许多子状态 顺序子状态 =&gt; 子状态是串行连续变化的 并发子状态 =&gt; 存在并发存在互不影响的子状态 补充 同步 分劈（Fork） 接合（Join） 伪状态 符号用圈里面一个*表示 用来表示并发状态的同步 在子状态图之间使用（放在分隔子状态的虚线上） 历史状态 符号用圈里面一个H表示 记录在离开某个状态时，其处于哪个子状态中 对于同一层级的状态来说，初态只有一个，终态可以有多个 其它图形工具 层次方框图 层次方框图用树形结构的一些列多层次的矩形框描绘数据的层次结构 Warnier图 IPO图 IPO图是输入、处理、输出图的简称 左边框中列出有关的输入 中间框中列出主要的处理 右边框中列出产生的输出 处理的顺序暗示了执行的顺序 箭头指出数据通信的情况 验证软件的需求（了解）验证软件的一致性、完整性、现实性和有效性]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（二）]]></title>
    <url>%2F2017%2F12%2F22%2F2017-12-22-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88b%EF%BC%89%2F</url>
    <content type="text"><![CDATA[可行性研究的任务不是解决问题，而是确定问题是否值得去解决。 分析可能的解法 判定系统规模和目标是否能够实现 效益是否可观 较高层次的系统分析和设计过程 技术可行性：开发此系统是可行的，是有好处的 经济可行性：根据系统目标衡量所需技术是否具备 操作可行性：系统是否易于使用并能够创造价值 法律可行性：是否存在侵犯、妨碍和责任等问题 可行性研究过程（understanding）了解就好 复查系统规模和目标 改正含糊或不确切的叙述 清晰地描述限制和约束 确保分析员解决正确的问题 研究目前正在使用的系统 完成现有系统的基本功能分析 解决现有系统的问题 绘制高层系统数据流图 掌握与其他系统的接口 导出新系统的高层逻辑模型 现有物理系统 → 现有系统的逻辑模型 → 目标系统逻辑模型 → 新的目标系统 高层数据流图 初步的数据字典 进一步定义问题 以数据流图和数据字典为基础 复查问题定义、工程规模和目标 分析员和用户 重复1~4步，直至提出的逻辑模型完全符合系统目标 导出和评价供选择的解法 从技术角度出发，考虑解决问题的不同方案 技术可行性，排除不现实的系统 操作可行性，排除用户不能接受的方案 经济可行性，排除利润低的方案 制定进度表 (估算生命周期每个阶段的工作量) 推荐行动方针（是否做？） 分析员：如果值得开发，则选择最好的解法 用户：成本/效益分析 草拟开发计划 工程进度表 各类开发人员、各种资源需求情况 生命周期每个阶段的成本 下一个阶段详细进度表和成本估计 书写文档提交审查 用户、客户组织负责人、评审组审查 系统流程图 （understanding）系统流程图概括描绘物理系统的传统工具用图形符号，以黑盒子形式描述组成系统的每个部件程序、文档、数据库、人工过程 符号： 栗子： 数据流图 (master)数据流图(DFD) 描绘信息流和数据从输入移动到输出的过程中所经受的变换。 数据流图的四种基本符号： 加工中常见关系的符号表示： 注意： 信息的流动 信息流不能为动词 实体到实体的信息流动 处理要有输入输出 处理名不能为名词 确保层间的一致性（确保输入输出流的量是一致的） 命名: 数据流的名字应代表整个数据流(数据存储、处理)的内容，而不是仅仅某些成分。 不要使用空洞的、缺乏具体含义的名字(如“数据”、“信息”、“输入”之类)。 处理名字最好是一个具体的及物动词。 示例：出入库管理系统 0级数据流图 1级数据流图 2级数据流图 数据字典 (master) 数据字典是关于数据的信息的集合，即对设计图中包含的元素的定义。 数据字典的用途是供人查阅不了解的条目的解释，提供分析设计过程中关于数据的描述。 只有设计图和对应的元素的精确定义放在一起，才能构成系统完整的规格说明。 定义数据的方法 = : 意思是等价于(或定义为); + : 意思是和(即，连接两个分量); [] : 意思是或(即，从方括弧内列出的若干个分量中选择一个)，用“｜”号分开供选择的分量; {} : 意思是重复(即，重复花括弧内的分量); () : 意思是可选(即，圆括弧里的分量可有可无); 使用上限和下限进一步注释表示重复的花括弧。 左边用上角标和下角标分别表明重复的上限和下限 左侧标明重复的下限，在闭括弧的右侧标明上限 例如： 举个栗子： 北京某高校可用的电话号码有以下几类:校内电话号码由4 位数字组成，第1位数字不是0;校外电话又分为本市电话和外地电话两类,拨校外电话需先拨0,若是本市电话则再接着拨8位数字(第1位不是0),若是外地电话则拨3位区码再拨8位电话号码(第1位不是0)。请用上述提到的定义数据的方法，定义上述的电话号码。1234567891011电话号码 = [ 校内电话号码 | 校外电话号码 ]校内电话号码 = 非零数字 + 3位数字校外电话号码 = [ 本市电话号码 | 外地电话号码]本市电话号码 = 数字零 + 8位数字外地电话号码 = 数字零 + 3位数字 + 8位数字非零数字 = [1|2|3|4|5|6|7|8|9]3位数字 = 3&#123;数字&#125;3数字零 = 08位数字 = 非零数字 + 7位数字7位数字 = 7&#123;数字&#125;7数字 = [0|1|2|3|4|5|6|7|8|9] 数字字典的实现 CASE工具 人工卡片 成本效益分析（了解）成本/效益分析是客户从经济角度判断是否继续投资项目的主要依据。 成本估计 代码行技术 任务分解技术 效益分析 货币的时间价值 投资回报期 纯收入 投资回报率（最重要的参考数据）]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（一）]]></title>
    <url>%2F2017%2F12%2F22%2F2017-12-22-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88a%EF%BC%89%2F</url>
    <content type="text"><![CDATA[软件危机（understanding）软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重的问题 软件危机的表现 对开发成本和进度的估计往往很不准确 用户对“已完成的”软件系统不满意的现象时常发生 软件质量差 软件通常难以维护 软件没有适当的文档资料 软件成本在计算机系统的总成本中所占的比例逐年上升（软件成本日益增长） 软件开发速度跟不上计算机发展速度 产生软件危机的原因 技术原因 软件规模越来越大 软件复杂度越来越高 管理原因 软件开发缺乏正确的理论指导，过分依赖个人技巧和创造性 对用户需求没有完整准确的认识，就匆忙着手编写程序 引入统一变动付出代价随时间变化的趋势 上图展示的就是软件开发过程中，需求变化出现在开发过程的后期将会带来巨大的修改代价 所以应该在软件开发的早期，甚至是定义的时候就尽量的接近用户的真是需求 但通常，用户的牙膏不会一下子挤完（甚至一开始，大多数用户对自己的需求都不是很明确） 如何克服软件危机？ ==&gt; 软件工程 消除软件危机的途径 对计算机软件的正确认识 1983年IEEE对软件的定义：计算机程序、方法、规则、相关的文档资料以及在计算机上运行程序时所必须的数据 软件 ≠ 程序 软件工程三要素 推广使用开发软件成功的技术和方法，并且研究探索更好有效的技术和方法 开发和使用更好的软件工具 需要组织管理措施（过程） 总之，为了解决软件危机，既要有技术措施（方法和工具），有要有必要的组织管理措施。 无章法（个人英雄主义）=&gt; 工程项目管理模式（团队合作开发） 软件工程(understanding)1968第一届NATO会议：软件工程称就是为了经济的获得可靠的且在实际机器上有效运行的软件，而建立和使用的完善的工程原理1993年IEEE： 把系统的、规范的、可度量的途径应用于软件开发、运行和维护的过程，也就是把工程应用于软件 研究1中提到的途径 主要目标：高效开发高质量软件 软件工程的基本原理 用分阶段的生命周期计划严格管理 坚持进行阶段评审 错误发现的越晚，所需付出的代价也越大 对每个已完成的阶段进行评审，以便尽早发现错误 实行严格的产品控制 软件开发过程中不应该随意改动需求，对修改意见需要经过严格的评审后才能实施 采用现代化程序设计技术 结果应该能清楚的审查 开发小组的成员应该少而精 承认不断改进软件工程实践的必要性 软件工程方法学 通常把在软件生命周期全部过程各种使用的一整套技术方法的集合称为方法学（methodology）,也称为泛型（paradigm） 软件工程方法学3要素 方法：“如何做？” 工具：“用什么做？” 过程：“如何控制、协调、保证质量？” 传统方法学（静态分析） 传统方法学也称为生命周期方法学或结构化泛型，它采用结构化技术 这种方法学把软件生命周期的全过程依次划分为若干阶段，然后顺序的完成每个阶段的任务 特点： 生命周期模型 软件过程划分为若干个阶段 每个阶段有各自的任务 阶段之间有某种顺序性 局限： 当软件规模较大，或对软件的需求是模糊的或随时间变化的时候，使用结构化泛型开发软件往往不成功 此外，使用传统方法学开发出的软件通常维护起来都很困难 面向对象方法学（动态分析） 特点： 面向对象方法学的出发点和基本原则，是尽可能模拟人类的思维方式 用面向对象方法学开发软件的过程，是一个主动多次反复迭代演化的过程 概念和表示方法上的一致性，阶段间平滑（无缝）过度 特殊到一般的归纳思维过程；一般到特殊的演绎思维过程（继承的思想） 软件生命周期 (重点)概括的说，软件生命周期由软件定义、软件开发和运行维护（也称为软件维护）3个过程 问题定义 要解决什么问题？ 可行性研究 对上一阶段确定的问题是否有行之有效的解决方案？ 需求分析 目标系统必须做什么？用正式的文档记录对目标系统的需求（规格说明） 总体设计（概要设计） 概括的说，应该怎样实现目标系统？（从此阶段开始设计实现和技术的细节）又称为初步设计、逻辑设或、概要设计或高层设计 详细设计 把上阶段提出的解决方案具体化，回答“应该如何具体的实现这个系统？”又称为模块设计、物理设计或低层设计 编码和单元测试 具体coding。写出正确的容易理解、容易维护的程序模块，并测试 综合测试 集成测试、验收测试、系统测试 软件维护 通过各种必要的维护活动使系统持久地满足用户的需要 四类维护活动 改正性维护：诊断和改正真在使用过程中发现的软件错误 适应性维护：即修改软件以适应环境的变化 完善性维护：即根据用户的要求改进或扩充软件使它更完善 预防性维护：即修改软件为将过来的维护活动预先做准备 软件过程 （重点）软件过程是为了获得赶工质量软件所需要完成的一些列的任务的框架，它规定了完成各项任务的工作步骤 瀑布模型 阶段间具有顺序性和依赖性 推迟实现的观点 清楚的区分逻辑设计与物理设计，尽可能推迟程序的物理实现 质量保证的观点 每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务 每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误 瀑布模型的成功过在很大程度上由于它基本上是一种文档驱动的模型 优点：可强迫开发人员采用规范的方法（例如，结构化技术）； 严格地规定了每个阶段必须提交的文档；要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证 缺点：瀑布模型是由文档驱动的。由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要。 适用范围：应用需求明确的项目 快速原型模型 快速建立起可以运行的程序，其功能往往是最终产品功能的子集 通过将简单的模型给用户试用，以获取到用户更多更详细的需求（努力挤牙膏） 快速原型的本质是“快速” 原型的用途是获取用户的真正需求，一旦需求确定了，原型将被抛弃（原型通常没有严格的规范化，缺少文档，难以维护）。 优点：软件产品的开发基本上是线性顺序进行的 原型系统已经通过与用户交互而得到验证，据此产生的规格说明文档正确地描述了用户需求，，不会因为规格说明文档的错误而进行较大的返工。 开发人员通过建立原型系统已经学到了许多东西，在设计编码阶段发生错误的可能性比较小，自然减少了反馈。 缺点： 缺乏丰富而强有力的软件工具和开发环境。 缺乏有效的管理机制，还未建立起自己的开发标准。 对设计开发环境要求较高。 在多次重复改变原型的过程中，程序员会感到厌倦。 系统的易变性对测试有一定影响，难于做到彻底测试，更新文档较为困难。 适用范围：有结构的系统或者需求不明确的系统 增量模型 增量模型也称为渐增模型。把软件产品作为一系列增量构件来设计、编码、集成和测试 每个构件由多个相互作用的模块构成，并且能够完成特定的功能。 使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能。(滚雪球方式) 与瀑布模型相比： 瀑布模型：力求一次性给用户完整的系统。 增量模型：逐步增加系统功能。 增量模型： 一种风险更大的增量模型 优点： 能在较短时间内向用户提交可完成部分工作的产品 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。 缺点：待解决的问题必须允许有一个可递增的软件解决方案。如果需要的软件必须将所有的功能表现出来，那么递增的模型是不合适的。还有就是为了递增模型成功，必须找出整个系统的体系结构。 适用范围：不能在设定的期限内完成产品时，先推出核心产品 使用这种方法将冒构件无法集成到一起的风险，除非密切地监控整个开过程 螺旋模型 螺旋模型的基本思想是使用原型及其他方法尽量降低风险。 简化的螺旋模型 可以在一定程度上降低风险，但对有些风险也是无能为力的 需要专业的风险评估人员 完整的螺旋模型 优点： 对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标 减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险 在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别 缺点：仅适用于内部项目，大型项目受限，需要风险分析专家。 适用范围：主要适用于内部开发的大规模软件项目。 喷泉模型 迭代是OO开发过程的主要特性。 喷泉模型是典型的面向对象生命周期模型。 “喷泉” 体现了面向对象软件开发过程迭代和无缝的特性。 为避免喷泉模型的过分无序，把一个线性过程作为总目标。 迭代：逐步求精 阶段间没有明显的界限－面向对象的思想保证了各个阶段开发的一致性。 喷泉模型： Rational统一过程 敏捷过程与极限编程 敏捷软件开发宣言 个体和交互胜过过程和工具（Individuals and interactions over processs and tools） 可以工作的软件胜过面面俱到的文档（Working software over comprehensive socumentation） 客户合作胜过合同谈判（Customer collaboration over contract negotiation） 响应变化胜过遵循计划（Responding to change over following a plan） 敏捷软件开发的原理（The principles of agile methods） 客户参与（Customer involvement） 增量交付（Incremental delivery） People not process 拥抱变化（Embrace change） 保持简单（Maintain simplicity） 极限编程有效实践（极限编程是敏捷过程中最富盛名的一个） Incremental planning Small releases Simple design Test-first development Refactoring Pair programming Collective ownership Continuous integration Sustainable pace On-site customer 适用范围： 项目团队的人数不能太多 项目经常发生变更 高风险的项目实施 开发人员可以参与决策]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（补充）——分解算法浅析]]></title>
    <url>%2F2017%2F11%2F11%2F2017-11-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面：今天笔者将会对BCNF和3NF分解算法做简要的分析，不过实际上大多数的分解用肉眼即可，以下分解算法不依赖于过多的条件可以直接讲一个满足1NF的模式分解为3NF或BCNF BCNF 分解算法 教材上关于BCNF分解算法的伪代码实现有部分印错（本科教学版） 该算法的结果是一个满足BCNF的无损分解，但可能不是保持依赖的（毕竟3NF是保持依赖并且可以满足无损分解的最高范式） 伪代码实现对满足1NF的模式R作如下处理可分解成满足BCNF范式的模式R1, R2, …, Rn 12345678910result := &#123;R&#125;; done := false; 计算F+; while(not done) do if(result中存在模式Ri不属于BCNF) then begin 令 α→β 为一个在Ri上成立的非平凡函数依赖，满足 α→β ∈ F+， 并且 α∩β = ∅; result := (result - Ri) ∪ (Ri - β) ∪ (α, β) end else done := true 先来分析一波上面的代码吧 首先令reslut = {R} 接着计算一下F的函数闭包F+（计算函数闭包还是挺麻烦的，所以在下面判断的时候挑一个函数依赖，判断一下是否被F逻辑蕴含即可） 然后判断结果集result中是否还存在哪个模式不满足BCNF范式，如果都满足，则直接跳到步骤5，如果存在某个模式 Ri ∈ result，不满足BCNF范式，则执行步骤4 选择一个在Ri上成立的非平凡函数依赖 α→β，并且 α→β 属于 F+，并且α∩β=∅。然后将模式Ri分解成两个模式，分别为 (Ri - β) 和 (α, β)。并且将Ri从result中移除，江新得到的两个模式添加到result中。接着回到步骤3继续判断 分解完成，输出结果 纸上学来终觉浅，让我们拿教材上的栗子出来刷一刷～～ 有模式class, 通过上述算法，对其进行满足BCNF范式的分解 U = {course_id, title, dept_name, credits. sec_id, semester, year, building, room_number, capticy, time_slot_id} F = {course_id → (title, dept_name, credits),(building, room_number)→capaticy,(course_id, sec_id, semester, year)→(building, room_number, time_slot_id)} 首先还是看一下上面模式的候选码是什么吧（书上的栗子是直接给出来了，但是有些题可能不给，需要自己算） 通过上一篇博客讲的候选码求解算法，容易求得模式class的候选码为{course_id, sec_id, semester, year} 接着判断模式class是否满足BCNF范式 模式R中存在依赖 course_id → (title, dept_name, credits), 但course_id并不是R的一个超码，故R不满足BCNF范式 对R做如下分解 course(course_id, title, dept_name, credits) class_1(course_id, credits. sec_id, semester, year, building, room_number, capticy, time_slot_id) 继续判断，易知course是满足BCNF范式的，而course_1同理不满足BCNF范式， 继续分解 找到非平凡依赖(building, room_number)→capaticy， 且其属于F 对class_1分解如下 classroom(building, room_number, capacity) section(course_id, credits. sec_id, semester, year, building, room_number, time_slot_id) 检测一下发现现在模式classroom和section也满足BCNF范式了 OK，原来的模式class现在分解为如下三个模式 course(course_id, title, dept_name, credits) classroom(building, room_number, capacity) section(course_id, credits. sec_id, semester, year, building, room_number, time_slot_id) 3NF分解算法以下分解算法中用到了正则覆盖的概念，这个笔者在之前的博客中也提到过，点我传送 该分解算法可以保持依赖，并且是无损分解 伪代码实现 123456789101112131415161718令Fc为F的正则覆盖;i:= 0;for each Fc 中的函数依赖 α→β i := i + 1 Ri := αβ;if 模式 Rj, j = 1, 2, ..., i 都不包含R的候选码then i := i + 1 Ri := R的任意候选码/*(以下代码可选)用来移除冗余关系，如果没有冗余关系则可以不care*/repeat if 模式 Rj包含于另一个模式Rk中 then /*删除Rj*/ Rj := Ri i := i - 1until 不再有可以删除的Rjreturn (R1, R2, ..., Ri) 老规矩，还是先分析一下上面的伪代码 首先求出F的正则覆盖Fc（实际上就是利用Amstrong公式化简原来的函数依赖集的过程） 接着将Fc中的每一个函数依赖单独分解成一个模式，得到一个模式列表S = {R1, R2, …, Ri} 如果上述模式列表S中的任意一个模式包含模式R的候选码，则跳到步骤5，否则执行步骤4 选取R的任意一个候选码，组成一个新的模式R’, 将R’添加到模式列表S中 （可选）如果模式列表中存在冗余（即某个模式被其他模式包含），则可以删除这个模式 输出S 讲真，3NF分解的步骤还是很简单的，主要还是计算一下F的正则覆盖，详细栗子就不举了，下面简单提一提 比如上面分析BCNF分解算法时用到的模式class， 利用上述算法分解之后可以得到和 利用BCNF算法分解一样的结果 所以，神奇的事情发生了，利用3NF分解算法得到的结果可能还会满足BCNF范式 实践中BCNF分解的另一种途径： 先用3NF算法分解，然后对结果中不满足BCNF范式的模式用BCNF分解算法分解，如果结果不保持依赖，则回退回3NF]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（补充）——候选码的确定方法]]></title>
    <url>%2F2017%2F11%2F10%2F2017-11-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E5%80%99%E9%80%89%E7%A0%81%E7%9A%84%E7%A1%AE%E5%AE%9A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面：前面一堆都了解了解，重点在后面一个关于求候选码的算法（要是题里面没有给主属性，就要通过这个方法求哪些是主属性，哪些不是了，所以还是挺实用的） 候选码定义: 设K为关系模式R的属性(组)，若K→FU，则称K为R的 候选码。 主码：若R有多个候选码，则可以从中选定一个作为R的主码。 主属性：包含在任一个候选码中的属性，称作主属性。 非主属性：不包含在任一个候选码中的属性，称作非主属性(或非码属性)。 全码：关系模式的码由全部属性构成。 注: 码或者是某一函数依赖的左部, 或是一个属性组。 引例：求出关系模式R的所有候选码：U={ A , B , C , D , E }F={AB→C, B→D, C→E, EC→B, AC→B } 解： 验证AB是否码, 须证明 AB→FABCDE是否成立?∵AB→C(已知), 而AB→AB(自反), ∴AB → ABC(合并)∵B→D(已知), ∴AB→AD(增广), ∴AB → ABCD(合并)∵C→E(已知), AB→C(已知), ∴AB → E(传递) 于是 AB → ABCDE(合并) 同理可证：AC也是一个候选码 上述例题实际上就是利用Amstrong公式，最后得到一个属性集可以推出U（关系模式的全集） 练习： 根据码的定义，求关系模式R的所有候选码。U={ A , B , C , D }， F={A→ B, C→B } 答：ACD 关于2NF的结论 不存在非主属性的关系模式属于2NF。 （没有非主属性） 全码关系模式属于2NF。 （没有非主属性） 码只由一个属性组成的关系模式属于2NF。（不会有部分依赖） 二目关系模式属于2NF。 （码或是一个属性，或是全码） 若R属于1NF，但R不一定属于2NF。例如, 关系模式 S(S#, SN, SD, DEAN, C#, G) 关于3NF的结论 不存在非主属性的关系模式属于3NF。 （没有非主属性） 全码关系模式属于3NF。 （没有非主属性） 二目关系模式属于3NF。 （不会存在传递依赖） 若R属于3NF，那么R也属于2NF。（可证明，反证） 若R属于2NF，但R不一定属于3NF。例如，关系模式 S_SD(S#, SN, SD, DEAN) BCNF定义：关系模式R ∈1NF，对于属性组X和Y，若X→Y且Y ∉ X时X必含有码，则R ∈BCNF 由BCNF的定义，对于非平凡的函数依赖: X → Y X包含码，或者X本身就是码（换句话说，X是一个超码） 所有非主属性对每一个码都是完全函数依赖， 即, 若R∈BCNF, 则R∈2NF。 所有的主属性对每一个不包含它的码也是完全函数依赖。 没有任何属性完全函数依赖于非码的任何一组属性。 若R∈BCNF, 则必有R∈3NF; 反之不一定成立 铛铛铛！！！敲黑板，候选码的求解算法以下算法会涉及到求属性集的闭包，函数依赖集和属性集闭包传送阵 设关系模式R 将R的所有属性分为 L、 R、N和 LR四类，并令X代表L、N两类，Y代表LR类。 L类: 仅出现在F的函数依赖左部的属性； R类: 仅出现在F的函数依赖右部的属性； N类: 在F的函数依赖左右两边都不出现的属性； LR类:在F的函数依赖左右两边都出现的属性 。 求属性集闭包X+，若 X+包含了R的全部属性则X即为R的唯一候选码, 转5; 否则, 在Y中取一属性A，求属性集闭包(XA)+，若(XA)+包含了R的全部属性，则转4；否则，调换一属性反复进行这一过程，直到试完所有Y中的属性。 如果已找出了所有的候选码，则转(5)；否则在Y中依次取2个、3个、…属性，求X与它们的属性集闭包，直到其闭包包含R的全部属性。 停止，输出结果。 例1： 设关系模式R(A, B, C, D), 其函数依赖集：F={D→B, B→D, AD→B, AC→D}，求R的所有候选码。 解: L类: A, C R类: N类: LR类: B, D因为(AC)F+=ACDB，所以AC是R的唯一候选码 例2：设关系模式R(A, B, C, D, E, P), 其函数依赖集：F={A→D, E→D, D→B, BC→D, DC→A}，求R的所有候选码。 解: L类: C, ER类:N类: PLR类: A, B, D因为(CEP)F+=CEPDBA，所以CEP是R的唯一候选码。 例3： 设关系模式R(S, D, I, B, O, Q), 其函数依赖集:F = { S→D, I→B, B→O, O→Q, Q→I }，求R的所有候选码。 解: L类(S); R类(D) ; N类(无) ; LR类(I, B, O, Q)因为S+=SD, 所以S不是R的候选码； 因为(SI)+=SIDBOQ，所以SI是一个候选码； 因为(SB)+=SBDOQI，所以SB也是一个候选码； 因为(SO)+=SODQIB，所以SO也是一个候选码； 因为(SQ)+=SQDIBO，所以SQ也是一个候选码。]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（补充）——数据库设计和E——R模型]]></title>
    <url>%2F2017%2F11%2F08%2F2017-11-08-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%92%8CE%E2%80%94%E2%80%94R%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[实体—联系模型 实体集 实体（entity）：现实世界中一个可以区别于其他对象的一个“事物”或对象 实体集（entity set）：相同类型（即具有相同性质/属性）的实体的集合 外延（extension）：属于实体集的实体的实际集合 ps: 实体集和外延的关系类似于之前讲的模式和实例的关系 属性（attribute）：实体集中每个成员所具有的描述性性质 值（value）：每个实体的每个属性都有一个值 联系集 联系（relationship）：多个实体间的相互关联 联系集（relationship set）： 相同类型联系的集合 实体集之间的关联称之为参与：实体集E1, E2, E3 参与 联系集R 联系也可以具有 描述性属性 实体在联系中扮演的功能称为角色 参与联系集的实体集的数目称为联系集的度， 二元联系集的度为2 属性 域（domain）/ 值集：每个 属性 都有一个 可取值的集合 ，称为该属性的 域 或 值集 简单（simple） 和复合（composite）属性 简单属性不可以再分成更小的部分，而复合属性可以(例如下面的name即为复合属性) 单值（single-value）和多值（multivalued）属性 单值：一个实体在的单值属性只对应一个值 多值：一个实体的多值属性可以对应多个值（如，phone_number） 派生（derived）属性 派生属性的值可以从别的相关属性或实体派生出来 eg.:银行账户的余额可以从账户的存取款明细中计算出来 派生属性在原则上是不用保存的，但是有时候保存派生属性可以节约计算时间（空间换时间） 约束 映射基数约束 一对一（one-to-one） 一对多（one-to-many） 多对一（many-to-one） 多对多（many-to-many） 参与约束 全部参与：实体集E的每一个实体都参与到联系集R的至少一个联系中 部分参与：实体集E中只有部分实体参与到联系集R的联系中 码 超码 候选码 主码 #### 从实体集中删除冗余属性 要点： 删除其他实体的主键 其他实体的主键相当于外建的存在，一般属于联系集的属性 举个栗子： instructor(ID, name, dept_name, salary)，其中ID为主键 department(dept_name, building, budget)，其中dept_name为主键 属性dept_name在两个表中都出现了，所以它属于冗余属性，他又是department的主键，故应该将其从instructor表中移除（实际数据库实现的时候instructor表中是有一个dept_name属性的，他作为一个外建存在，实际上是两者的联系集是简单的1对多的关系，便没有单独成表，而是采用外键相联系） 实体——联系图 基本结构 分成两部分的矩形 代表 实体集 菱形 代表 联系集 未分割的矩形 代表 联系集的属性 线段 将实体集连接到联系集 虚线 将联系集属性连接到联系集 双线 显示实体在联系集中的参与度(用双线与联系集相连表示全部参与) 双菱形 代表连接到弱实体集的 标志性实体集 映射基数 一对一 一对多 多对一 多对多 balabala，图画起来太麻烦了，其他的直接看书，下面聊一聊弱实体集 弱实体集 定义：没有足够的属性以形成主码的实体集称之为 弱实体集（weak entity set） 先举个栗子：(由于简书不支持下划线的写法，所以下面表中所有的主码都用斜体表示) course (course_id, titles, credits) section (sec_id, semester, year) 对于上面的两个实体集，参与如下联系集 sec_course(course_id, sec_id, semester, year) 上面的section实体集实际上就是一个弱联系集 一个section实体如果不与一个course对相关联是毫无意义的，并且只有sec_id, semester, year三个属性也是决定不了一个section的 弱实体集必须于另一个称作标识（identifying）或属主和实体集（owner entity set）的实体集相关联才有意义 虽然弱实体集没有主码，但是本身仍要有在依赖于强实体集的基础上的进一步区分的方法，弱实体集的分辨符/部分码（discriminator）便可以用来做进一步的区分 上述例子中的sec_id, semester, year便组成了section的分辨符 在画ER图的时候，组成分辨符的属性底下画虚线（可参见教材 图7-5） 弱实体集的主码由 标识实体集的主码 加上 该弱实体集的分辨符 构成 ER图中的表示 组成分辨符的属性底下画虚线，而不是实线 关联弱实体集和标识性强实体集的联系集以双菱形表示 接着，只需要把教材图7-15的图看懂理解，ER图的绘制基本上就没有毛病了 ER图转换为关系模式这个不难下面简单列几点注意事项 复合属性 将每个子属性单独作为一个属性来处理 派生属性 不显示表示出来 多值属性 单独成表 弱实体集转换 对于从弱实体集转换而来的模式，该模式的主码由其所依赖的强实体集的主码与弱实体集的分辨符组成 联系集 多对多的情况一定单独成表 联系集拥有描述性属性的情况单独成表 其它情况下均可不单独成表 一对一情况下讲任意实体集的主键作为另一个实体集的外建均可 一对多和多对一的情况下，将“一”端的主键作为”多”端的外建]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（十一）—— 范式]]></title>
    <url>%2F2017%2F11%2F01%2F2017-11-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一般而言，关系数据库的设计目标是生成一组关系模式，使我们存储信息时避免不必要的冗余，并且让我们可以方便地获取信息。这是通过设计满足适当范式（normal form）的模式来实现的。 引例 首先有如下两个模式 instructor( ID, name, dept_name, salary ) department( dept_name, building, budget ) 若将上面两个模式合并成一个大的模式 inst_dept(ID, name, salary, dept_name, building, budget) 存在数据冗余（building和budget被存储了多份，实际上每个系的楼和预算只要存一次就好了） 存在插入、删除和更新异常 需要分解成更小的模式 并不是所有模式的分解都是有益的 employee(ID, name, street, city, salary) 分解成下面两个模式 employee1(ID, name) employee2(name, street, city, salary) 由于可能存在同名的可能，所以分解以后导致了数据的丢失 比如有两个叫Sunny的人，我们用其中一个Sunny的ID去查询他的地址信息的时候，因为存在两份信息相互混淆，导致得不到正确的结果，但是在分解之前通过ID是可以得到唯一的地址的 有损分解和无损分解 像上面的例子中，分解以后导致信息丢失的分解称之为有损分解（在实际进行分解时要避免这种分解） 反之则称之为无损分解（无损分解在重新合并后可以得到和分解之前一致的状态） 函数依赖 什么是函数依赖？ 有如下模式 U = {Sno, Sname, Cno, Sdept, Mname, Grade} (分别代表学号、学生姓名、课程号、系、系主任、分数) Sname = f(Sno) ==&gt;学生的姓名函数依赖于学号 记作：Sno→Sname 读作：Sno推出Sname 非平凡函数依赖和平凡函数依赖 X 和 Y 为模式U中一个或多个属性的集合 非平凡函数依赖 X→Y，但Y∉X 平凡函数依赖（包含冗余） X→Y，且Y∈X 完全函数依赖和部分函数依赖 写函数依赖时，完全函数依赖和部分函数依赖的写法中，P和F是写在箭头的正上方的，由于Markdown不能很好的展现，就标在了箭头的右上角所以用下面的表示法： &rarr;F ：完全依赖 &rarr;P ：部分依赖 完全函数依赖 在模式R(U)中X→Y，但是对于任意X的真子集X’， 都没有X‘→Y, 则称Y完全函数依赖于X，记作X&rarr;FY X实际上就是能推出Y的最小集 例如：(Sno, Cno)→Grade 部分函数依赖 在模式R(U)中X→Y，存在某个X的真子集X’， 有X‘→Y, 则称Y部分函数依赖于X，记作X&rarr;PY 例如：(Sno, Cno)→Sdept 而实际上：Sno→Sdept 也是可行的，上面的依赖关系中，Cno是冗余的 传递函数依赖 X→Y, Y→Z ==&gt; X→Z 码 超码、候选码和主码 可以沿用SQL中码的概念 超码是可以唯一标识一个元组的属性集（可以有多个） 候选码是每个超码中去除不必要属性但是仍然能够标识一个元素的最精简属性集（可以有多个） 主码只有一个，在候选码中选一个当做主码 用函数依赖来定义 K为R&lt; U, F &gt;中的属性或属性组合，若K→U(→上面有一个F)(即U完全依赖于K)，则称K为R的候选码，若候选码多与一个，则选择其中一个作为主码 主属性与非主属性 主属性：包含于某个候选码的属性 非主属性：不被任何候选码包含的属性 范式 首先还是构造一个例子 R&lt; U, F&gt; U = {Sno, Sdept, Sloc, Cno, Grade} (分别代表学号、系、系所在楼、课程号、分数) F = {(Sno, Cno)&rarr;F Grade, Sno&rarr;Sdept, (Sno, Cno)&rarr;P Sdept, Sno&rarr;Sloc, (Sno, Cno)&rarr;PSloc} 主属性：Sno, Cno 非主属性：Sdept, Sloc, Grade 上面的依赖关系可以用下面的图示表示 第一范式（1NF） 一个域是原子的(atomic)，则该域的元素被认为是不可分的单元 比如name属性就可以不是原子的，name(first_name, middle_name, last_name) 一个关系模式R属于第一范式（1NF）==&gt;R上的所有属性都是原子的 上述例子中的每个属性都是原子的，所以满足第一范式 第二范式（2NF） R ∈ 1NF，并且每一个非主属性完全依赖于码（实际上就是在1NF的基础上，去除了非主属性对码的部分函数依赖） 上述例子中存在非主属性对码的部分函数依赖，故不满足2NF 对上述例子作出如下分解 R1&lt; {Sno, Cno, Grade}, {(Sno, Cno)&rarr;FGrade} &gt; R2&lt; {Sno, Sdept, Sloc}, {Sno&rarr;Sdept, Sdept&rarr;Sloc}&gt; ps:其中R2隐含了Sno&rarr;Sloc (由之后即将学习的AmStrong公理可以推算出来) 上面的依赖关系可以用下面的图示表示 经过上面的分解之后，每一个非主属性都完全依赖于码了，所以分解之后的模式满足2NF 第三范式（3NF） R∈2NF, 并且不存在非主属性对码的传递依赖（实际上就是在2NF的基础上去除了非主属性对码的传递依赖） 上述经过分解以后的模式中存在非主属性对码的传递依赖，故不满足3NF Sno&rarr;Sdept, Sdept&rarr;Sloc ==&gt; Sno&rarr;Sloc 对上面的模式进行进一步的分解 R1&lt; {Sno, Cno, Grade}, {(Sno, Cno)&rarr;FGrade} &gt; R2&lt; {Sno, Sdept}, {Sno&rarr;Sdept} &gt; R3&lt; {Sdept, Sloc}, {Sdept&rarr;Sloc} &gt; 上面的依赖关系可以用下面的图示表示 经过上面的进一步分解之后，就不存在非主属性对码的传递依赖了，故进一步分解之后的模式满足3NF 2NF和3NF中的约束都是针对于非主属性的。在日常开发的时候只要ER图设计好，一般都是满足到3NF的，3NF也是可以保证无损分解的最高范式 Boyce-Codd范式（BCNF） R ∈ 3NF， 并且不存在主属性间的部分函数依赖和传递函数依赖 （实际上就是在3NF的基础上，去除了主属性的部分函数依赖和传递函数依赖） 举个栗子 R&lt; U, F &gt; U = {S, T, J} F = { (S, J)&rarr;T, (S, T)&rarr;J, T&rarr;J } 从上面的函数依赖易判断出：S、T、J都是主属性 因为{S, J}， {S, T} 都是候选码 因为不存在非主属性，所以该模式已经满足到3NF 上面模式的依赖可以用下面的图示表示 上面的栗子中的模式主属性中存在部分函数依赖，所以不满足BCNF 作出如下分解 R1&lt; {S, T, J}, { (S, J)&rarr;T, (S, T)&rarr;J } &gt; R2&lt; {T, J}, { T&rarr;J } &gt; 上面的依赖关系可以用下图表示 经过分解之后的模式就不存在主属性间的部分函数依赖和传递函数依赖， 故满足BCNF 当我们分解不属于BCNF的模式的时候，产生的模式中可能有一个或多个不属于BCNF。在这种情况中，需要进一步分解，其最终结果是一个BCNF的模式集合 更高的范式还有第四范式和第五范式，但是应用较少，且考纲不要求，这里就不再赘述了]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（十二）——函数依赖理论和分解算法]]></title>
    <url>%2F2017%2F11%2F01%2F2017-11-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%90%86%E8%AE%BA%E5%92%8C%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[函数依赖理论 逻辑蕴涵 定义： 存在如下条件 关系模式：r(R) 依赖集：F （由一个或多个依赖组成） 依赖：f 若r(R)满足F ==&gt; r(R)满足f 我们称 F 逻辑蕴涵 f ps: 其中f可由F通过Armstrong公理推得 举个栗子： 给定关系模式 r(A, B, C, G, H, I) F包含如下依赖 A &rarr; B A &rarr; C CG &rarr; H CG &rarr; I B &rarr; H 函数依赖f : A &rarr; H 其中 f 被 F 逻辑蕴涵 由Amstrong传递公理可知：A &rarr; B, B &rarr; H ==&gt; A &rarr; H 函数依赖集的闭包 令 F 为一个函数依赖集。则 F的闭包 是 被 F 逻辑蕴涵的所有函数依赖的集合 记作：F+ Armstrong公理（Armstrong’s axiom） 公理是科学的客观规律，不需要自己证明，直接用就行 Armstrong 公理 自反律（reflexivity rule）。若α为一个属性集，且β⊆α， 则α&rarr;β 举个栗子：(A, B)&rarr;A 增补律（augmentation rule）。若α&rarr;β成立且γ为一属性集，则γα&rarr;γβ 举个栗子：(A, B)&rarr;C ==&gt; (A, B, D, E)&rarr;(C, D, E) 传递律（transitivity rule）。若α&rarr;β和β&rarr;γ成立，则 α&rarr;γ 成立 举个栗子：A&rarr;B, B&rarr;C ==&gt; A&rarr;C Armstrong公理是完备的，对于一个给定的函数依赖集F，通过Armstrong公理可以产生全部的F+ Armstrong公理的一些推论 可由Armstrong公理直接推得，也可以当做公理使用 合并律（union rule）。若α&rarr;β和α&rarr;γ成立，则α&rarr;βγ 举个栗子：A&rarr;B, A&rarr;C ==&gt; A&rarr;(B, C) 分解律（decomposition rule）。若α&rarr;βγ成立，则α&rarr;β和α&rarr;γ成立 举个栗子：A&rarr;(B, C) ==&gt; A&rarr;B, A&rarr;C 伪传递律（pseudotransitivity rule）。若α&rarr;β和γβ&rarr;δ成立，则αγ&rarr;δ成立 举个栗子：A&rarr;B, (B, C)&rarr;D ==&gt; (A, C)&rarr;D 属性集的闭包 令α为一个属性集，我们将函数依赖集 F 下被α 函数确定的所有属性的额集合为称为F下α的闭包 记作：α+ 伪代码如下：1234567result := α repeat for each 函数依赖 β→γ in F do begin if β ⊆ result then result := result ∪ γ end until(result 不变) 正则覆盖（极小函数依赖集） 如果去除函数依赖中的一个属性不改变函数依赖集的闭包，则称该属性是无关的 F的正则覆盖 Fc 是一个依赖集，使得F逻辑蕴涵Fc 中的所有依赖，并且Fc 逻辑蕴涵F中的所有依赖。此外，Fc 必须具有如下性质 ： Fc 中任何函数依赖都不含无关属性 Fc 中函数依赖的左半部都是唯一的。即Fc 中不存在两个依赖α1&rarr;β1和α2&rarr;β2， 满足α1=α2 无损分解 如果用两个关系模式r1(R)和r2(R)替代r(R)时没有信息损失，则我们称该分解时无损分解（lossless decomposition） SQL 表示 123-- 下面查询的结果与r具有相同结果的元组集SELECT *FROM r1 natural join r2 关系代数表示： ∏R1(r) ⋈ ∏R2(r) = r 分解算法（下回分解）]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017级Android第一次例会]]></title>
    <url>%2F2017%2F10%2F24%2F2017-10-24-2017%E7%BA%A7Android%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BE%8B%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[Android 前世今生 版本名称 版本号 发布时间 API版本 官方支持状态 Android (Alpha) 1.0 September 23, 2008 1 不支持 Beta (Internally known as “Petit Four”) 1.1 February 9, 2009 2 不支持 Cupcake（纸杯蛋糕） 1.5 April 27, 2009 3 不支持 Donut（甜甜圈） 1.6 September 15, 2009 4 不支持 Eclair（闪电泡芙） 2.0 – 2.1 October 26, 2009 5 – 7 不支持 Froyo（冻酸奶） 2.2 – 2.2.3 May 20, 2010 8 不支持 Gingerbread（姜饼） 2.3 – 2.3.7 December 6, 2010 9 – 10 不支持 Honeycomb（蜂巢） 3.0 – 3.2.6 February 22, 2011 11 – 13 不支持 Ice Cream Sandwich（冰淇淋三明治） 4.0 – 4.0.4 October 18, 2011 14 – 15 不支持 Jelly Bean（果冻豆） 4.1 – 4.3.1 July 9, 2012 16 – 18 不支持 KitKat（奇巧巧克力棒） 4.4 – 4.4.4 October 31, 2013 19 支持 Lollipop（棒棒糖） 5.0 – 5.1.1 November 12, 2014 21 – 22 支持 Marshmallow（棉花糖） 6.0 – 6.0.1 October 5, 2015 23 支持 Nougat（牛轧糖） 7.0 – 7.1.2 August 22, 2016 24 – 25 支持 O/Oreo（奥利奥） 8.0 August 22, 2017 26 支持 开发语言组里主要以Java语言为主，同时会介绍一些Kotlin开发Android。90% Java + 10% Kotlin Java Kotlin C++ … 开发环境 Eclipse（拒绝） Visual Studio Android Studio(推荐) 2.3（稳定版）==&gt;不支持Kotlin 3.0（pre）==&gt;支持Kotlin，对Java8有较好的支持 Java 环境配置：Kotlin 可以基于JVM，不需要额外配置，IDEA中可直接创建Kotlin项目 点此传送进行Java环境配置（http://www.jianshu.com/p/21abe20aadf2） 最好是下专业版IDEA（专业版需要注册码，可以用学校邮箱注册学生账号，可免费一年，过期需要手动再次激活） Java书籍推荐 入门：《Java核心技术 卷Ⅰ》、《疯狂Java讲义》 进阶：《Java编程思想》、《Java核心技术 卷Ⅱ》 强烈安利：《Effective Java》（这本书建议对Java有一定的熟悉程度，并有一定开发经验之后再看，会受益匪浅） 电子书资源： 点我下载（http://pan.baidu.com/s/1boXCxbT） Android环境配置 Google Developer （https://developers.google.cn/） Google Android Developer IDE 下载： 建议下载最新的Android Studio3.0预览版（稳定版和预览版可以共存，所以你也可以2.3和3.0都装） 官网下载 Android中文社区，可下载2.3.3和3.0预览版稳定版AS（http://www.android-studio.org/） 环境配置 CSDN教程 极客学院视频教程 极客学院视频 极客学院离线视频资源]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（十）——关系代数]]></title>
    <url>%2F2017%2F10%2F17%2F2017-10-17-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[基本运算每一种基本运算的结果都是一个新的关系，可以用这个关系继续参与运算，借此便可进行复杂的运算 选择运算（select）==&gt;相当于SQL语句中的WHERE子句的职能 格式：σ选择谓词(关系) 举个栗子： σSAL&gt;1000(EMP) 上式表示取出查询工资大于1000的所有员工的信息 等价于下面的SQL语句123SELECT *FROM EMPWHERE SAL &gt; 1000 选择谓词的分类 比较：=、≠、&lt;、≤、&gt;和≥ 连词：and(∧)、or(∨)和not(¬)==&gt;可以将多个谓词合并成一个大的谓词 可以包括两个属性（字段的比较）：σCOMM&gt;SAL(EMP)表示抽成大于工资的人 投影运算（project）==&gt;相当于SQL语句中的SELECT子句的职能 格式：∏字段序列(关系) 举个栗子 ∏ENAME,SAL(EMP) 上式表示查看所有员工的姓名和工资 等价于下面的SQL语句12SELECT ENAME, SALFROM EMP 关系的组合运算==&gt;就像SQL中select、where子句那样的组合效果 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) 上面的式子求出了所有工资大于1000的员工的名字和工资(实际上就是将σSAL&gt;1000(EMP)执行的结果当做一个临时的关系，参与了投影运算得到的) 等价于下面的SQL语句123SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000 事实关系的组合运算就是那么简单，分析的时候把每个简单运算的结果当做一个新的关系参与后面的运算，这样一层层剥开来，再复杂的语句也变得容易分析 并运算（union）==&gt;相当于SQL中UNION关键字的职能 格式：（关系r）∪（关系s） 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) ∪ ∏ENAME,SAL(σCOMM&gt;300(EMP)) 上面的式子求出了所有工资大于1000或抽成大于300的员工的姓名和工资，等价于下面的SQL语句 1234567SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000UNIONSELECT ENAME, SALFROM EMPWHERE COMM &gt; 300 几点需要额外注意的： 此处的并运算是集合运算，所以结果是去重的，结果集中不存在重复的元组（而在SQL语句中，指定UNION ALL是可以保留重复的） 关系r与关系s必须是同元的，即它们的属性的数目要求必须相同（这就和SQL语句中UNION使用的时候要求上下两个语句的字段数相同是一样的意思） 关系r和关系s对应位置的属性域应该是类型兼容的（同样和SQL中UNION使用时，每个对应位置字段类型兼容是一样的意思） 集合的差运算（set-defference）==&gt;相当于SQL语句中的EXCEPT 格式：(关系r)-(关系s) 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) - ∏ENAME,SAL(σCOMM&gt;300(EMP)) 上面的式子表示工资大于1000但抽成不大于300的员工的姓名和工资，等价于下面的SQL语句1234567SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000EXCEPTSELECT ENAME, SALFROM EMPWHERE COMM &gt; 300 几点需要额外注意的： 此处的注意同上面的并运算的注意事项 笛卡尔积运算（Cartesian-product）==&gt;等价于SQL语句中两个表进行笛卡尔积（全匹配）得到的结果，即SQL中进行多表连接时不指定连接条件的情况 格式：(关系r)×(关系) 举个栗子： EMP × DEPT 上面的式子表示两个表进行全匹配，等价于下面的SQL语句12SELECT *FROM EMP, DEPT 下面两个式子是等价的 ∏ENAME,DNAME(σEMP.DEPTNO=DEPT.DEPTNO(σJOB=”MANAGER”(EMP×DEPT))) ∏ENAME,DNAME(σEMP.DEPTNO=DEPT.DEPTNO((σJOB=”MANAGER”(EMP))×DEPT) 下面是对这两个式子的SQL转化，转化之后就一目了然了1234567891011-- 对应第一个式子SELECT ENAME, DNAMEFROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNOWHERE JOB = 'MANAGER'-- 对应第二个式子SELECT ENAME, DNAMEFROM DEPT JOIN (SELECT * FROM EMP WHERE JOB = 'MANAGER') ON EMP.DEPTNO = DEPT.DEPTNO 更名运算（rename）==&gt;等价于SQL语句中as的职能 格式：ρX(A1,A2,…,An)(E)==&gt;表示的是将关系E更名为X，Ai表示的是给E的第i个字段指定别名 举个栗子 ∏ENAME,DNAME(σe.DEPTNO=d.DEPTNO(σJOB=”MANAGER”(ρe(EMP)×ρd(DEPT)))) 上面式子含义就不解释了，是上面举的栗子，只是引入了更名运算符，它等价于下面的SQL语句123SELECT ENAME, DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNOWHERE JOB = 'MANAGER' 来，学习完上面的基本运算，来做个实际的栗子，要求找到员工表中的最高工资（因为目前还没有介绍类似SQL中组函数的操作，后面会介绍。所以通过以下方式来实现） step1: 找到所有不是最高工资的人 ∏e1.SAL(σe1.sal &lt; e2.sal(ρe1(EMP)×ρe2(EMP))) step2: 用所有的员工减去上面的员工，即得到最高工资 ∏SAL(EMP) - ∏e1.SAL(σe1.sal &lt; e2.sal(ρe1(EMP)×ρe2(EMP))) 在书写关系运算表达式的时候可以用序列号代替字段名（但是不直观，不常用，一般不用） 举个栗子 ∏$6(σ$6 &lt; $14(EMP×EMP)) 等价于下面的运算 ∏e1.SAL(σe1.sal &lt; e2.sal(ρe1(EMP)×ρe2(EMP))) 附加运算附加运算是由基本运算组成的，不能增强基本运算的运算能力，但是能简化运算 集合交运算（intersection）==&gt;相当于SQL语句中INTERSECT关键字的职能 格式：(关系r)∩(关系s) 因为集合交运算是可以由前面的基本运算组合产生的，所以把它归到附加运算 A ∩ B &lt;=&gt; A - (A - B) 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) ∩ ∏ENAME,SAL(σCOMM&gt;300(EMP)) 上面的式子表示工资大于1000并且抽成大于300的员工的姓名和工资，等价于下面的SQL语句1234567SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000INTERSECTSELECT ENAME, SALFROM EMPWHERE COMM &gt; 300 自然连接（natural join）==&gt; 相当于SQL语句中的NATURAL JOIN 格式：(关系)⋈(关系) 自然连接的形式化定义 r,s是两个关系 R，S是上面两个关系对应的关系模式（其实就是上述两个关系各自的属性列表） R ∩ S 表示r和s的同名属性列表 R ∪ S 表示出现在r或s上的属性名列表(是一个集合，不包同名属性，存在同名属性会去重) R - S 表示出现在R上，但不出现在S上的属性名列表 则可做如下定义 r⋈s = ∏R∪S(σr.A1=s.A1 ∧ r.A2=s.A2 ∧ … ∧ r.An=s.An(r×s)) ，其中 R∩S={A1, A2, …, An} 举个栗子 ∏name, course_id(instructor ⋈ teaches) 上面的式子列出了所有老师的名字以及其所授课程的id，等价于下面的SQL语句12SELECT name, course_idFROM intructor natural join teaches ps: 两个关系模式执行自然连接以后属性的排布顺序： 排在最前面的是两个关系模式相同的属性 其次是只属于第一个关系模式的属性 最后是只属于第二个关系模式的属性！！！所以所两个关系模式进行自然连接以后，总的属性的个数是减少了，具体减少的个数等于同名属性的个数 theta连接==&gt;是自然连接的扩展，相当于SQL中的join on 格式：(关系)⋈Θ(关系) 形式化定义： r ⋈Θ s = σΘ(r × s) 举个栗子 ∏name, course_id(instructor ⋈instructor.ID = teaches.ID teaches) 上面的式子表示列出所有工资高于5000的老师的名字以及其所授课程的id， 等价于下面的SQL语句12SELECT name, course_idFROM instructor join teaches on instructor.ID = teaches.ID 除运算（division） 这个在书上没讲，是老师上课的时候补充的 格式：(关系)÷(关系) 形式化定义：R÷S = ∏R∪S( ( ∏R-S(r) × S ) - ∏R-S, S(r) ) 笔者还有一篇介绍用SQL实现关系代数中除运算的文章=&gt;点我传送 解释起来挺麻烦的，这边给出一个博客链接：点我传送 赋值运算 就是将一个关系表达式的结果赋值取一个临时的名字，就相当于定义了一个临时关系。这个操作就相当于SQL中with语句的职能 格式： temp_name ← 关系表达式 举个栗子：temp1 ← R × Stemp2 ← σr.A1=s.A1 ∧ r.A2=s.A2 ∧ … ∧ r.An=s.An(temp1)result = ∏R∪S(temp2) 上面的式子等价于： result = r⋈s 外连接运算 左外连：⟕ 右外连：⟖ 全外连：⟗ 扩展运算扩展运算是不能用基本的关系代数运算来实现的一类查询，可以满足复杂的查询需求 广义投影（Generalized-projection） 与基本运算中的投影运算相比，就是多了允许在选择列表中出现表达式（在基本运算中的投影的选择列表中只能出现字段） 格式：∏F1, F2, … , Fn(E) 其中F1, F2, … , Fn可以是字段或者是表达式 E代表一个关系 举个栗子： ∏name, sal * 1.2(instructor) 上面的式子表示查出所有老师的名字，以及涨了20%以后的工资，等价于下面的SQL语句 12SELECT name, sal * 1.2FROM instructor 聚集函数（Aggregation function） 聚集函数的符号表示是用书写体G，这边就直接用G指代了 聚集函数是输入值的一个汇聚，以多个值作为输入，将一个单一的值作为返回结果 多重集：使用聚集函数对其进行操作的汇集中，一个值可以出现多次，值出现的顺序是无关紧要的。这样的汇集称为多重集（就比方说统计一个员工表中员工的数量，然后我们通过统计员工的名字来统计，即便是同名的员工我们也是计算的） 格式： G1, G2, … , GnGF1(A1), F2(A2), …, Fn(An)(E) 其中前面的G1, G2, … , Gn表示的是分组条件 后面的F1(A1), F2(A2), …, Fn(An)是聚集函数表达式列表 Fi(i = 1, 2, …, n)表示聚集函数：sum、count、average、max、min A1, A2, … , An代表字段 举个栗子： A1, A2Gsum(A3)(∏A1, A2, …, An(σP(r1×r2×…×rm)) ) 等价于下面的SQL语句1234SELECT A1, A2, sum(A3)FROM r1, r2, ..., rmWHERE PGROUP BY A1, A2 上面的聚集函数在进行计算的时候采用的都是多重集，也就是相同的值可以多次重复计算（也就是在执行聚集函数的时候是不去重计算），如果要去重计算的话就要采用下面的几个函数写法 sum_distinct count_distinct averag_distinct max_distinct min_distinct 举个栗子： A1, A2Gsum_distinct(A3)(∏A1, A2, …, An(σP(r1×r2×…×rm)) ) 上面的式子等价于下面的SQL语句1234SELECT A1, A2, sum(distinct A3)FROM r1, r2, ..., rmWHERE PGROUP BY A1, A2]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（九）——对违反约束的处理]]></title>
    <url>%2F2017%2F10%2F15%2F2017-10-15-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E8%BF%9D%E5%8F%8D%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章的一些尾巴，然后开始讲第六章的关系代数笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们构造一些简单表 1234567891011121314151617181920212223242526272829303132333435-- 执行下面的语句构造表CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE CASCADE ON UPDATE CASCADE);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 级联操作在指定外键以后，由于存在完整性约束，所以在执行删除或更新的时候由于语句可能会破坏完整性约束而执行失败。因此可以在定义外键的时候声明为级联删除和级联更新(是一种对违反参照完整性约束时的处理方式) 使用方式1234567CREATE table 表名( ... FOREGIN KEY (字段序列) REFERENCES 表名(字段序列) ON DELETE CASCADE ON UPDATE CASCADE, ...) 级联删除（ON DELETE CASCADE） 级联删除是在定义外键时指定的，但是却会在执行删除语句时产生影响 举个栗子 我们先不指定级联 12345678910111213141516171819202122232425262728293031323334DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id));INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 然后执行下面的删除操作 123-- 下面我们试图删除中国的信息，但是在person表里有一条数据引用了中国，所以因为参照完整性约束的存在，所以这条语句会执行失败DELETE countryWHERE country_id = 1 接下来我们重新构造一遍（当然直接用DDL语句更新也是可以的）–并在构造person表时指定了级联删除 1234567891011121314151617181920212223242526272829303132333435DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE CASCADE);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 然后再次执行下面的删除操作 123-- 此时执行会发现语句成功执行了，不但删除了中国的信息，连带person表中引用了中国信息的所有数据都被删除了DELETE countryWHERE country_id = 1 上面的例子便很好的说明了级联删除的作用。如果我们视图删除外键参照键所在表（此处为country表）的某条数据A（此处是中国的信息），而这条数据又被外键所在表的一条或多条数据B所关联（此处person表中Sunny的country_id关联了country表中中国的id）。在指定了级联删除的情况下，删除A会连带着删除所有满足条件的B 当然在实际使用的时候用的还是比较少的，因为参照完整性约束在一定程度上可以防止数据的误删除，对数据库的完整性起了一定的保护作用，如果指定了级联删除，这层保护就失效了。所以还是视情况而用 级联更新（ON UPDATE CASCADE） 类似的，级联更新和级联删除一样，如果我们更新时违反了完整性约束，同样更新操作不被拒绝，而是级联更新 举个栗子（我们在上面操作的基础上执行，上面构造时指定了级联删除，但是没指定级联更新） 1234-- 我们试图执行下面的更新操作，我们把修改English的country_id， 但是由于person表中还有数据的country_id=2,如果下面的更新成功执行，则会导致person表中存在country_id=2的数据，而country中却没有对应数了，违反参照完整性约束，故下面的语句执行失败UPDATE countrySET country_id = 4WHERE country_id = 2 同样的，我们重新构造一下，此时指定级联更新 123456789101112131415161718192021222324252627282930313233343536DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE CASCADE ON UPDATE CASCADE);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 此时再执行一下上面的更新语句 1234-- 由于指定了级联更新，所以会发现下面的语句执行成功了，不但更改了country表中的数据，连带着person表中的数据也一并更新了UPDATE countrySET country_id = 4WHERE country_id = 2 上面就是级联更新的效果 另一类对违反完整性约束的处理 SET DEFAULT 一旦违反完整性约束，就将参照域（此处为country_id）设置为默认值 SET NULL 一旦违反完整性约束，就将参照域（此处为country_id）设置为NULL 举个栗子 执行下面的构造 1234567891011121314151617181920212223242526272829303132333435DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE SET NULL);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 然后执行下面的删除操作 123-- 下面的删除操作成功执行，但不是级联删除，而是把person表中原来country_id=1的数据的country_id都设成了NULLDELETE countryWHERE country_id = 1 延迟检查这是由于数据库默认是在执行每一条SQL语句的时候都进行完整性约束的检查，导致有些操作无法进行。延迟操作就将完整性约束的检查延迟到了事务结束的时候检查（大多数数据库不支持，比如SQL Server， 但Oracle数据支持） 由于不常用，SQL Server也不支持，这里就讲一下概念，不举实际的栗子了。 假设上面的例子表中没有指定延迟检查 执行下面的语句1234567-- 执行下面两条语句是会出错的，因为插入第一条数据的时候，由于完整性约束的存在，要求country表中要有country_id=4的数据，但是这个数据目前还不存在（所以只要先执行第二条语句，这两个语句才能成功执行）INSERT INTO person (person_id, name, country_id) VALUES ( 4, 'Jerry', 4);INSERT INTO country (country_id, country_name) VALUES ( 4, 'France'); 而如果指定了延迟检查呢 执行下面语句（下面两个语句处于同一个事务中）12345678-- 由于是延迟检查，所以两条数据都插入完，执行commit，事务结束时才进行完整性约束的检查，此时就不会出错，可以正常插入INSERT INTO person (person_id, name, country_id) VALUES ( 4, 'Jerry', 4);INSERT INTO country (country_id, country_name) VALUES ( 4, 'France');COMMIT 虽然SQL标准中有这个概念，但是大多数数据库没有提供支持，并且不常用]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（八）——视图 、事务]]></title>
    <url>%2F2017%2F10%2F10%2F2017-10-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%20%E3%80%81%E4%BA%8B%E5%8A%A1%20%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章(第三章的多表部分会挪到这一部分讲)笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们继续延用之前用的表(´`) 视图首先还是来谈谈笔者对视图概念的理解吧，在笔者看来视图这个数据库对象在不考虑物化的情况下就是一张虚表，本身没有实际的数据，但是可以利用视图在某个视角下观察一张或多张表的数据。所有对视图的操作最后都将转成对表的操作 视图定义（创建一个视图） 格式： 1CREATE VIEW 视图名 AS 子查询 举个栗子： 1234-- 下面的语句创建了一个简单的视图temp_view，其中包含员工名以及其所在部门名两个字段CREATE VIEW temp_view ASSELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO; 接下来我们对上面创建的视图进行查询操作 12SELECT *FROM temp_view; 得到如下结果： 数据库只存储视图的定义本身 视图通常是这样来实现的：当我们定义一个视图的时候，数据库系统就吧这个视图的定义（其实就是一个子查询语句）本身存储下来，一旦我们使用这个视图，数据库系统就会用定义中的查询语句替换视图 举个栗子123456789101112-- 我们继续沿用上面定义的视图temp_view，它的定义是这样的CREATE VIEW temp_view ASSELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO;-- 则对视图的查询操作可以作下面的等价(下面两个查询语句是等价的)SELECT *FROM temp_view;SELECT *FROM (SELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO) as temp_view; 可更新的视图 条件 FROM子句中只有一个数据库关系（即在定义视图的时候，后面的SELECT语句中只能查询一个表） SELECT子句中只包含关系的属性名，不包含任何的表达式，集聚函数或distinct声明 任何没有出现在SELECT子句中的属性可以取空值（即这些属性既没有not null 约束，也不构成主码的一部分） 查询中不含有group by 或 having 子句 满足上述条件的视图我们称作可更新的视图，在可更新视图上允许执行update、insert、delete操作 视图是在表的基础上定义的，所有对视图的操作最后都将作用在表上 视图的update、insert、delete 先定义一个视图，值包括员工的职工号、名字和工资 123CREATE VIEW emp_info ASSELECT EMPNO, ENAME, SALFROM EMP; 视图查询的结果如下： update 举个栗子123456789-- 下面的语句更新SMITH的工资UPDATE emp_infoSET SAL = 900WHERE ENAME = 'SMITH'--接下来查询表中的数据是否受到影响（查询的结果是900，就不贴图了）SELECT ENAME, SALFROM EMPWHERE ENAME = 'SMITH'; insert 举个栗子1234-- 往视图中插入一条数据（下面插入是可以执行成功的，可以自己试试，创建一个视图，只包含员工名字和工资，不包含EMPNO，这样就不能执行插入语句，违反了上面四个条件中的第三个条件）INSERT INTO emp_info (EMPNO, ENAME, SAL) VALUES ( 8888, 'Robbin', '1000'); –查询一下原表中的数据，会发现多了下面这条 视图的插入操作，最终作用到表上，并且是给视图中有的字段赋值，没有的字段都赋null值（这就解释了上面可更新视图的四个条件中的条件3） delete 举个栗子123-- 执行结果就是原表中的数据也被删除了DELETE emp_infoWHERE emp_info.EMPNO = 8888 物化视图 就是保存视图的结构，再使用时直接用保存的结果表，而不用再去将视图替换成定义，再次执行一遍查询视图的操作。这个在对视图的操作很频繁的时候是对效率很有增益的，但是同时带来的是同步的问题。就是原表中的数据更新了，但是视图物化的数据却没有更新，导致数据不一致。 一般用的很少，常用于数据仓库 视图更新检查（WITH CHECK OPTION） 默认情况下，如果一个视图满足以上可更新视图的定义，则通常的更新操作是允许被执行的 但是如果在创建视图的时候，在后面跟上 WITH CHECK OPTION,那么对视图的每一个更新操作，都会检查，更改后的结果，是否满足创建视图时WHERE子句中的限定。 举个栗子： 123456-- 我们在上面定义视图的栗子基础上改造一下，并加上WITH CHECK OPTIONCREATE VIEW emp_info ASSELECT EMPNO, ENAME, SALFROM EMPWHERE SAL &gt; 3000WITH CHECK OPTION; 上面视图的定义就是包含了工资超过3000的所有员工的员工号，名字，以及工资 这个时候如果我们执行下面的更新操作 1234-- 下面这个操作将会被拒绝执行UPDATE emp_infoSET SAL = 2000WHERE ... 由于在定义视图的时候添加了 WITH CHEKC OPTION 选项，所以在执行更新操作的时候回检查是否符合创建视图时WHERE子句中的条件，显然上面的操作不满足，故被拒绝执行。 事务 一个事务就是一个原子的，不可分割的任务，里面可能包含多条SQL语句。在事务机制下，一个事务中的多条SQL语句要么都执行，要么都不执行。 性质 原子性 事务是原子的，里面包含的一条或多条SQL语句要么都执行，要么都不执行 一致性 在隔离的执行多个事务时，用同步锁保证对数据库数据的一致性访问 隔离性 多个事务并行执行，若其中一个事务还没有结束，其他事务内是无法观察到这个事务对数据库的影响的 持久性 一旦事务正常完成，并提交，则其对数据库的修改就会持久化到数据库内。 事务的开始和终止 虽然各种关系型数据库都支持事务，但是不同的数据库的实现不同。具体的事务的开始和终止有隐式和显示之分 事务的开始 显示：begin transition （例如SQL Server数据库） 隐式：第一条DML语句（增删改查语句）开始执行就会开启一个事务 （例如Oracle数据库） 事物的终止 显示： end transition (例如SQL Server数据库) 隐式：执行 rollback、commit或者一条DDL语句 （例如Oracle数据库） 数据库加锁的范围不同 表级锁 页级锁 行级锁 举个栗子(由于使用SQL Server做的测试，所以采用显示的事务开启和关闭)12345678910111213141516-- 首先查看博客开头ALLEN的工资是1600-- 下面开启一个事务，并执行一条涨工资的操作（执行会立即完成）BEGIN TRANSACTIONUPDATE EMP SET SAL = SAL * 2WHERE ENAME = 'ALLEN';-- 与此同时，开启另一个事务，执行一条涨工资的操作（语句没有执行，一直在等待。这是因为上面那个事务对ALLEN的数据进行操作了，并且事务没有结束，由于同步锁的缘故，所以本事务中的修改语句要等上面那个事务执行完才能继续执行）BEGIN TRANSACTIONUPDATE EMP SET SAL = SAL * 3WHERE ENAME = 'ALLEN';-- 如果此时结束第一个事务，那么第二个事务的语句就能继续执行，此时提交第二个事务，最后得到的结果是，ALLEN的工资为9600COMMIT 完整性约束 主键约束 外键约束（参照完整性约束） 单关系上的约束 not null unique check(&lt;谓词&gt;)]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（七）]]></title>
    <url>%2F2017%2F09%2F29%2F2017-09-29-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章(第三章的多表部分会挪到这一部分讲)笔者接下来的代码示例会主要在SQL Server数据库中测试(由于SQL Server 数据库不支持自然连接，所以自然连接部分的将会在MySQL数据库中进行测试) 在开始今天的摸鱼大业之前，让我们继续延用之前用的表 外键约束：即具有外键约束的两张表，在进行操作时会收到一定程度的限制，如果某个操作执行后会破坏这个完整性，就将被拒绝执行。这个在之前的博客中有介绍==&gt; 传送门 自连接一个表与自身相连接的操作，其实与多表连接是一样的，只是连接的两张表用的是同一张表而已 举个栗子1234-- 下面的语句查询了所有员工的名字以及其经理的名字SELECT w.ENAME as worker_name, m.ENAME as manager_nameFROM EMP w JOIN EMP m ON w.MGR = m.EMPNO; 得到如下结果： 上面得到的结果是采用内连接得到的结果，所以对于那些MGR为null（没有经理）的员工，其信息就得不到显示，可以采用左外连接（LEFT OUTER JOIN） 员工表中MGR 和 EMPNO 字段应该有一层限制，MGR的取值应该是某一个EMPNO的取值（话句话说，一个员工的经理号应该也是同一张表中这个经理的职工号）。在定义这张表的时候可以给这两个字段加上一个外键约束。 12345678--下面的语句模拟了这一操作--只关注了EMPNO和MGR这两个字段，其他字段的描述省略了CREATE TABLE EMP( EMPNO INTEGER PRIMARY KEY , MGR INTEGER, .... FOREIGN KEY(MGR) REFERENCES EMP(EMPNO)) 还是那句话：绝大多数连接条件是建立在外键与外键的参照键之间的(自连接也不例外) 自然连接（NATURAL JOIN）其实自然连接就是写法更简单的多表连接，无需书写连接条件，让数据库自己判断应该采用什么连接条件（自然连接的语法是SQL的标准语法，但是并不是所有的数据库都支持，SQL Server就不支持自然连接的语法，但是Oracle和MySQL数据库都是支持的。。所以下面的测试就在MySQL里面测试啦，上次用IDEA连的那个数据库里面我已经建好了和在上面测试用例一样的表和数据，可以直接用） 可采用自然连接的前提条件：两个表中要有同名字段，并且同名字段的数据类型要一致 举个栗子 1234567891011-- 下面的语句就实现了查询所有的员工名字及其所在部门名-- 相当于内连接-- 因为两个表中有同名字段DEPTNO，并且数据类型相同，数据库就用这个作为连接条件SELECT e.ENAME, d.DNAMEFROM EMP e NATURAL JOIN DEPT d;-- 上面的语句等价于下面的内连接语句SELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO; 得到如下结果： 如果两个表中有同名字段，但是数据类型不一致，执行自然连接是会失败的，因为此时数据库不知道应该怎么连接两张表 当然如果想要执行外连接（左外，右外，全外）也是一样的 举个栗子 12345678910111213-- 下面几个语句是等价的，会得到相同的结果，都采用了左外连接SELECT e.ENAME, d.DNAMEFROM EMP e NATURAL LEFT OUTER JOIN DEPT d;SELECT e.ENAME, d.DNAMEFROM EMP e NATURAL LEFT JOIN DEPT d;SELECT e.ENAME, d.DNAMEFROM EMP e LEFT OUTER JOIN DEPT d ON e.DEPTNO = d.DEPTNO; 得到如下结果： 在使用自然连接时，同名字段（用于连接的字段）不能写限定名（虽然老师上课这么讲，但实际上呢？） 举个栗子 123456789101112-- 我们在上面例子的基础上，多显示一个部门号，下面的两条语句如果能执行，执行完的结果都是一样的-- 下面的语句在Oracle数据库执行会报错-- 但是在MySQL中执行是能过的SELECT e.ENAME, d.DNAME, e.DEPTNOFROM EMP e NATURAL JOIN DEPT d;-- 下面这种写法在Oracle和MySQL中都是能过的SELECT e.ENAME, d.DNAME, DEPTNOFROM EMP e NATURAL JOIN DEPT d; 让我们先分析一下，为什么在使用自然连接的时候同名字段可以不写限定名 先看看执行下面的语句有什么结果： 123SELECT *FROM EMP e NATURAL JOIN DEPT d; 得到下面结果： 可以看出来，采用自然连接以后，原本的同名字段DEPTNO只出现了一次,可以理解为采用自然连接以后FROM子句的结果就是上面那张表，同时原来的同名字段合成了一个。所以在SELECT子句中书写的时候可以不加表限定名（在Oracle数据库中不能加表限定名） 对比join操作，如果你直接用内连接或者外连接，而不是自然连接，会发现结果集里面用来连接的字段即便同名，也是会出现两次的（这也很好的解释了，为什么之前说在进行内外连操作的时候，用来连接的字段是需要用表明来限定的，不然SQL语句会有歧义，导致无法正确被解析————见数据库笔记（六））1234-- 你可以试试执行下面的SQL语句，会发现，结果集中名为DEPTNO的列有两列SELECT *FROM EMP e INNER JOIN DEPT d on e.DEPTNO = d.DEPTNO; 让我们对上面的结果小结一下 在采用自然连接的时候，对于同名字段，可以不写表限定名（但是在使用非自然连接的时候，同名字段一定要用表名来限定） 至于能不能写，得看具体是什么数据库，Oracle此种情况下就不允许在同名字段前写表限定名，而MySQL中则可以 所以推荐是在采用自然连接的时候，非同名字段都加上限定名，同名字段都不加 下面是在多表操作中的一点建议 在多表连接中，所有的字段前面都建议加上限定名 特殊的是，在使用自然连接的时候，同名字段不要写限定名 有一个问题就是，由于数据库只分析到数据字典层面，而无法分到数据层，所以就算两个表中的一组同名字段之间没有任何关系，但是数据类型一致，采用自然连接的话，这一组同名字段也会被作为连接条件。 举个栗子 12345678--下面这个栗子没有实际执行，想象一下就好-- 假设我们给部门表的部门名字段更名：DNAME--&gt;ENAME-- 然后我们仍然执行上面的例子-- 结果应该是没有数据，除非有一个员工，他的名字和他所在部门的名字是一样的。SELECT e.ENAME, d.ENMAEFROM EMP e NATURAL JOIN DEPT d 导致上面结果的原因是采用了自然连接以后，数据库会把所有同名并且类型相同的字段作为连接条件 有时候我们并不希望所有的同名字段都作为条件，这个时候我们就不能用上面的自然连接操作，就应该使用介绍的有关JOIN … USING的用法 利用JOIN … USING 可以灵活的指定用什么字段做连接条件 JOIN…USING 同样是一种自然连接，且是一种特殊的自然连接，不需要显示写明连接条件，只需要指定用什么字段连接即可 举个栗子 12345678910-- 用下面的语句同样可以实现查询所有员工名字以及其所在部门名字的需求SELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d USING (DEPTNO);-- 同样的，如果我们给部门表的部门名字段更名：DNAME--&gt;ENAME-- 为了避免上面提到的问题，我们可以只指定DEPTNO作为连接条件，就轻松解决上面的问题SELECT e.ENAME, d.ENAMEFROM EMP e JOIN DEPT d USING (DEPTNO); 得到如下结果： 其中JOIN 表名 USING (字段序列)，字段序列可以是一个或多个字段 如果两个表中存在同名字段，但是数据类型不一样，这样执行自然连接是会失败的 连接类型和连接条件(就是老师上课提到的课本上那个图) 连接类型 INNER JOIN LEFT OUTER JOIN RIGHT OUTER JOIN FULL OUTER JOIN 连接条件 NATURAL ON&lt; predicate> USING(A1, A2, …, An) 其中上面的连接类型和连接条件可以任意组合使用 但不是所有数据库都支持NATURAL 和 USING的用法，SQL Server不支持，Oracle和MySQL支持，即便支持，有一些细节还是不一样的（比如上面同名字段前面能不能加限定词的问题） ON的话是都支持的，建议用ON，有更好的可读性和灵活性 FROM子句中的子查询 如果子查询出现在FROM子句中，我们将子查询的结果当做一个临时的关系（表），奕称之为虚表 举个栗子 123456-- 下面的例子求出了工资比本部门平均工资高的员工的名字和其工资，以及其所在部门的平均工资SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) as avg_sal FROM EMP GROUP BY DEPTNO) as EWHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 得到如下结果： 分析上面的执行过程的时候，可以先分析一下子查询执行的结果是什么，然后再把它当做一张表放在上面，继续分析整个语句 可以给子查询得到的临时表取一个名字，并给里面的每个字段指定名字 最常见的是下面这种命名方法 12345SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO) as E(DEPTNO, avg_sal)WHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 直接在子查询后面用as关系指定表名以及子查询结果中每个字段的别名 但是也不是所有数据库都支持上面那种用法，Oracle数据库中就不支持用as关键字指定子查询的表名，也不支持在表名后面加上每个字段的名字，那这个时候怎么办呢？（可以在子查询里面给每个字段取别名，最后再给子查询得到的虚表用空格分隔取个表名就好了） 12345SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) as avg_sal FROM EMP GROUP BY DEPTNO) EWHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 下面提几点注意（对于FROM子句中的子查询）： 如果子查询中含有聚集函数（组函数）,一定要给它起个别名 对每个子查询得到的虚表都务必取个表名（虽然有些数据库可以不起表名，但是有些数据库不起表名是会出错的，所以建议还是都起一个表名） With 子句其实with子句的作用和在FROM子句中使用子查询时一样的，同样是得到了一张虚表，只是把FROM中冗长的子查询移到外面，可读性 更好一点 with子句的作用是定义一张临时表 WITH子句相当于把FROM中的子查询提出来，如果FROM子句中的子查询比较复杂的时候，这样做是很有好处的，可读性会好很多 WITH 的基本使用方法1WITH &lt; 临时表名 &gt; （字段别名序列）AS (子查询) 举个栗子12345678910111213141516-- 下面的例子和上面找大于本部门平均工资的例子是等效的-- 执行的结果也是相同的WITH avg_tab(DEPTNO, avg_sal)AS (SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO)SELECT e.ENAME, e.SAL, avg_tab.avg_salFROM EMP e, avg_tabWHERE e.DEPTNO = avg_tab.DEPTNO AND e.SAL &gt; avg_tab.avg_sal;-- 下面的语句和上面的等效SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO) as E(DEPTNO, avg_sal)WHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 标量子查询 把子查询的结果当做一个值，可以出现在任何可以放值的地方，比如SELECT,WHERE,HAVING 子查询的结果必须是单个元组的单个属性（即一行一列，只有单个值） 带子查询的DELETE语句 举个栗子： 12345678-- 下面的语句可以用来删除所有销售部的员工的信息DELETEFROM EMPWHERE DEPTNO = ( SELECT DEPT.DEPTNO FROM DEPT WHERE DNAME = 'SALES') 带子查询的INSERT语句 基本格式 12INSERT INTO &lt; 表名 &gt;（字段序列）子查询 举个栗子 1234567891011-- 由于SQL Server中是没有dual这张系统表的，而Oracle和MySQL数据库中是有的，所以下面的测试是在MySQL中测试的-- 下面的语句很巧妙的实现了：--如果部门表中没有部门号为666的部门的话，就将摸鱼部门的信息插入到部门表中--如果部门表中有部门号为666的部门，则不执行插入操作INSERT INTO DEPT (DEPTNO, DNAME, LOC)SELECT '666', 'MOYU', 'DUT'FROM dualWHERE NOT EXISTS(SELECT * FROM EMP WHERE DEPTNO = '666'); UPDATE语句的扩展 有下面几个扩展 可以嵌入子查询（这个不在举例，和上面的用法类似） case分支结构 case分支结构(可以有效的避免更新次序引发的问题) 第一种用法 1234567CASE WHEN &lt;条件&gt; THEN ... WHEN &lt;条件&gt; THEN ... ... ELSE ...END 第二种用法 12345CASE &lt;条件&gt;WHEN &lt;值&gt; THEN ...WHEN &lt;值&gt; THEN ......END 对比两种方法，可以将第一种方法类比成其他编程语言的if-else分支语句，而将第二种用法类比成switch语句 举个栗子123456789101112131415161718192021222324-- 我们的需求是给员工涨工资，工资大于等于3000的涨2%-- 工资大于等于两千的涨3%-- 工资小于2000的涨5%--第一种尝试UPDATE EMPSET SAL = SAL * 1.02WHERE SAL &gt;= 3000;UPDATE EMPSET SAL = SAL * 1.03WHERE SAL &gt;= 2000;UPDATE EMPSET SAL = SAL * 1.05WHERE SAL &lt; 2000;--会发现上面执行的次序不一样会导致结果不一样，如果把第三个更新语句先执行，那么可能某个工资低于2000的员工涨了一次工资后工资大于两千了，于是执行第二个更新语句的时候又给他涨了一遍工资-- 第二种尝试--下面就完美的实现了上面的需求，而且没有执行次序导致的问题UPDATE EMPSET SAL = CASE WHEN SAL &gt;= 3000 THEN SAL * 1.02 WHEN SAL &gt;= 2000 THEN SAL * 1.03 ELSE SAL * 1.05 END case分支结构不止可以用在update子句中，在select子句中也是有的 视图啊啊啊啊啊，这个内容还不是三言两语讲的玩的，下次吧下次吧。&gt;.&lt;]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（六）]]></title>
    <url>%2F2017%2F09%2F26%2F2017-09-26-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章(第三章的多表部分会挪到这一部分讲)笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们继续延用之前用的表(为了演示方便，我们在EMP表中多插入了一条数据，这个数据的部门号是空值)，用于演示下面的例子(´`) FROM 中的子查询由于FROM中的子查询涉及到多表的操作，所以准备放在后面讲，先在此处做个小提示，等学完多表操作后，会回来提这个，到时候我会在这边贴一个链接 多表查询中的笛卡尔积（全匹配问题） 如果在进行多表查询操作时没有连接条件 ，则会进行全匹配，结果集相当于两个表进行笛卡尔积 举个栗子1234-- 下面的操作本来是想输出所有的员工的姓名以及其所在的部门名-- 但是由于没有指定连接条件，所以结果将会是每一个员工与每一个部门组合的结果SELECT ENAME, DNAMEFROM EMP, DEPT; 结果如下(结果太多了，总共有52条，下面的图片中只截取了前面的一部分)： 在实际开发过程中笛卡尔积得到的结果一般是没有太大意义的，所以应当尽量避免==&gt;添加连接条件(WHERE emp.deptno = dept.deptno) 举个栗子：1234-- 这个栗子就基本完成了上面的需求SELECT ENAME, DNAMEFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 但是仔细观察会发现，上面的数据只有13条，而员工表里面的数据有14条，其中Sunny所在部门号为空值，在部门表中匹配不到结果，故没有出现在结果集当中。（这是因为采用内连接的缘故，下面将会对内外连接分别做分析） 在WHERE子句中书写连接条件的内连接这种在where子句中写连接条件的实现方式，不是SQL标准中的标准用法，但是大多数数据库都支持这种用法，所以这种用法已经成了一种事实标准。在内连接的范畴中，这种用法与SQL标准的内连接用法是等价的 等值内连 上述那个例子就是最常见的等值内连 123SELECT ENAME, DNAMEFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 等值内连就是在where中书写多表的连接条件的时候比较两个表中某一个或多个字段的值，值相等的则匹配（常见的就是用一个表的外键与另一个表中对应的外键的参照键进行比较） 必须是两张表中能够满足连接条件的数据才会出现在结果集当中（不单是等值连接，下面讲的非等值连接也是，所有内连接都应该瞒住这个） 再来举个上面举过的栗子1234-- 下面的操作得到了所有员工的名字以及其所在部门的名字SELECT ENAME, DNAMEFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 我们发现员工名为Sunny的员工数据和部门号为40的部门数据都没有出现在结果集当中。因为Sunny的部门号为空值，不等于部门表中任意一行数据的部门号，故找不到匹配；因为在员工表中没有员工的部门号为40，所以部门号为40的部门也没有出现在结果集当中。（只有满足连接条件，并且成功找到匹配的数据才会出现杂结果集当中） 这种用where书写的多表连接语句等价于SQL标准中的内连接（inner join） 上面的语句也可以写成下面这种形式1234567891011-- 下面的语句和上面例子中的语句是等价的SELECT ENAME, DNAMEFROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO-- SQL标准中还有下面这种用法（课本上有提到，但是显然SQL Server不支持这种用法）-- 表示的是利用DEPNOT这个字段来进行两表的连接（前提是这两个表中要有同名字段）-- 如果支持这种用法的数据库执行下面操作的话得到的结果和上面的是一样的（经验证，MySQL数据库是支持这种用法的）SELECT ENAME, DNAMEFROM EMP INNER JOIN DEPT USING(DEPNOT) 对于两表中的同名字段，在使用的时候必须用表名或者表别名加以限定，不然SQL语句会有歧义，导致无法正确被解析 举个栗子1234567891011121314151617181920-- 我们想在上面例子的基础上，多显示一个部门号-- 如果写成下面这样，就会报错，因为SQL解析器不知道DEPTNO指的是EMP表的还是DEPT表的SELECT ENAME, DNAME, DEPNOTFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO;-- 正确的写法应该是这样的SELECT ENAME, DNAME, EMP.DEPTNOFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO;--当然也可以用DEPT来限定SELECT ENAME, DNAME, DEPT.DEPTNOFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO;-- 不过最好用表别名来限定，比较简洁一点SELECT ENAME, DNAME, e.DEPTNOFROM EMP e, DEPT dWHERE EMP.DEPTNO = DEPT.DEPTNO; 如果对一个表起了别名之后就不能再使用原表名了，而要换成其别名 举个栗子1234-- 下面这个语句执行的话是要报大错滴，因为已经给EMP表起了别名e，就不能再用原表名EMP了SELECT ENAME, DNAME, EMP.DEPTNOFROM EMP e, DEPT dWHERE EMP.DEPTNO = DEPT.DEPTNO; 如果再考虑效率问题，在进行多表操作时，最好所有字段都用表名或者表别名限定，这样可以免去SQL解析器帮你分析某个字段属于哪个表的开销，可以在一定程度上提高执行效率 举个栗子123SELECT e.ENAME, d.DNAME, e.DEPTNOFROM EMP e, DEPT dWHERE EMP.DEPTNO = DEPT.DEPTNO; 不等值连接 举个栗子1234-- 下面的语句就查处了所有员工的姓名、工资、以及其工资等级SELECT e.ENAME, e.SAL, g.GRADEFROM EMP e, SALGRADE gWHERE e.SAL &gt;= g.LOSAL AND e.SAL &lt;= g.HISAL; 得到如下结果： 不等值连接就是内连接中除了通过比较值相同来进行连接以外的其他内连接操作 n个表相连，至少需要n-1个连接条件，要不然就会在连接过程中出现笛卡尔积 多表的连接条件一般都是建立在外键和外键的参照键之间，采用等值连接 SQL内连接的标准写法 JOIN … ON … 举个栗子123456-- 下面的语句就是SQL标准中多表内连接的写法SELECT *FROM TABLE1 t1 JOIN TABLE2 t2 ON ... JOIN TABLE3 t3 ON ... JOIN TABLE4 t4 ON ... 外连接内连接的结果是外连接结果的一个子集，外连接的结果中还可以包括只在一张表中出现，并且在另一张表种找不到匹配的结果 左外连接(LEFT OUTER JOIN) 包含JOIN关键字左表中的所有数据（即便某个数据在右表中找不到匹配） 举个栗子123456-- 下面的语句与上面的例子类似-- 同样是得到所有员工的名字以及其所在部门名-- 不同的是采用左外连接以后Suuny的数据会出现在结果集中了SELECT ENAME, DNAMEFROM EMP LEFT OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 右外连接(RIGHT OUTER JOIN) 包含JOIN关键字右表中的所有数据(即便某个数据在左表中找不到匹配 举个栗子12345-- 还是这个栗子，但不同的是我们把LEFT改成了RIGHT-- 会发现，部门号为40的部门信息显示出来了SELECT ENAME, DNAMEFROM EMP RIGHT OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 对比可以发现左外连接和右外连接的效用其实是一样的，只要吧JOIN两边表的位置对调一下，两者就可相互转换。（使用时随意，习惯怎么用就怎么用就好） 全外连接 JOIN关键字两边的表的所有数据都会出现在结果集当中，得到的结果其实就是左外连接和右外连接结果集的并集 举个栗子：123SELECT ENAME, DNAMEFROM EMP FULL OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 在进行多表连接的时候采用WHERE和ON的区别 其一，在进行外连接的时候，必须用ON 举个栗子 12345678910-- 下面的语句做了简单的外连接操作SELECT *FROM EMP LEFT OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO;-- 下面的语句执行是会报错的，因为没有加onSELECT *FROM EMP LEFT OUTER JOIN DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 其二，如果在on子句中指定连接条件，并在where子句中出现其余条件，这样的SQL插叙通常更容易让人读懂 所以在执行内连接的时候，on和where的使用是没有多大区别的，但是在执行外连接的时候就必须用on了。所以建议就是在on子句中指定连接条件，并在where子句中出现其余条件]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（五）]]></title>
    <url>%2F2017%2F09%2F22%2F2017-09-22-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章(第三章部分的多表操作没有在此处讲，准备挪到第四章再一起讨论)笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们先构造一组表，用于演示下面的例子(´`) Having 子句由于where子句中不能用聚合函数（组函数）做条件，故引入having子句 让我们先看一下各个子句的书写顺序（下面的只是我们一般在写SQL语句时候的书写顺序） SELECT FROM WHERE GROUP BY HAVING ORDER BY 上面各子句的执行顺序：FROM–&gt;WHERE– &gt; GROUP BY–&gt; HAVING–&gt;SELECT–&gt;ORDER BY 其中上面除了GROUP BY和HAVING可以互换位置外，其他位置均固定，但最好采用上面的顺序 从上面的讨论中可以看出 HAVING一般紧随GROUP BY之后，置于ORDER BY之前 而且当聚集函数（组函数）做条件时，只用用HAVING来处理 举个栗子：求所有平均工资大于2000的部门的部门号以及该部门的平均工资 先来看看每个部门的平均工资 123SELECT DEPTNO, avg(SAL) as avg_salFROM EMPGROUP BY DEPTNO 得到如下结果 接下来开始求题设的问题 1234SELECT DEPTNO, avg(SAL) as avg_salFROM EMPGROUP BY DEPTNOHAVING avg(SAL) &gt; 2000; 得到如下结果 聚合函数的嵌套 不同数据库对聚集函数嵌套的规定不同 Oracle数据库规定最多只能有两层嵌套 SQL Server不允许聚集函数嵌套 举个栗子： 1234567--下面的语句在Oracle数据库中执行是可以的SELECT max(avg(sal))FROM EMPGROUP BY deptno--上面的语句在SQL Server中执行会报下面的错[S0001][130] 不能对包含聚合或子查询的表达式执行聚合函数。 ┐(´•_•`)┌ 实际上二层以上的嵌套也是毫无意义的（只是瞎哔哔，不是什么重点，有助于理解为什么聚集函数多层嵌套是没有意义的） 首先回忆一下，聚集函数的操作是多行输入，得到一行输出 举个栗子 123SELECT max(max(avg(sal)))FROM EMPGROUP BY deptno 现在来分析上面语句执行的过程 （avg）首先根据部门号deptno分成若干组，并计算每组的平均工资（返回若干条记录） （max）然后取各部门最高的平均工资（返回一条记录） （max）这个时候只有一条记录，取最大值也还是那一条记录 子查询这部分是重点也是难点呀٩(๑`^´๑)۶，不用担心，让笔者带你细细解剖(≖_≖ )这部分参考了两份笔记和课本 嵌套子查询即SQL标准提供嵌套子查询机制，允许将一个完整的select-from-where查询表达式嵌入到另一个查询语句中 子查询嵌套在where和having子句中的情况（把子查询整体当做一组值，可以是0个，1个，或多个） 单行子查询 在单行子查询中，子查询语句只能返回一行数据 当where子句中用下列逻辑符号连接子查询时，便只能连接单行子查询 = &lt; > &lt;= >= &lt;&gt; 举个栗子(≖_≖ ) 我们现在要找所有员工中，拿到最高工资的人的名字以及工资1234SELECT ENAME, SALFROM EMPWHERE SAL = (SELECT max(SAL) FROM EMP); 得到如下结果 多行子查询 多行子查询中，子查询语句可以返回多行数据 当where子句中用下列关键字连接子查询时，便是多行子查询($代表上面提到的=, &gt;等符号) $ any/some $ all 举几个简单的栗子 &lt; any(…) 表示小于子查询结果集中的最大值 > any(…) 表示大于子查询结果集中的最小值 = any(…) 等价于in = all(…) 没有语法错误，但是只要子查询结果集的个数大于1，则整体的结果必然为空 &lt; all(…) 表示小于子查询结果集中的最小值 > all(…) 表示大于子查询结果集中的最大值 来举个正经的栗子 求比部门号为20的部门的所有员工的工资都要高的员工的名字和工资12345SELECT ENAME, SALFROM EMPWHERE SAL &gt; SOME (SELECT SAL FROM EMP WHERE DEPTNO = 10); 得到如下结果 还有一个要注意的问题(ㅍ_ㅍ)，就是子查询中SELECT后面的字段要根据主查询语句中的字段来确定（简单的说就是子查询语句前面，where后面，出现了什么字段，子查询语句的SELECT列表中理论上就应该出现这些字段） 举个栗子 12345678910111213--下面这个语句是匹配的SELECT ENAME, SALFROM EMPWHERE SAL &gt; SOME (SELECT SAL FROM EMP WHERE DEPTNO = 10);--下面这个语句就不匹配的--因为ENAM并没有出现在主查询语句中SELECT ENAME, SALFROM EMPWHERE SAL &gt; SOME (SELECT ENAME, SAL FROM EMP WHERE DEPTNO = 10); 其实换个角度想想，具体执行的时候是将where后面的字段与子查询语句的结果集进行比较，如果字段都不一样，就没有可比性了 对了，还有一个补充，not in + 子查询，如果子查询的结果集中包含NULL值，那整体的结果必为空。因为NULL值是不确定的值，谁也不能保证某个具体的值是否等于NULL。。。 子查询中存在性的判别可以用exists关键字 举个栗子就好1234567--下面的语句就查出了所有手底下管了人的经理的信息--其实这里已经用到了相关子查询，具体的下面将会讲到SELECT *FROM EMP as eWHERE exists(SELECT 1 FROM EMP WHERE EMP.MGR = e.EMPNO); 试思考下面两个问题，根据提示理解一下，也可以实际操作验证一下 =some 等价于 in， 然而 &lt;&gt;some不等价于not in（&lt;&gt;some表示的是只要不等于结果集中的任意元素即可，可想而知，只要结果集中有大于一个元素，这个条件是恒成立的） &lt;&gt;all 等价于 not in，然而=all不等价于in 相关子查询 慎用，因为一旦使用相关子查询，子查询语句可能会被执行很多次，很影响效率 举个栗子 123456789--下面的语句找出了所有比自己部门平均工资高的员工的信息--检索时，每检索一行数据，子查询语句就要被执行一次--（因为该子查询语句只有在某个具体的部门号下才会有结果--而，要获取部门号，就必须依赖于主查询语句中的某行具体数据）SELECT ENAME, SAL, DEPTNOFROM EMP eWHERE SAL &gt; (SELECT avg(EMP.SAL) FROM EMP WHERE e.DEPTNO = EMP.DEPTNO); 举个上面举过的栗子 1234567--下面的语句就查出了所有手底下管了人的经理的信息--用exists时，只要找到数据即会返回，不会继续向下检索SELECT *FROM EMP as eWHERE exists(SELECT 1 FROM EMP WHERE EMP.MGR = e.EMPNO); 由于exists会在找到数据后立即返回，而不是继续向下检索，所以用exists的相关子查询效率会稍微高一丢丢 可以自己验证一下下面结论 not exists 不受空值的影响 not in 受空值的影响]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（四）]]></title>
    <url>%2F2017%2F09%2F19%2F2017-09-19-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章(第三章部分的多表操作没有在此处讲，准备挪到第四章再一起讨论)下面的例子中的测试都是在MySQL数据库中测试的 集合运算此处集合运算的概念与数学中集合的概念类似，可以借助文氏图加深理解。故此处对并运算进行展开，其他啊两个自己类比，后面还会对集合运算的几个注意点进提醒。 union(集合并运算) union 默认去除重复，并升序排序（因为涉及到排序，故而会有效率上的劣势） union all 就可保留重复项，并且保留原序（不进行排序） 举个栗子（现有两张表如下） |stu_name |age | score ||:——-:|:—:| :—–:||Sunny| 18| 98||Robbin| 18 |96||James| 19| 67||Jane| 17| 82|Student表信息如上 |tech_name |age ||:——-:|:—:||James |32||Marry |33||Lory |33|Teacher表的信息如上 执行以下运算 12345SELECT ageFROM StudentUNIONSELECT ageFROM Teacher 得到如下结果(得到的结果没有重复元素，但是没有排序，说明MySQL数据库在此处没有对其进行排序输出，但是Oracle数据库是会对数据进行升序排序的) |age ||:——-:||18||19||17||32||33| 执行以下运算 12345SELECT ageFROM StudentUNION ALLSELECT ageFROM Teacher 得到如下结果(可以知道，UNION ALL 保留了重复元素) |age ||:——-:||18||18||19||17||32||33||33| intersect(集合交运算) except(集合差运算) Note: 参与集合运算的两个视图的列数要一致 举个栗子1234567-- 下面的语句执行就会出错-- 因为第一个视图有两个字段，而第二个视图只有一个字段，无法进行集合运算SELECT age, scoreFROM StudentUNION ALLSELECT ageFROM Teacher 参与集合运算的两个视图对应位置的字段的数据类型应该是一致的（数据类型兼容即可，字段名无需一致） 举个栗子 1234567-- 按上面的说法下面语句执行是非法的-- 因为第二个字段的数据类型不兼容，一个是浮点型，一个是字符串类型SELECT age, scoreFROM StudentUNION ALLSELECT age, tech_nameFROM Teacher 上面的书法在Oracle数据库里得到了证实，确实执行是会报错的，那MySQL数据库呢？我们执行以下，得到以下结果 |age |score ||:——-:|:—:||18 |98||18 |||19 |67||17 |82||32 |James||33 |Marry||33 |Lory|说明该写法在Mysql里面竟然是合法的（所以所有的特性都要视不同的数据库，视情况而分析） 若无字段可加，又需保证列数相同，可控NULL做填充 举个栗子 12345SELECT age, scoreFROM StudentUNION ALLSELECT age, NULLFROM Teacher 得到如下结果哦 |age |score ||:——-:|:—:||18 |98||18 |||19 |67||17 |82||32 |||33 |||33 || 集合运算的结果视图的字段名以第一个结果集的字段名为主 举个栗子 12345SELECT stu_nameFROM StudentUNIONSELECT tech_nameFROM Teacher 得到如下结果： |stu_name ||:——-:||Sunny||Robbin||Marry||Lory||Jane||James| Oracle数据库中，差运算不是except， 而是minus；Oracle数据库union可以后面跟all， 但是interscet和minus后面不可以（不同数据库不同） 空值NULL NULL就是不确定的值，参与数值运算和字符串运算时，不同的数据库采取的处理不同； Oracle 数据库中，NULL无论参与数值运算还是字符串运算，都会使整体为NULL 获取系统时间 Oracle数据库的查询语句必须有from 故采用如下方法获取系统时间 1234-- 其中dual是Oracle数据库系统自带的一行一列的表-- 其他数据库没有这个表SELECT SYSDATEFROM dual MySQL就没有这个限制 12-- 在MySQL和SQL Server中用下面的语句就可获得系统时间SELECT SYSDATE 日期类型的运算 可与数值类型做加减运算（在Oracle数据库里面单位为天，·.·在MySQL里面竟然是秒） 举个栗子（MySQL里面测试） 1SELECT SYSDATE() - 1, SYSDATE(), SYSDATE() + 1 得到如下结果 |’SYSDATE() - 1’ |’SYSDATE()’ | ‘SYSDATE() + 1’ ||:——-:|:—:| :—–:||20170919183000 |2017-09-19 18:30:01| 20170919183002| 可与日期类型做减运算，得到连个日期之前的差值 不可与日期类型做加运算（在Oracle数据库执行日期间加运算直接报错，Mysql数据库直接真的返回两个日期加以后的值，不过巨耗时，mmp） 与NULL值运算得NULL值（在Oracle和MySQL上测试结果都正确） where 子句，判断是否为空 用is NULL 和 is not NULL 判断 而不用 = NULL 和 != NULL 布尔变量有三个取值：TRUE，FALSE, NULL 三种取值以and，or相连时的结果，与并联串联电路的判断类 TRUE and NULL = NULL TRUE OR NULL = TRUE FALSE and NULL = FALSE FALSE OR NULL = NULL 举个栗子12345-- 下面的语句将会返回Student表中的所有信息-- 因为where子句后面的条件为真SELECT *FROM StudentWHERE TRUE OR NULL 去重关键字 distinct 跟在SELECT的后面，并且置于所有字段的前面 会将其后的字段都作为判断重复的条件 举个栗子123-- 下面的语句就是列出学生表中的数据，并去除stu_name和age都相同的数据重复SELECT DISTINCT stu_name, ageFROM Student 聚集函数（Aggregate Functions）多行输入，一行输出 此类函数有MIN，MAX，COUNT，AVG，SUM。其中AVG和SUM只能参与数值运算 聚集函数在使用时会忽略空值NULL 除了COUNT(*)，COUNT(*)在统计的时候是不忽略空值的 Count 在计数时，忽略空值项 默认是统计重复项的，其中ALL是默认的，顾可以不显示指明 1COUNT(ALL age) 如果统计去除重复以后的结果,可如下面写法 1COUNT(DISTINCT age) Oracle中用作对null值数据处理的函数nvl 123# 下面的语句表示对数据表中的分数做加和，如果遇到为空的项，则取其值为0SELECT SUM(NVL(score, 0))FROM Student COUNT(*)==&gt;可返回满足where子句条件的所有数据的数量 这是COUNT独有的用法，其他聚集函数里面只能放字段或表达式 SUM SUM(age) + SUM(score) &gt;= SUM(age + score) 因为聚集函数在使用时会忽略空值，而NULL值直接参与运算可能会导致整体为空，顾有上述结论 当且仅当数据中没有空值时，上述等号成立 分组聚集（Aggregation） GROUP BY 字段序列 GROUP BY 后面跟的字段序列作为分组条件，值相同的为一组 可以是多个字段（顺序不影响结果） 当SELECT列表中出现了聚集函数，select中能出现以下字段 可以放group by 后面的字段 可以放聚集函数处理了的字段或表达式 上面两种情况下的字段在每组的取值都是唯一的，故而可以保证结果集中每一项的行数是一致的 having， 解决where子句中不能包含聚集函数的问题 传送门]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（三）]]></title>
    <url>%2F2017%2F09%2F16%2F2017-09-16-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章(第三章部分的多表操作没有在此处讲，准备挪到第四章再一起讨论) SELECT * 与 SELECT 全字段 的执 行效率是有差别的 数据库在具体执行 SELECT * 的时候可以这样理解：首先把 * 替换成对应表的全字段序列，再执行。故在执行的的时候 SELECT * 的效率是会更低的 事实上 SELECT * 也是典型的低效语句 故在实际应用过程中应该尽量避免使用 SELECT * where子句 and、or、not的优先级顺序 or &lt; and &lt; not (not的优先级最高) 例如：我们要实现“年龄小于16或大于18，并且分数不小于60的所有学生” 于是写出了 123where age &gt; 18or age &lt; 16and not score &lt; 60 上面的语句实际表示的是: 分数不小于60并且年龄小于16，或者年龄大于18 实际使用的时候不要依赖于它们的优先级顺序！！ 上面的需求可用下面的语句实现：12where (age &gt; 18 or age &lt; 16)and score &gt;= 60 SQL 附加的基本运算 更名运算 as |stu_name |age | score ||:——-:|:—:| :—–:||stu1 | 18| 98|首先存在如上表结构 需要事先申明的是，这里所说的更名并不是实际更改数据库中的表结构，更改只是在执行查询操作的过程中得到的结果视图 as 关键字可用于SELECT语句中给字段更名 执行如下语句： 12SELECT stu_name as student_name, age, scoreFROM Student 得到如下结果 |student_name |age | score ||:——-:|:—:| :—–:||stu1 | 18| 98| as 关键字可用于FROM语句中给表更名 as可以把一个长的关系名替换成短的，这样在查询语句的其他地方用到这个关系名的时候就会方便不少 执行如下语句 1234567-- 下面两个语句实现的效果是一样的,但是显然第二种比较简洁SELECT Student.stu_name, Student.ageFROM StudentSELECT S.stu_name, S.ageFROM Student as S 还有一种情况需要用as修改表名，就是需要比较同一个关系中的元组的时候，必须要用别名，要不然无法区分 |stu_name |age | score ||:——-:|:—:| :—–:||Sunny| 18| 98||Robbin| 18 |96||James| 19| 67||Jane| 17| 82|现在表中有如上数据 我们需要查询表中所有比Jane的成绩高的学生的名字 则可以用下面的语句实现： 123SELECT T.stu_nameFROM Student as T, Student as SWHERE T.score &gt; S.score and S.stu_name = 'Jane' 得到以下结果 |stu_name ||:——-:||Sunny||Robbin| 大多数数据库中可以用空格替代as 12345678-- 下面两个语句是等价的（在Mysql数据库上测试）SELECT T.stu_nameFROM Student as T, Student as SWHERE T.score &gt; S.score and S.stu_name = 'Jane'SELECT T.stu_nameFROM Student T, Student SWHERE T.score &gt; S.score and S.stu_name = 'Jane' 注意：Oracle数据库更改表的别名不能用 as（但是改字段的别名是可以用as的）， 只能用空格，要不然会报错（比如上面的两个语句在大多数数据库执行都是可以通过而且结果一致的，但是在Oracle数据库第一条语句就不会过）** 如果别名中带空格，则别名需要用双引号引起来（因为空格也是可以替代as的，所以如果别名中含有空格而不做处理，可能会导致数据库无法解析这条语句） 首先看下面这条语句 123-- 下面这条语句想给Student表起一个别名，叫做 Student Info, 执行是会失败的SELECT Student Info.stu_nameFROM Student as Student Info 正确的操作应该是这样的 12SELECT "Student Info".stu_nameFROM Student as "Student Info" 字符串的拼接运算 不用数据库采用不同的运算符，常见的有 || 和 + |stu_name |age | score ||:——-:|:—:| :—–:||Sunny| 18| 98||Robbin| 18 |96||James| 19| 67||Jane| 17| 82|现在表中有如上数据 执行下面的语句(笔者是在Mysql下测试的，Mysql的字符串拼接是用connect函数实现的，所以略有不同) 12SELECT S.stu_name, concat('name: ', S.stu_name) as infoFROM Student as S 得到如下结果 |stu_name | info||:——-:|:—:||Sunny |name: Sunny||Robbin| name: Robbin||James |name: James||Jane |name: Jane| 对于null值的处理，不同的数据库采取的处理不同 Oracle会直接忽略空值，而DB2会使整体为null 下面在Mysql中测试与空值拼接，结果是会使整体为null 执行以下语句 12SELECT S.stu_name, concat('name: ', S.stu_name, NULL ) as infoFROM Student as S 结果如下 |stu_name | info||:——-:|:—:||Sunny |null||Robbin| null||James |null||Jane |null| 可以与字符串常量拼接 sql里面就用一对单引号包含一个字符串表示字符串常量，如’name: ‘ 上面的例子里面就用到了与字符串常量拼接，这里就不再赘述了 如果字符串常量里面需要包含单引号，可以用另一个单引号来转义 比如执行下面的语句 123# 下面的字符串常量中出现了四个单引号，其中首位两个是用来标示这个是一个字符串常量，第二个单引号是用来转义第三个单引号SELECT S.stu_name, concat('I''m ', S.stu_name) as infoFROM Student as S 结果如下： |stu_name | info||:——-:|:—:||Sunny |I’m Sunny||Robbin| I’m Robbin||James |I’m James||Jane |I’m Jane| 函数 其实函数每个数据库都有各自的实现，种类和功能不尽相同 比如上面的connect函数是Mysql中的一个函数 upper(s)和lower（s）函数是用来将字符串全部变成大写/小写的函数 模糊匹配（like） 通配符（具体到某个具体的数据库可能还会有功能更强大的通配符，这里只讨论比较通用的两个） % ==&gt;匹配任意长度的字符串（字符串的长度也可以是0） _ ==&gt;匹配一个字符 举个栗子：12345-- 下面的语句标示查询条件是第三个字符是A的stu_nameWHERE stu_name LIKE '__A%'-- 下面的语句标示查询条件是第三个字符是A，且长度至少为4的stu_nameWHERE stu_name LIKE '__A_%' |stu_name |age | score ||:——-:|:—:| :—–:||Sunny| 18| 98||Robbin| 18 |96||James| 19| 67||Jane| 17| 82|现在表中还是有如上数据 执行下面操作 1234-- 下面的语句用来查询表中stu_name的值为Ja开头，且至少长度为三的所有学生名字SELECT stu_nameFROM StudentWHERE stu_name LIKE 'Ja_%' 得到如下结果 |stu_name ||:——-:||James||Jane| 如果模式串（我们这里称like后面的串为模式串）中需要包含‘_’或者‘%’等通配符关键字，就需要用到转义，SQL里面用escape来指定转义字符 举个栗子：123-- 下面的语句在最后面定义‘\’为转义字符-- 所以实际的效果是匹配所有以 Ja_ 开头的 stu_nameWHERE stu_name LIKE 'Ja\_%' escape '\' 排序（order by） 如果没有显示指定升序还是降序，则默认是采用升序的 null 值的处理（不同的数据库采取的处理不同） Oracle 将null值当做最大 SQL Server 将null值当做最小 接下来来去测测Mysql数据库 |stu_name |age | score ||:——-:|:—:| :—–:||Sunny| 18| 98||Robbin| 18 |||James| 19| 67||Jane| 17| 82|首先表中的数据是上面酱紫的 然后执行下面操作 12345-- 下面的语句查询学生表中的所有数据，并按成绩排序（因为没有指定-- 升序还是降序，所以默认是升序的）SELECT *FROM StudentORDER BY score; 结果如下（可以看出，Mysql是将null值当做最小值） |stu_name |age | score ||:——-:|:—:| :—–:||Robbin| 18 |||James| 19| 67||Jane| 17| 82||Sunny| 18| 98| 在排序的时候可以用desc显示指定降序，asc显示指定升序 举个栗子 12-- 下面的排序条件标示先按score降序排序，如果遇到score相同的，则按age升序排序ORDER BY score desc, age asc order by 后面所跟字段，以在前面的字段为主进行排序 desc、asc 更在字段名或表达式后面，并且只能影响其前面的一个字段 举个栗子123-- 下面的排序条件表示，先以score进行升序排序（因为未指定的话默认是升序的），-- 如果遇到score相同的再按age进行降序排序order by score, age desc order by 后面可跟别名，字段名，表达式，字段的顺序号 别名、字段名 表达式 举个栗子12-- 下面排序条件标示把sal*12后按结果降序排序order by 12 * sal desc 字段的顺序号： 举个栗子1234-- 下面这条语句标示查询Sudent表中的所有数据，并按age和score进行升序排序（默认是升序排序）SELECT student_name, age, scoreFROM StudentORDER BY 2, 3 如果要查询的结果集是很大的，排序是很耗时的，会影响性能 where子句beween…and、in between…and（表示一个连续的范围） between a and b &lt;==&gt; a &lt;= x &lt;= b not between a and b &lt;==&gt; x &gt; b | x &lt; a 写的时候，小数写在前面，大数写在后面 in（表示离散的范围） 举个栗子1234# 下面的语句表示查询分数为98、99或者100的学生的信息SELECT student_name, age, scoreFROM Studentwhere score in (98, 99, 100)]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java环境简单配置+IDEA（小白版）]]></title>
    <url>%2F2017%2F09%2F16%2F2017-09-16-Java%E7%8E%AF%E5%A2%83%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2BIDEA%EF%BC%88%E5%B0%8F%E7%99%BD%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JDK配置 首先到官网下载最新版JDK：Oracle官网下载 Accept License Agreement–&gt;下载适合自己pc版本的jdk（此处以64位windows为例。x86是32位，x64是64位） 开始安装JDK 选择安装路径，可以不安装在C盘，记住安装到哪就行了，默认也行，我安装在（C:\Program Files\Java\jdk1.8.0_131） 安装过程中会跳出Jre的安装界面，你可以放到和之前JDK在同一个文件夹下，也可默认。然后直接下一步开始安装 环境变量配置 右击我的电脑–&gt;属性–&gt;高级系统设置–&gt;环境变量 新建环境变量，变量名为：JAVA_HOME，变量值为之前JDK的安装路径，此处安装在：C:\Program Files\Java\jdk1.8.0_131（可以在系统变量下新建，这样可以为每个登录该pc的用户都配置，如果在用户变量中新建，则只为当前用户配置，此处以在系统变量下新建为例） 找到Path变量–&gt;编辑 如果是win10系统，则进入后界面如下，选择新建两个环境变量，一个值为：%JAVA_HOME%\bin另一个为：%JAVA_HOME%\jre\bin（此处笔者已经配置好）配置好就如下图 如果是win7及之前的系统则进入后界面如下:在变量值最后输入 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;（注意原来Path的变量值末尾有没有;号，如果没有，先输入；号再输入上面的代码） 验证一下^-^ win + R–&gt;输入cmd，进入cmd命令行 输入：java -version 就可以查看版本信息，如果显示如下信息，则表示环境配置成功 到这里我们就可以骚操作一波，用记事本写简单Java程序（纯属骚操作，如果用IDE开发（比如我们接下来的部分要介绍的重头戏，用IDEA实现真正的骚操作）可不看这个hhhhhh，如果不想使用IDE开发的话，建议可以使用NotePad++、sublimeText或Atom进行代码编辑，不过真想用记事本敲也无可厚非） 新建一个文本文档，并修改后缀为.java修改以后如下：如果没有显示后缀名，则可通过如下方式修改： 用记事本打开，输入以下代码：12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;Oh, balabala&quot;); &#125;&#125; 直接在创建文件的文件夹下按住Shift + 右键，选择在此处打开命令窗口（环境变量的配置使得用户可以在任意目录下调用javac 和java 命令）输入：javac Hello.java （用于编译java源程序）java Hello（运行java程序） 自此JDK的配置就OK了，可以开始Java从入门到放弃的修炼了~~ 极其好用的IDE–&gt;IDEAps:如果在打开IDEA之前没有下载好JDK的道友，请先往上看详细步骤 先来一波官网的下载链接：IDEA官网下载地址我们下载社区版（别问为啥，社区版免费，如果下载左边的旗舰版也行，但是需要注册码，之前有个网上长期流传的获取注册码的路子，现在貌似不好用了，如果道友是学生就可以用学校给的邮箱百度“IDEA学生”去注册一个IDEA的学生账号（学生账号有自己的注册码，有效期为1年），如果不是就买或者用社区版吧）： 第二步我们来开始安装： 选择安装路径： 上面的是创建桌面图标，选择自己电脑对应的版本就行了；下面的可以全选，表示什么格式的文件可直接关联到IDEA，用IDEA来打开 下一步直接install 启动刚安装好的IDEA 如果第一次安装，就直接不导入设置，ok 选个喜欢的主题（此处笔者选这骚气黑），然后next 直接next 直接start 接下来新建一个项目练练手 create a project 如果显示NO SDK， 找到之前安装的JDK所在路径，然后next next 第二行选择项目的存放路径，第一行给项目取个名字，然后Finish 右击src文件夹–&gt;new–&gt;java class 给类取个名字，ok 输入以下代码：12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;Oh, balabala&quot;); &#125;&#125; 运行程序：运行成功，开始你的表演：]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（一）]]></title>
    <url>%2F2017%2F09%2F12%2F2017-09-12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL教程 DBS（Database System） 传统的文件处理系统中存储组织信息的主要弊端 数据的冗余和不一致性（data redundancy and inconsistency） 数据访问困难（dificulty in accessing data） 数据孤立（data isolation） 完整性问题（integrity problem） 原子性问题（atomicity problem） 并发访问异常（concurrent-access anomaly） 安全性问题（security problem） 数据库系统的目标：提供一种可以方便高效地存取数据库信息的途径 数据视图数据库系统的一个主要目的是给用户提供数据的抽象视图，也就是说隐藏关于数据存储和维护的某些细节 数据抽象 物理层（physical level） 最低层次的抽象 描述了数据实际上是怎么存的（比如是都存在一个文件里还是分散在多个文件里） 逻辑层（logical level） 比物理层层次稍高的抽象 描述了数据库中存什么数据以及数据之间的关系 逻辑层的用户不需要去关系数据具体是怎么存的，这称作物理数据独立性（physical data independence） ps: 对于具有物理数据独立性的设计，即便底层的物理存储改变了，逻辑层也不需要做任何的修改 视图层（view level） 最高层次的抽象，只描述整个数据库的某个部分 简而言之，对于逻辑层的数据，我们可以通过不同的视图，以不同的视角以及视野去查看它 实例和模式 类比：模式类比于变量的声明，实例类比于变量在特定时刻的值 模式： 数据库的总体设计 数据库的模式限定了数据库中都有哪些表，表中都有哪些字段以及表与表之间的关系 实例： 特定时刻存储在数据库中的信息的集合 数据库的一个实例包含了数据库在一个时刻下的所有表的信息 数据模型 关系模型 实体—联系模型 基于对象的数据模型 半结构化的模型 网状数据模型 层次数据模型 关系型数据库的一些基本术语 relation（关系）==&gt;表 column（列）==&gt;字段（同一字段内所有数据的数据类型一致） row（行）==&gt;对应于数据库表中的一行数据（对应于数学概念中的元组） SQL（Structured Query Language）==&gt;结构化的查询语言 DDL：Data Define Language（数据定义语言）==&gt;执行 该类SQL语句会导致表结构的变化 DML：Data Manipulation Language（数据操纵（管理）语言）==&gt;执行该类SQL语句对表中的数据进行增删改查 查询语言（query language）：DML中涉及信息检索的部分称之为查询语言 tuple（元组）==&gt;对应于数据表中的一行数据 domain（域）==&gt;字段的取值范围 schema（方案/模式）==&gt;数据库中的Schema，为数据库对象的集合，一个用户一般对应一个schema Cartesian product（笛卡儿积） 百度百科对笛卡尔积的解释 一篇介绍笛卡儿积与数据库关联的博客 ps: 应当避免表与表之间相关联的时候采用全匹配（如果采用笛卡尔积的匹配方式即为全匹配） DDL （数据定义语言）数据库模式定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。一个数据库模式包含该数据库中所有实体的描述定义。DDL用来定义一个数据库的模式 执行此类语句会导致数据库结构的变化 create（创建一个表） 1234567-- 下面的语句创建了一个用户表，以id为主键，并添加了username和age字段CREATE TABLE User( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) DEFAULT "", age INT DEFAULT 18);CREATE UNIQUE INDEX User_id_uindex ON User (id); alter（修改表的结构） 12-- 下面的语句修改了user表的id属性ALTER TABLE user MODIFY id INT(11) unsigned NOT NULL AUTO_INCREMENT; drop（删除一张表） 12-- 下面的语句删除了为user表DROP TABLE demo.user; rename（用于对一张表的名字进行重命名） Oracle数据库将其划分到DDL SQL server数据库将其归到DML12-- 下面的语句将user表的表名改成new_userrename table user to new_user truncate（截断==&gt;用于删除数据表中的所有数据，但是保留表结构，不同公司的数据库实现的机制不同） DML数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令，因此有很多开发人员都把加上SQL的SELECT语句的四大指令以“CRUD”来称呼。 此类语句对数据进行增删改查（CRUD） insert 12-- 下面的语句往user用户表中插入一条记录INSERT into user(username, age) VALUES('Robbin', 18) update 12-- 下面的语句修改了user表中username为Robbin的表项（元组）的数据UPDATE user SET username = 'Robbin2', age = 17 WHERE username = 'Robbin' delete 12-- 下面的语句删除user表中username为Robbin2的表项（元组）DROP FROM user WHERE username = 'Robbin2' select DB2将select归到DML Oracle将select单独划为一类（因为select操作只是对数据库进行查询操作，没有实质改变数据库中的数据）12-- 下面的语句查询user表中的所有数据SELECT * FROM user DML和DDL的区别 DML语句支持回滚，采用事务，可以保证数据的一致性；而DDL语句采用隐式commit，是不支持回滚的（一旦执行就不可撤回） 四种SQL语句 Key（键/码） superkey（超码）==&gt;一个或多个字段的集合，可唯一标识一行数据 candidate keys（候选码）==&gt;最小的超码（即本集合为超码，且集合内除本身外的任何子集都不能作为超码） Primary key（主码/主键）==&gt;从候选码中选取一个作为主码（主键），可以由多个字段组成 Primary attribute（主属性）==&gt;包含于某个候选码的属性 Non-Prime attribute（非主属性）==&gt;不包含于某个候选码的属性 Note: 数据表中字段的个数是有限的 属性在元组中是无序的（但是设计的时候一般把主键放在前面） 设计字段的时候要保证字段的原子性 NULL==&gt;空值表示不确定的值，不代表0，也不代表空串]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（二）]]></title>
    <url>%2F2017%2F09%2F12%2F2017-09-12-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章 SQL的组成PS：其中DDL、DML、integrity有一些补充，剩下的几项都是课本内容，应该后面会讲到。现在就先放在那边吧 数据定义语言（Data-Definition Language， DDL） 提供定义关系模式，删除关系以及修改关系模式的命令 如create、drop、alter等执行以后会产生、销毁表（定义、删除关系模式）或改变表的结构（修改关系模式） 数据操纵语言（Data-Manipulation Language，DML） SQL DML提供从数据库中查询信息，以及在数据库中插入元组、删除元组、修改元组的能力 只是对表中数据的增删改查，并没有实际影响表的结构（即关系模式并没有改变，改变的只是表中的数据） 完整性约束（integrity） SQL DDL 会给每一个关系（每一张表）在定义或者修改的时候定义一定的完整性约束。之后所有的操作都应该满足这些约束，不满足的操作将不被允许执行 复习注释: 不过如果对违反约束的行为做了处理，有些违反约束的语句也是可以成功执行的。比如在定义外键的时候指定了级联删除，那么一旦删除语句违反了外键约束，数据库不是拒绝执行，而是级联删除相关数据 比如主键约束表示一个或多个字段唯一标识了一行数据，如果试图插入主键值相同的数据，就不会被允许 具体的下面会单独说明并举例 视图定义（view definition） SQL DDL 包括定义视图的命令 事务控制（transaction control） SQL包括定义事务的开始和结束的命令 嵌入式SQL和动态SQL（embedded SQL） 嵌入式和动态SQL定义SQL语句如何嵌入到通用编程语言，如C、C++、Java 授权 SQL DDL包括定义对关系和视图的访问权限的命令 基本类型这些基本数据类型不依赖于某一个具体的数据库，是SQL数据库通用的类型 char(n)——全称character 用户指定长度的字符串，所有取值的长度都固定为长度为n的char 比如身份证或者电话号码等长度固定的数据可以使用这个 一般实际用的较少 varchar(n)——全称character varying 可变长的字符串，n为串的最大允许长度 实际存的时候数据多长，就存多长，较省空间 实际应用中大多用varchar，而不是char int——integer 整数类型，没啥好讲的，Oj8k smallint 小整数类型 numeric(p, d) 定点数，这个数有p位数字，其中小数点右边有d位 例如，numberic(3, 1)可表示-99.9 ~ 99.9 下面在MySQL数据库上面的测试，举个栗子：(测试结果表明，如果定义numberic(3, 1), 则小数点前面有三位数时是无法插入的，如果小数点后面有多位小数，则通过四舍五入的方法只保留一位小数) 先简单定义一张Student表（没有定义主键，允许插入相同的数据） 123456-- 下面定义了一张学生表，其中grade的取值范围为-99.9 ~ 99.9（不合理的取值，只是为了测试）CREATE TABLE Student ( study_id VARCHAR(20) NOT NULL, age INTEGER DEFAULT 0, grade NUMERIC(3, 1)); 执行正常的插入操作 12345678910111213141516171819202122232425-- 下面两条插入语句都能正常执行，并且结果正确INSERT INTO Student(study_id, age, grade) VALUES ( '201590001', 18, 92.5)INSERT INTO Student(study_id, age, grade) VALUES ( '201590002', 18, -92.5)-- 执行下面一条插入操作，最后保存的记录是 -92.6，INSERT INTO Student(study_id, age, grade) VALUES ( '201590003', 18, -92.56)-- 执行下面一条插入操作，最后保存的记录是 -92.5，INSERT INTO Student(study_id, age, grade) VALUES ( '201590004', 18, -92.54)-- 下面的这条插入操作将会报错-- [22001][1264] Data truncation: Out of range value for column 'grade' at row 1INSERT INTO Student(study_id, age, grade) VALUES ( '201590005', 18, 192.5) 执行上面操作后的结果 study_id age grade 201590001 18 92.5 201590002 18 -92.5 201590003 18 -92.6 201590004 18 -92.5 real,double,precision 浮点数与双精度浮点数 float(n) 精度至少为n位的浮点数 Date, time, timestamp, interval 日期类型 SQL中的完整性约束下文中列举的只是部分简单约束，具体的会在后面的内容中讨论 先来简单聊一聊我对完整性约束的理解吧，其实数据库中的完整性约束讲起来就是数据库在定义一张表的时候，对其作出了一系列的约束（这些个约束可能影响一个或多个字段，甚至影响整个表结构）。如果后续的操作中（不管是DDL还是很DML），如果违背了之前定义的约束，（如果没有对违反约束行为做特殊的处理）这个操作就不会成功 primary key（A1, A2, …, An）——主键约束 该约束主要指定了以属性A1~An构成关系的主键，该主键值必须非空且唯一 即只要一个表的主键确定，那这个表中就不允许存在一行数据其主键的值为null， 也不允许存在两行数据其主键的值一样。一旦后续操作违反了这个原则（约束），则该操作就不会被执行 举个栗子： 新定义一张department表 1234567-- 下面的操作创建了一张department表，并指定dept_name为主键CREATE TABLE department ( dept_name VARCHAR(20), building VARCHAR(15), budget NUMERIC(12, 2), PRIMARY KEY (dept_name)); 下面顺序执行一系列插入操作 1234567891011121314-- 下面的操作将成功插入一条记录INSERT INTO department (dept_name, building, budget)VALUES ('Software', 'A', 100000);-- 下面再执行一次与上面一模一样的操作，会发现报错，因为之前已经有一条-- 记录的主键值为'Software'，顾无法再插入主键值相同的数据-- [23000][1062] Duplicate entry 'Software' for key 'PRIMARY'INSERT INTO department (dept_name, building, budget)VALUES ('Software', 'A', 100000);-- 下面的语句试图插入一条dept_name为空的数据，显然也是报错的-- 因为作为主键的字段是不允许为空的-- [23000][1048] Column 'dept_name' cannot be nullINSERT INTO department (dept_name, building, budget) VALUES (NULL , 'A', 100000); 执行上面操作后的结果 dept_name building budget Software A 100000 foregin key(A1, A2, …, An) references —— 外键约束 简单来讲如果一个关系（表）A中包含一个外键C，则作为外键的一个或多个字段必然是另一张表B的主键。则由于外键约束这一层关系，对A表和B表都会收一定程度的限制（现在解释的还是比较抽象，看下面的例子会比较直观一点） 如果想向A表中插入一条数据，且数据中C的值在B表中找不到对应表项，则这个操作不会成功（就像你如果向运动员表中插入一条数据，国家属性对应的标识在国家表中不存在，则这次插入操作就会失败） 如果试图删除一个表B的记录，而这条记录的主键只正好是A表中某条数据的外键，则这次删除操作不会成功 举个栗子： 先创建两张表 1234567891011121314151617-- 创建一张表department，并制定dept_name为主键CREATE TABLE department ( dept_name VARCHAR(20), building VARCHAR(15), budget NUMERIC(12, 2), PRIMARY KEY (dept_name));-- 再创建一张couese表，并指定dept_name为本表关于department表的外键CREATE TABLE course ( course_id VARCHAR(7) NOT NULL, title VARCHAR(50), dept_name VARCHAR(20), credits NUMERIC(2, 0), PRIMARY KEY (course_id), FOREIGN KEY (dept_name) REFERENCES department (dept_name)); 我们先试图插入一条course记录 1234-- 下面试图往course表中插入一条记录，但是department表中并没有-- dept_name = 'DUT'的记录，故该操作会失败INSERT INTO course (course_id, title, dept_name, credits)VALUES ('08', 'English', 'DUT', 3) 我们先往department表中插入记录，再往course表中插入记录，下面的操作就能成功插入 12345INSERT INTO department (dept_name, building, budget) VALUES ('DUT' , 'A', 100000);INSERT INTO course (course_id, title, dept_name, credits)VALUES ('08', 'English', 'DUT', 3) 执行上面操作后的结果 dept_name building budget DUT A 100000 course_id title dept_name credits 08 Endlish DUT 3 * 此时我们如果试图删除department表中dept_name = DUT的那条数据 123-- 执行下面的操作就会报错，因为course表中还有一项数据的dept_name的值为DUT，如果删除掉department中的这条数据，就会破坏其完整性，顾执行失败-- 23000][1451] Cannot delete or update a parent row: a foreign key constraint fails (`db_study`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`dept_name`) REFERENCES `department` (`dept_name`))DELETE FROM department WHERE dept_name = 'DUT'; * 同样的如果，我们试图删除department表，则只要course表中还有数据，这个操作就会失败 not null——非空约束 理解上面两个约束以后这个就很好理解了，这个约束就是指定某个字段不能为空，试图传入null值的操作都不会成功 作为主键的字段隐式拥有非空约束]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
