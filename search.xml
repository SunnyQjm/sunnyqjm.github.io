<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高级C与网络编程复习（五）—— TCP C/S程序示例（TCP Client/Server Example）]]></title>
    <url>%2F2018%2F01%2F05%2Fsuper_c_e%2F</url>
    <content type="text"><![CDATA[简单回射程序概述 客户从标准输入读入一行文本，并写给服务器 服务器从网络输入读入这行文本，并回射给客户 客户熊网络赎回如读入这行回射文本，并显示在标准输出上 TCP回射服务程序 &ensp;tcpserv01.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;unp.h&gt;void str_echo(int);int main(int argc, char** argv)&#123; int listenfd, connfd; pid_t pid; socklen_t clen; struct sockaddr_in cliaddr, servaddr; listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(9748); servaddr.sin_addr.s_addr = htonl(INADDR_ANY); Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr)); Listen(listenfd, LISTENQ); for( ; ; )&#123; clen = sizeof(cliaddr); connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;clen); if( (pid = Fork()) == 0 )&#123; //子进程执行 Close(listenfd); str_echo(connfd); Close(connfd); exit(0); &#125; Close(connfd); //父进程执行 &#125;&#125;void str_echo(int connfd)&#123; ssize_t n; char buf[MAXLINE];again: while((n = read(connfd, buf, MAXLINE)) &gt; 0) Writen(connfd, buf, n); if(n &lt; 0 &amp;&amp; errno == EINTR) goto again; else if(n &lt; 0) err_sys("str_echo: read error");&#125;]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（四）—— 基本套接字函数（Elementary Sockets Functions）]]></title>
    <url>%2F2018%2F01%2F04%2Fsuper_c_d%2F</url>
    <content type="text"><![CDATA[socket函数 1234567891011121314151617#include &lt;sys/socket.h&gt;/*** 该函数用于创建一个socket套接字* @param domin 协议族/地址族* @param type 套接字的类型* SOCK_STREAM ==&gt; TCP套接字* SOCK_DGRAM ==&gt; UDP套接字* SOCK_RAW ==&gt; RAW套接字* SOCK_PACKET ==&gt; 可用于创建路由套接字等* @param protocol 指定协议** @return 返回一个socket描述符 sockfd* sockfd &lt; 0 ==&gt; 创建失败* sockfd &gt;= 0 ==&gt; 创建成功，之后可用该sockfd进行IO操作**/int socket(int family, int type, int protocol); family 常值 type 常值 protocol 常值 socket函数中的family不是任意组合都是有效的，下面是组合效果： AF_XXX 和 PF_XXX AF_前缀表示地址族，PF_前缀表示协议族 历史上曾有这样的想法：单个协议族可以支持多个地址族，PF值用来创建套接字，而AF值用于套接字地址结构。 但实际上，支持多个地址族的协议从未出现过，而且头文件 &lt;sys/socket.h&gt;中为一给定协议定义的PF值总是与此协议的AF值相等 connect函数 123456789/**T* 该函数用于建立与指定socket的连接* @param sockfd 一个未连接的socket的描述符* @param sockaddr 指向要连接的套接字的sockaddr结构体的指针* @param addrlen 上述sockaddr结构体的长度** @return 成功则返回0, 失败返回-1, 错误原因存于errno 中**/int connect(int sockfd, const struct sockaddr * servaddr, int addrlen); 如果是TCP套接字，调用connect函数将激发TCP的三路握手过程。而且仅在连接建立成功或出错时才返回 connect错误： ETIMEOUT（超时错误）: TCP客户没有收到对发出的SYN分节的响应 ECONNREFUSED（连接拒绝错误）：客户在发出SYN分节后收到RST响应 表明服务器主机在我们指定的端口上没有进程在等待与之连接（通常是服务器进程没有在运行，或者是客户端连接的时候指定了错误的端口号） 或TCP向取消一个已有的连接 或TCP接收到一个根本不存在的连接上的分节 硬错误（hard error） EHOSTUNREACH或ENETUNREACH（主机不可达或） 客户咋中间的某个路由器上引发了一个“destination unreachable”（目的地不可达）ICMP错误 并且在某个规定时间（4.4BSD规定75s）内仍未收到响应 软错误（soft error） 状态转换 TCP状态转换图 connect函数导致当前你套接字从CLOSED状态（该套接字自从由socket函数创建以来，一直处于CLOSED状态）转移到SYN_SENT状态 如果连接成功则转移到ESTABLISHED状态 若connect失败，则该套接字不可再用，必须关闭，我们不能对这样的套接字再次调用connect函数 当循环调用函数connect为给定主机尝试各个IP地址直到有一个成功时，在每次connect失败后，都必须close当前的套接字描述符并重新调用socket bind函数 bind函数把一个本地协议地址赋予一个套接字 对于网际协议，协议地址是32位的IPv4地址或128位IDEIPv6地址与16位的TCP或UDP端口号的组合 调用bind函数可以指定一个端口号，或指定一个IP地址，也可以两者都指定或两者都不指定 1234567891011/***** sockfd： 标识一未捆绑套接口的描述字。* my_addr： 赋予套接口的地址。sockaddr结构定义如下：* struct sockaddr&#123;* u_short sa_family;* char sa_data[14];* &#125;;* addrlen： my_addr的长度。* 返回值： 成功返回0，失败返回-1.****/int bind( int sockfd , const struct sockaddr * my_addr, socklen_t addrlen); 端口的绑定 通常用于服务器在启动的时候捆绑他们众所周知的端口 对于客户机，不调用bind绑定端口，而是在发送消息的时候由内核临时分配一个端口，这是正常的 而对于服务器而言，不绑定端口是极为罕见的 地址的绑定 进程可以把一个特定的IP地址绑定到它的套接字上，不过这个IP必须属于其所在主机的网络接口之一 对于客户端而言，绑定IP地址就相当于为该套接字上发送IP数据报指定了源IP地址 对于服务器而言，绑定IP地址就相当于限定该套接字只能接收那些目的地为这个IP地址的客户连接 给bind函数指定要捆绑的IP地址和端口号产生的结果 通配地址(wildcard address) IPv4: INADDR_ANY 123//IPv4struct sockaddr_in servaddr;servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //wildcard IPv6: in6addr_any 123//IPv6struct sockaddr_in6 serv;serv.sin6_addr = in6addr_any; //wildcard 错误 EADDRINUSE(“Address already in use”, 地址已使用) listen函数仅由TCP服务器调用，它做两件事情 当socket函数创建一个套接字时，它被假设为一个主动套接字(active socket)，也就是说，它是一个将调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，之后是内核应接收指向该套接字的连接请求。 本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数 123456/*** 将一个未连接的套接字转换成监听套接字，这样即可以用来监听来自客户端的请求了* @param sockfd 一个未连接的套接字描述符* @param backlog 等待连接队列的最大长度**/int listen( int sockfd, int backlog); 调用时机 本函数通常应该在调用socket和bind这两个函数以后，并在调用accept函数之前调用 内核为任何一个给定的监听套接字维护两个队列 为完成连接队列（incomplete connection queue）：服务器收到请求的SYN分节，并且正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态 已完成连接队列（completed connection queue）：每个已完成TCP三路握手过程的客户对应其中的一项。这些套接字处于ESTABLISHED状态 点我可查看TCP状态转换图 两个队列的建立时机 accept函数 accpet函数由TCP服务器调用，用于从已完成连接队列头返回一个已完成连接 如果已完成连接队列为空，那么进程将被投入睡眠（假定套接字为默认的阻塞方式） 12345678910/*** 在一个套接字的监听队列中取一个连接，如果没有，则死等** @param sockfd 监听描述符（在调用listen之后监听来自客户端的连接）* @param addr (可选)用来保存新连接的源端地址* @param addrlen (可选)用来保存新连接的源端地址结构的长度** @return 如果连接成功，则返回一个已连接的套接字描述符（用于和客户端通信）**/SOCKET accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 后两个参数为Value-Result参数 ==&gt; 点我查看Value-Result参数详情 fork和exec函数 fork函数12345678#include &lt;unistd.h&gt;/*** 调用fork函数创建一个新进程，与当前进程并行执行** @return 在子进程中为0，在父进程中为子进程ID，若出错返回-1**/pid_t fork(void); fork函数是Unix中派生新进程的唯一方法 调用一次，返回两次。返回值告知当前进程是子进程还是父进程 子进程可通过geippid获取父进程的id 父进程fork之前打开的所有文件描述符都会copy一份给子进程（各个描述符的引用计数加1） 两个典型用法： 创建自身副本，每个副本并行执行各自的操作 一个进程想要执行另一个程序，则fork一下，在子进程调用exec执行其它程序 exec函数1234567#include &lt;unistd.h&gt;int execl(const char* pathname, const char *arg0, ... /*(char*)*/);int execv(const char* pathname, char* const *argv[])... 存放在硬盘上的可执行程序文件能够被Unix执行的唯一方法是：由一个现有的进程调用上述6个exec函数中的一个 exec把当前进程映像替换成新的程序文件，而且该程序通常从main函数开始执行。进程ID不改变 我们称调用exec的进程为调用进程（calling process），称新执行的程序为新程序（new program） 这些函数只在出错时才返回到调用跟着，否则，控制将被传递给新程序的起始点，通常就是main函数 6个exec函数的关系 描述符引用计数 Unix系统内核为每个文件描述符（包括socket fd）维护一个引用计数,这个引用计数标识当前打开着的引用该文件或套接字的描述符的个数 当某个文件描述符或套接字描述符关闭的时候，不是直接关闭文件或套接字，而是引用计数减1，当引用计数减到0的时候执行关闭操作 需要注意的是：如果多个进程同时拥有指向同一个文件或套接字的描述符。且其中一个没有关闭（并且不再使用了），则就算其他文件描述符都关闭了，这个文件或套接字也不会关闭。就会造成内存泄露 举个栗子： 123456789101112131415161718pid_t pid;int listenfd, connfd;listenfd = Socket(...);/*fill in sockaddr_in&#123;&#125; with server's well-know port*/Bind(listenfd, ...)Listen(listenfd, LISTENQ);for( ; ; )&#123; connfd = Accept(listenfd, ...); if( (pid = Fork()) == 0 )&#123; //子进程 Close(listenfd); doit(connfd); Close(connfd); exit(0); &#125; Close(connfd); //父进程&#125; 上面的代码中，调用了fork之后，connfd和listenfd在父子进程中都有一份 所以在父进程中，只用处理listenfd，故关掉connfd 在子进程中，只用处理connfd，故关掉listenfd 试想：如果父进程中没有关闭connfd，则就算子进程执行完毕，connfd关联的套接字的引用计数还是不为0，所以一直不会释放。连接多了之后，每个连接的socket都不释放，慢慢的服务器内存就炸了。 close函数 123456789#include &lt;unistd.h&gt;/*** 通常Unix close函数也用来光比套接字，并终止TCP序列** @return 0 ==&gt; 成功* -1 ==&gt; 出错**/int close(int sockfd); 通常close函数的默认行为是把该套接字标记成已关闭，然后立即返回 被标记的套接字不能再被进程使用，即不能read/write 然后尝试将缓存或队列中所有的Message发出 接着就是正常的TCP终止序列 gesockname 和 getpeername 函数 1234567891011#include &lt;sys/socket.h&gt;/*** 返回与sockfd关联的本地协议地址**/int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);/*** 返回与sockfd关联的外地协议地址**/int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen); 其中，两个函数的后两个参数均为Value-Result参数 可以用getsockname获取内核为我们分配的地址或端口号 getsockname还可以用于获取某个套接字的协议族 上面两个函数中的第一个参数sockfd必须是已连接的套接字描述符 当服务器进程通过accept的某个进程通过调用exec执行程序时，getpeername是唯一可以用来获取对端设备地址信息的函数]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（三）—— 套接字编程简介（Sockets Introducrion）]]></title>
    <url>%2F2018%2F01%2F04%2Fsuper_c_c%2F</url>
    <content type="text"><![CDATA[套接字地址结构（Socket Address Structures） 大多数套接字函数（socket function）都 需要一个指向套接字地址结构（socket address structure）的指针作为参数 每个协议族（protocol suite）都定义它自己的套接字地址结构 这些结构的名字均以sockaddr_开头，并以对应每个协议族的唯一后缀结尾 IPV4套接字地址结构&ensp;网际（IPV4）套接字地址结构：sockaddr_in&nbsp;-->&nbsp;定义在&lt;netinet/in.h&gt;当中12345678910111213struct in_addr&#123; in_addr_t s_addr; //32-bit ipv4 Address, network byyte ordered //32为的ipv地址，采用网络字节序&#125;；struct sockaddr_in&#123; uint8_t sin_len; //length of structure (16) sa_family_t sin_family; //AF_INET ==&gt;本地址结构是IPV4的地址结构，他属于网际协议族 in_port_t sin_port; //16-bit TCP or UDP port, 网络字节序 struct in_addr sin_addr; //32-bit ipv4 address, 网络字节序 char sin_zero[8]; //unused ==&gt; 保留位，未使用&#125; POSIX规范要求的数据类型 IPV4地址和TCP或UDP端口号都采用网络字节序（大端序）存储 IPV4地址存在两种访问方法（因为历史原因） serv.sin_addr (结构体) serv.sin_addr.in_addr_t （通常是一个无符号的32为整数） sin_zero字段未被使用，不过在填写这种结构的时候sin_zero通常被置为0。（通常的做法是，在填写之前，用bzero将整个结构体清0，再填写，可以保证未填写的部分都是0） 套接字地址结构仅在主机上使用，虽然结构体中的某些字段（例如IP地址和端口号）用在不同主机之间的通信，但是结构体本身并不在主机之间传递 通用套接字地址结构&ensp;通用套接字地址结构：sockaddr&nbsp;-->&nbsp;定义在&lt;sys/socket.h&gt;当中12345struct sockaddr&#123; uint8_t sa_len; sa_family_t sa_family; //Address family: AF_XXX value char sa_data[14]; //protocol-specific address&#125; 前面提到过，大多数套接字函数都需要一个指向套接字地址结构的指针。但是套接字函数大多支持多个协议族，也就是说在调用的时候可能传入不同协议族的地址结构指针，那套接字函数在定义的时候就必须要有一个类型，可以接收各个协议族对应的地址结构指针。 这种需求可以用void *来解决，实际上也更方便，如果用void *来定义，可以接收任意类型的指针，而且不用显示转换。但是void *实在ANSI C中提出的，而套接字函数是在ANSI C之前定义的，所以为了解决上述需求，采用了通用套接字，下面是一个套接字函数的栗子： 1234int bind(int, struct sockaddr *, socklen_t);//调用方式如下bind(sockfd, (struct sockaddr *) &amp;serv, sizeof(serv)); 通用套接字地址结构sockaddr和其他协议族各自的地址结构sockaddr_XX规定的最小size是一样的，都是16个字节 套接字函数在具体处理的时候根据sa_family字段区分不同的地址结构，对应不同的处理 IPV6套接字地址结构&ensp;IPv6套接字地址结构：sockaddr_in6&nbsp;-->&nbsp;定义在&lt;netinet/in.h&gt;当中12345678910111213141516struct in6_addr &#123; uint8_t s6_addr[16]; //128-bit IPV6 address&#125;;#define SIN6_LEN //require for compile-time testsstruct sockaddr_in6 &#123; uint8_t sin6_len; //length of this struct, 大小为28个字节 sa_family_t sin6_family; //AF_INET6 in_port_t sin6_port; //传输层端口，网络字节序 uint32_t sin6_flowinfo; //flow information, undefined struct in6_addr sin6_addr; //IPV6 address, 网络字节序 uint32_t sin6_scope_id; //set of interfaces for a scope&#125; 值-结果参数（Value-Result Argument） 一个参数，当函数调用时，其作为一个值从函数外传入函数内，当函数返回时，该参数又存储了函数执行的部分结果，这种类型的参数称为value-result参数 value-result参数总是以引用/指针的方式传递（只能用地址传递的方式，如果用值传递方式获取不到函数的返回信息） 上文曾提到过，当往一个套接字函数传递地址结构的时候，该结构总是以引用的方式传递（即传递地址结构的指针）。该结构的长度也作为一个参数来传递，不过其传递的方式可能是传值，也可能是传指针，具体的传递方式取决于该结构的传递方向：是从进程到内核，还是从内核到进程 从进程到内核传递套接字地址结构 涉及的函数有：bind、connect、sendto 传递结构长度的时候传值就好了 举个栗子： 12345struct sockaddr_in serv;/*fill in serv&#123;&#125;*/connect(sockfd, (SA *) &amp;serv, sizeof(serv)); 图示： 从内核到进程传递套接字地址结构 涉及的函数有：accpet、recvfrom、getsockname、getpeername 传递结构长度的时候传入一个指向socklen_t的指针（而不是int，POSIX规范建议将socklen_t定义为uint32_t） 举个栗子： 12345struct sockaddr_un cli;socklen_t len;len = sizeof(cli);getpeername(unixfd, (SA *) &amp;cli, &amp;len); 图示： 当函数被调用时，结构大小是一个值（value），它告诉内核该结构的大小，这样内核在写该结构的时候不至于越界；当函数返回时，结构大小又是一个结果（result），它告诉进程内核在该结构中究竟存储了多少信息。 字节排序函数（Byte Ordering） 大端和小端（big-endian and little-endian） 小端：低字节存储在起始地址 大端：高字节存储在起始地址 举个例子：123456780x0102//从左到右为内存增大方向//在大端系统中存储00000001 00000010//在小端系统中存储00000010 00000001 测试主机是大端还是小端的实践 –&gt; click_me123./byteorderx86_64-unknown-linux-gnu: little-endian 网络字节序 不同的机器可能采用不同的存储方式（大端/小端），为了统一，网络协议变制定了一个网络字节序 网际协议使用大端字节序来传送多字节整数 由于不同主机的差异性，便需要有一些函数来进行网络字节序和主机字节序的转换 字节转换函数12345678910111213141516171819202122232425#include &lt;netinet/in.h&gt;/*** host to network short* 将主机字节序的16位短整型转换为网络字节序的16位短整型**/uint16_t htons(uint16_t host16bitvalue);/*** host to network long* 将主机字节序的32位整型转换为网络字节序的32位整型**/uint32_t htonl(uint32_t host32bitvalue);/*** network to host short* 将网络字节序的16位短整型转换为主机字节序的16位短整型**/uint16_t ntohs(uint16_t net16bitvalue);/*** network to host long* 将网络字节序的32位整型转换为主机字节序的32位整型**/uint32_t ntohl(uint32_t net32bitvalue); 事实上，在64为的系统中，尽管长整数占64位，htonl和ntohl函数操作的仍然是32位值 字节操纵函数字节操作函数和有两组，本书中只用到了bzero 源自Berkeley的函数（b开头的字节操纵函数）1234567891011121314151617#include &lt;strings.h&gt;/*** 将以dest为起始的目标串的前nbytes个字节置为0**/void bzero(void *dest, size_t nbytes);/*** 将dst中的前nbytes个字节拷贝到src串中**/void bcopy(const void *src, void *dst, size_t nbytes);/*** 比较ptr1和ptr2串的前n个字节* @return 若相等则返回0， 否则返回非0**/void bcmp(const void *ptr1, const void *ptr2, size_t nbytes); ANSI C函数（mem开头的字节操纵函数）123456789101112131415161718192021#include &lt;string.h&gt;/*** 把dest串的前len个字节置为c**/void *memset(void *dest, int c, size_t len);/*** memcpy类似bcopy，但是两个指针的位置时候是相反的** PS：当dest串和src串重叠时，bzero可正常处理，memcpy的处理结果不可知，此时改用memmove函数**/void *memcpy(void *dest, const void *src, size_t nbytes);/*** 比较两个串的前nbytes个字节* @rerurn 0 相等* &gt;0 第一个不相等字节，ptr1 &gt; ptr2* &lt;0 第一个不相等字节，ptr1 &lt; ptr2**/void *memcmp(const void *ptr1, const void *ptr2, size_t nbytes); 地址转换函数 地址转换函数在ASCII字符串和网络字节序的二进制值之间转换网际地址 inet_aton、inet_addr、inet_ntoa在点分十进制数串（例如“192.168.1.1”）与它长度为32位的网络字节序二进制值之间转换IPv4地址。 两个比较新的函数，inet_pton和inet_ntop对于IPv4和IPv6都适用 inet_aton、inet_addr 和inet_ntoa函数12345678910111213141516#include&lt;arpa/inet.h&gt;/*** 将strptr所指c字符串转换成一个32位的网络字节序二进制值，并通过addrptr指针来存储**/int inet_atonn(const char *strptr, struct in_addr *addrptr);/*** 将strptr所指c字符串转换成一个32位的网络字节序二进制值, 并返回**/in_addr_t inet_addr(const char *strptr);/*** 将一个32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。**/char *inet_ntoa(struct in_addr inaddr); inet_addr 被废弃 inet_addr函数出错时返回INADDR_NOE(通常是一个32位均为1的值) 这意味着该函数不能处理“255.255.255.255”，因为它的二进制值和INADDR_NONE的值是一样的，被用来指示函数执行失败 inet_ntoa函数返回值所指向的串驻留在静态内存当中，着意味着该函数是不可重入的 上面这些函数至支持IPv4，如果要支持IPv6，使用下面介绍的两个函数 inet_pton 和 inet_ntop 函数1234567891011121314151617181920#include &lt;arpa/inet.h&gt;/*** 尝试转换由strptr所指的字符串，并通过addrptr指针存放二进制结果** @return 1 ==&gt; 转换成功* 0 ==&gt; 输入的不是有效表达式* -1 ==&gt; 转换出错**/int inet_pton(int family, const char*strptr, void *addrptr);/*** 与inet_pton进行相反的转换，从数值格式（addrptr）转换到表达式格式（strptr）。* @param len 指定目标存储单元的带下，以免该寒素溢出调用者的缓冲区* @param strptr 用来存储目标串，如果执行成功，返回值即为这个指针* （不能传递空指针，调用这必须为目标存储单元分配内存，并指定其大小）* @return NULL ==&gt; 失败* strptr ==&gt; 成功**/const char *inet_ntop(int family, void *addrptr, char *strptr, size_t len); 两个函数的family参数可以是AF_INET或AF_INET6。如果以不被支持的地址族作为family参数。这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT sock_ntop和相关函数 在使用inet_ntop的时候，对于IPv4和IPv6的调用方法不同（这使得我们的代码和协议相关了）： 1234567//IPv4struct sockaddr_in addr;inet_ntop(AF_INET, &amp;addr.sin_addr, str, sizeof(str));//IPv6struct sockaddr_in6 addr6;inet_ntop(AF_INET6, &amp;addr6.sin6_addr, str, sizeof(str)); 所以Steven针对上述问题写了下面这么个封装函数 123456789#include "unp.h"/*** 同时支持IPv4和IPv6版本的inet_ntop** @return 成功 ==&gt; 非空指针* 出错 ==&gt; NULL**/char *sock_ntop(const struct *sockaddr, socklen_t addrlen); sock_ntop的实现和其它相关函数此处不做详细讨论，有兴趣可以查看Steven的《Unix 网络编程 卷1》 readn, writen 和 readline 函数 12345678910111213141516#include "unp.h"/*** 从一个描述符中读n字节**/ssize_t readn(int filedes, void *buff, size_t nbytes);/*** 往一个描述符里写n个字节**/ssize_t writen(int filedes, const void *buff, size_t nbytes);/*** 从一个描述符中读文本行，以字节为单位**/ssize_t readline(int filedes, void *buff, size_t maxlen); 上面三个函数对read和write操作可能发生的EINTR错误做了处理]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（二）—— 传输层：TCP、UDP、SCTP]]></title>
    <url>%2F2018%2F01%2F03%2Fsuper_c_b%2F</url>
    <content type="text"><![CDATA[总图（Big Picture） UDP UDP应用程序将数据封装到UDP数据报，，并将其写到UDP socket。进而封装成IPV4或IPV6数据报（datagram），然后发送到目的地 UDP提供的是无连接的服务（connectionless service） 每个UDP数据报都有一个长度，如果一个数据报正确地到达目的地，那么数据报的长度将随数据一道传递给接收端应用程序 RFC 768 [Postel 1980] TCP 面向连接（Connection-oriented） 提供可靠传输（Reliable） TCP通过给每个字节关联一个序列号（sequence）对所发送的数据进行排序（sequencing） TCP提供流量控制（flow control）==&gt; 控制接收端收包的速率 全双工（full-duplex） TCP连接的建立和终止 三路握手 ———— Three-Way Handshake (SYN, ACK) 服务器通过socket，bind，listen创建一个监听socket，并调用accpet准备接受外来的连接（这些工作要在客户端请求来临之前做好）。 客户端通过socket函数创建一个未连接的socket，再调用connect尝试连接到服务器（此时客户端阻塞，等待服务器响应）。此时会向服务器发送一个SYN包（表明客户端欲向服务器申请服务），等待服务器的确认。 服务器收到SYN包，则向客户端发送一个ACK（告诉客户端，请求我已经收到）。同时发送一个SYN（通知客户端服务器需要知道客户端是否收到回复，收到则请回一个ACK） 客户端收到服务器发回的ACK和SYN之后，connect函数返回（表示连接服务器成功），并向服务器回一个ACK（告知服务器我已经收到你的回复） 服务器收到客户端的ACK以后accept函数返回（此时连接正式建立，可以开始后通信） ACK如果不捎带数据的话，是不占序列号的 SYN占一个序列号 四路终止 ———— Four-Way Termination (FIN, ACK) 客户端调用close（任意一端都可以发起终止，此处以客户端发起为例，发起终止的一端称为执行主动关闭）。接着向服务器发送一个FIN，表示数据发送完毕 服务器接收到FIN后回复一个ACK（此时服务器称为执行被动关闭的一端），同时服务器的read函数会读到一个EOF，导致read函数退出 一段时间后，服务器也调用close，向客户端发送一个FIN 客户端收到FIN以后回复一个ACK FIN占一个序列号 在被动关闭一端收到FIN到其调用close函数之间的间隙，称为半关闭状态（half-close），在这段时间内仍然可以冲被动关闭一端向主动关闭一端发送数据 当一个Unix进程无论自愿（调用exit或main函数返回）还是非自愿（收到一个终止本进程的信号）的终止时，所有打开的描述符都将被关闭，这也导致主机向仍然打开的任何TCP连接上发出一个FIN（对于那些描述符只被这个终止的进程持有的连接而言） TCP状态转换图 TCP的限制 TCP同时提供可靠数据传输和严格的有序数据分发。然而有一些应用程序需要可靠数据传输，但是不需要顺序维护，而另一些应用过程序只需要部分有序即可。 TCP这种面向数据流的传输方式有时候是不方便的。应用程序必须添加自己的记录标记。 TCP套接字的范围有限，使得为多宿主主机提供高可用数据传输能力的任务变得复杂 容易受到拒绝服务攻击，例如SYN攻击 这些限制影响公共交换电话网的IP性能 端口号（Port Numbers） 众所周知（well-know）的端口：0 ~ 1023 已注册端口：1024 ～ 49151 动态或私有端口：49152 ～ 65535 TCP端口号与并发服务器]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级C与网络编程复习（一）—— Introduction]]></title>
    <url>%2F2018%2F01%2F02%2Fsuper_c_a%2F</url>
    <content type="text"><![CDATA[Introduction A Simple Daytime Client A Simple Daytime Server A Simple Daytime Client Steven源码地址 笔者加注释源码地址 功能： 实现向服务器发起一个TCP连接，请求时间信息，并将接收到的信息打印在控制台上 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;unp.h&gt;int main(int argc, char** argv)&#123; /*sockfd 套接字描述符，客户端通过该描述符与服务器进行通信（它指示一个与服务器的连接）*/ int sockfd, n; char recvline[MAXLINE + 1]; /*接收缓存*/ /*服务器地址，用来保存服务器的地址信息（该结构体专门保存IPV4地址），包括ip和端口*/ struct sockaddr_in servaddr; /*如果输入参数不够，则报错并退出*/ if(argc != 2) err_quit("usage: daytimecli &lt;IPAddress&gt;"); /*通过socket函数创建一个套接字，创建失败则退出*/ if( (sockfd == socket(AF_INET, SOCK_STREAM, 0) ) &lt; 0) err_sys("socket error"); /*清0*/ bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; /*指定协议族为网际协议族*/ servaddr.sin_port = htons(13); /*指定端口为13*/ /*将用户从命令行输入的IP存到servaddr中，如果用户输入的格式不正确*/ /*则该函数会返回小于0的错误信息，此时退出应用程序*/ if(inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0) err_quit("inet_pton error for %s", argv[1]); /*连接到servaddr指向的服务器，连接失败则退出*/ if(connect(sockfd, (SA *)&amp;servaddr, sizeof(servaddr)) &lt; 0) err_sys("connect error"); /*读取服务器发回的信息*/ while( (n = read(sockfd, recvline, MAXLINE)) &gt; 0 )&#123; recvline[n] = 0; /*输出到控制台*/ if(fputs(recvline, stdout) == EOF) err_sys("fputs error"); &#125; if(n &lt; 0) err_sys("read error"); exit(0);&#125; struct sockaddr_in 组成 12345678910111213141516/*** 下面是三个struct sockaddr_in的主要成员，数据的具体类型不同的系统不同，* 可以大概理解成下面这样，具体的定义可以查看源码**/unsigned short sin_family; /*源码中并不是直接表示成这样，用了几层宏定义，不过在*/ /*笔者的电脑上，其最原始的定义为 unsigned short*/u_16 sin_port; /*u_16表示无符号16位的数，范围为0~65535*/struct in_addr sin_addr;/*** struct in_addr 的结构如下**/struct in_addr&#123; __be32 s_addr; /*__be32 通常为 unsigned int(32位)*/&#125; 用于存储IPV4的地址信息，包括ip，端口，协议族（IPV4属于 AF_INET） socket() 百度百科–&gt; click_me click me for detail 原型123456789101112131415/*** 该函数用于创建一个socket套接字* @param domin 协议族/地址族* @param type 套接字的类型* SOCK_STREAM ==&gt; TCP套接字* SOCK_DGRAM ==&gt; UDP套接字* SOCK_RAW ==&gt; RAW套接字* SOCK_PACKET ==&gt; 可用于创建路由套接字等* @param protocol 指定协议** @return 返回一个socket描述符 sockfd* sockfd &lt; 0 ==&gt; 创建失败* sockfd &gt;= 0 ==&gt; 创建成功，之后可用该sockfd进行IO操作**/int socket(int domain, int type, int protocol); 需注意的是，socket函数的后两个参数不能随意组合。比如在type = SOCK_STRAM 的时候 protocol ≠ IPPROTO_UDP。（当第三个参数为0的时候，会自动选择第二个参数类型对应的默认协议） bzero 原型 1234/*** bzero为一个宏函数，实际上调用的是memset**/#define bzero(ptr, n) memset(ptr, 0, n) void *memset(void *s, int ch, size_t n);** bzero(ptr, n) ==&gt; 以ptr所指为起始，将紧接着的n位置成 0 (可以达到清0的效果) htons() 百度百科–&gt; click_me 原型1234/*** 将一个无符号短整型从主机字节序转网络字节序**/u_short htons(u_short hostshort); 网络字节序统一为 大端（big-endian）序，而现在大部分主机采用的是小端系统，也有机器采用大端系统。为了统一，调用这个函数之后均采用大端序（协议统一） inet_pton() 百度百科–&gt; click_me 原型：12345678910111213/*** 将“点分十进制” --&gt; “二进制整数”** @param af address family(地址族)* @param src 指向一个字符串，这个字符串为一个点分十进制的串，例如："192.168.1.1"* @param dst 指向一个数据结构，用来存储转换后的结果* 如果af = AF_INET, 即为ipv4地址转换，则函数会将结果放在一个in_addr结构体中* 如果af = AF_INET6, 即为ipv6地址转换，则函数会将结果放在一个in_addr6结构体中** @return 如果函数出错则返回一个负值，并将errno置为EAFNOSUPPORT。* 如果参数af指定的地址族和src格式不对，则返回0**/int inet_pton(int af, const char *src, void *dst); inet_pton同时支持和IPV4和IPV6 connect() 百度百科–&gt; click_me click me for detail 原型：123456789/*** 该函数用于建立与指定socket的连接* @param sockfd 一个未连接的socket的描述符* @param sockaddr 指向要连接的套接字的sockaddr结构体的指针* @param addrlen 上述sockaddr结构体的长度** @return 成功则返回0, 失败返回-1, 错误原因存于errno 中**/int connect(int sockfd, const struct sockaddr * servaddr, int addrlen); 为了书写简便，原书作者对上述函数的第二个参数做了一层宏定义：1#define SA struct sockaddr 所以在上面的daytimecli.c 中调用connect的时候，用SA简化了书写，实际上 SA = struct sockaddr1connect(sockfd, (SA *)&amp;servaddr, sizeof(servaddr) read() 百度百科–&gt; click_me 原型：123456789101112/*** 从fd所指向的文件中传送count个字节到buf中** @param fd 指向一个文件的指针（可以是socket fd）* @param buf 指向一个数组的指针，用做缓存，存取从fd中读出的数据* @param count 读取的大小** @return 返回值为实际读取到的字节数* 如果返回0，表示已到达文件尾或无可读取的数据。* 错误返回-1,并将根据不同的错误原因适当的设置错误码**/ssize_t read(int fd, void *buf, size_t count); 如果read函数中传入的文件描述符为sockfd，则表示从网络中读取count字节的数据并存到buf中。 read函数是一个阻塞函数，如果没有读够count个字节，会一直在那边死等，下面两种情况下read函数和的阻塞状态会解除 如果一个信号的到来，会导致主线程因为去执行信号的回调函数，而解除阻塞函数的阻塞状态。并将errno置成EINTR。表示因为信号中断而退出。（不过现在的系统好像做了优化处理，即便定义了某些信号的处理函数，当该信号到来时，该回调会执行，但同时却不会引发中断错误） 还有就是收到EOF（文件结束指针）。如果是tcp socket，则当对方关闭了写一端的时候，会向本机发送一个FIN，标识对方已经发完数据了。此时read的阻塞状态便会解除。同样的，如果对方给调用close函数关闭了socket，read函数也会解除阻塞（关闭socket相当于写端和读端都关闭了） 对比 write fputs() 百度百科–&gt; click_me 原型：123456789/*** 向指定的文件中写入一个字符串** @param ptr 指向待写入的字符串* @param stream 指向目标文件的一个文件指针（文件指针由fopen获得）** @return 函数返回值为一般非负整数，如果返回EOF(常值，为-1)，则标识读到文件尾**/int fputs(const char* ptr, FILE* stream) IPV6版本 上面的程序是支持IPV，点击此处有IPV6版本的代码 一些关于教材的扩展介绍 包裹函数（wrapper function） linux系统内核的c语言函数名都是小写的，如果之后的代码中出现了大写开头的函数，则表示是原书作者对内核函数做了一层包装，加了一些错误判断等，使用起来更加方便，这些即作者所说的包裹函数（wrapper function） 举个栗子：123456int Socket(int family, int type, int protocol)&#123; int n; if( (n = socket(family, type, protocol)) &lt; 0 ) err_sys("socket error"); return(n);&#125; 上面这个函数便是作者对内核的socket函数做了一层封装，功能和socket函数时候一样的，只不过在出错的时候，这个函数已经帮你将错误打印出来了，如果不需要什么其它特殊处理的话。在使用Socket函数的时候变可以不需要错误处理了 下面展示会了没有使用包裹函数和使用了包裹函数的区别123456//不使用包裹函数if( (sockfd == socket(AF_INET, SOCK_STREAM, 0) ) &lt; 0) err_sys("socket error");//使用包裹函数Socket(AF_INET, SOCK_STREAM, 0); 原书作者定义的包裹函数大致符合下列规则 名字和被包裹的函数一致，只是首字母大写 函数的参数数量和意义和被包裹的函数一致 函数的行为与被包裹的函数保持一致 Unix errno 值 error 为一个全局变量 当Unix中的函数执行过程中有错误发生，则errno就被置为一个指明该错误类型的正值，而函数本身通常返回-1 A Simple Daytime Server Steven源码地址 笔者加注释源码地址 功能： 实现在13号端口上监听来自任意IP的请求，并向客户端输出时间信息 没做并发处理，一次只能向一个客户端提供服务 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;unp.h&gt;#include &lt;time.h&gt;int main(int argc, int argv)&#123; int listenfd, connfd; struct sockaddr_in servaddr; char buff[MAXLINE]; time_t ticks; //调用包裹函数，创建一个socket listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(13); //指定socket的地址为INADDR_ANY，标识监听来自所有地址的请求 servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //将socket绑定到指定的端口，只在指定的端口监听来自客户端的请求 Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr)); //调用Lisen可将socket转换成一个监听套接字，监听套接字可用于监听其他客户端的请求 Listen(listenfd, LISTENQ); for( ; ; )&#123; //accpet函数是一个阻塞函数，死等一个连接请求。 //当监听到一个请求，就返回一个已连接描述符（该描述符用于与新连接的那个客户端通信） connfd = Accept(listenfd, (SA *) NULL, NULL); //获取当前系统的时间 ticks = time(NULL); //将当前时间输出到buff数组中 snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&amp;ticks)); //将buff中的数据发给客户端 Write(connfd, buff, strlen(buff)); //关闭socket连接 Close(connfd); &#125;&#125; bind() 百度百科–&gt; click_me click me for detail 原型：1234567891011/***** sockfd： 标识一未捆绑套接口的描述字。* my_addr： 赋予套接口的地址。sockaddr结构定义如下：* struct sockaddr&#123;* u_short sa_family;* char sa_data[14];* &#125;;* addrlen： name名字的长度。* 返回值： 成功返回0，失败返回-1.****/int bind( int sockfd , const struct sockaddr * my_addr, socklen_t addrlen); bind函数把一个本地协议地址赋予一个套接字，通常在connect或listen函数调用前使用 listen() 百度百科–&gt; click_me click me for detail 原型123456/*** 将一个未连接的套接字转换成监听套接字，这样即可以用来监听来自客户端的请求了* @param sockfd 一个未连接的套接字描述符* @param backlog 等待连接队列的最大长度**/int listen( int sockfd, int backlog); 函数的第二个参数指定的是系统内核允许在这个监听描述符上排队的最大客户连接数 不是允许的最大并发数 在监听描述符上排队的客户 ==&gt; 客户的请求被listen到了，但是还没有被accept处理，那么这个客户的请求便在该监听描述符上排队，等待被accpet 通常情况下，accpet以后就调用新线程或新进程处理了，所以很快就可以再accept，所以一般在监听描述符上排队的客户数不会很多 accept() 百度百科–&gt; click_me click me for detail 原型：12345678910/*** 在一个套接字的监听队列中取一个连接，如果没有，则死等** @param sockfd 监听描述符（在调用listen之后监听来自客户端的连接）* @param addr (可选)用来保存新连接的源端地址* @param addrlen (可选)用来保存新连接的源端地址结构的长度** @return 如果连接成功，则返回一个已连接的套接字描述符（用于和客户端通信）**/SOCKET accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 上述函数的第二、三个参数为值-结果（value-result）参数 即在函数调用的时候，可以通过这两个参数向函数内部传递内容 同时在函数调用结束的时候，可以通过这两个参数获取到返回信息 accept函数就将新连接的地址信息保存在了后两个参数中（如果不需要可以直接传NULL） accpet为每个连接到本服务器的客户返回一个全新的描述符（唯一标识一个客户） snprintf() 百度百科–&gt; click_me 原型：1234/*** 向str指向的区域格式化输出size个字节的数据**/int snprintf(char *str, size_t size, const char *format, ...) 用法和printf基本相同 不同的是，printf是向控制台打印，而snprintf是通过地址指针，向目标区域输出 write() 百度百科–&gt; click_me 原型：1234/*** 将buf中count个字节的数据输出到fd标识的文件中**/ssize_t write (int fd,const void * buf,size_t count); 对比read close() click me for detail 关闭与客户端的连接。该调用引发正常的TCP连接终止序列：每个方向上（读方向，写方向）发送一个FIN，每个FIN又各自的对端确认]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>C语言</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（十一）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88k%EF%BC%89%2F</url>
    <content type="text"><![CDATA[设计原则 （understanding） 面向接口编程 依赖倒置 组合优于继承 单一职责 开放——封闭 Liskov替换 面向接口编程(Program to An interface, Not An Implementation) 使用“接口继承”，而非“实现继承” 接口关注对象的概貌，将对象中“不变”的信息抽象出来，不涉及细节，因此是“稳定”的 Example: 面向接口的好处： Client只需关注如何进行业务活动（如：驾驶），而不必关心其使用对象的具体实现 一个对象可以很容易地被（实现了相同接口的）另一个对象所替换 对象间的连接不必硬绑定（hard wire）到一个具体类的对象上，因此增加了灵活性 松散耦合，增加了重用的可能性 依赖倒置（Dependency Inversion Principle） 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 依赖倒置原则使细节和具体实现都依赖于抽象，抽象的稳定性决定了系统的稳定性 Example： 组合优于继承 （Favor Composition Over Inheritance ） 继承：OO特点之一 组合：任务委托 二者：都是面向对象设计中用于重用的方法 开发早期，继承经常被过度使用 使用继承的问题： 组合优于继承－设计改进 优先使用组合可获得重用性与简单性更佳的设计 配合使用继承，扩充可用的组合类集，加大重用的范围&lt;% img /img/se_97.jpg %&gt; 何时使用继承？ 子类表达了“是一个父类的特殊类型”，而非“是一个由父类所扮演的角色” 子类的一个实例永远不需要转化为其它类的一个对象 子类是对其父类的职责进行扩展，而非重写或废除（LSP） 单一职责——Single responsibility Principle 所谓职责，可理解为功能，就是设计的类功能应该只有一个，而不是两个或更多 职责也可以理解为引起变化的原因：当一个类中有两个以上的变化方向，会产生过多的变化点 Example: 开放封闭原则——Open For Extension, Yet Closed For Modification (OCP) OCP认为应该试图设计出永远也不需要改变的模块 可以添加新代码来扩展系统的行为；不能对已有的代码进行修改 OCP模块标准 模块的行为可以被扩展，以需要满足新的需求 模块的源代码是不允许进行改动的 一个软件系统的所有模块不可能都满足OCP，但是应该努力最小化这些不满足OCP的模块数量 OCP法则是OO设计的真正核心 符合该法则便意味着最高等级的复用性和可维护性 一个OCP栗子： 改进 Liskov替换原则 使用指向基类（超类）的引用的函数，必须能够在不知道具体派生类（子类）对象类型的情况下使用它们 ==&gt; 在任何父类出现的地方，都可以用子类替换（包括逻辑上和语义上） LSP是根据对象的“多态”而得出的 但在实现子类时必须要谨慎对待，以确保不会无意中违背了LSP 一个违背Liskov原则的栗子 对于下面的代码：12345678910111213141516171819202122232425262728293031//Rectangle类声明如下public class Rectangle&#123; protected double width; protected double height; public Rectangle()&#123;&#125; public void setWidth(double w)&#123; this.width = w; &#125; public void setHeight(double h)&#123; this.height = h; &#125; public double area()&#123; return width * height &#125;&#125;//直接用Rectangle类, 输出200Rectangle rect = new Rectangle();rect.setWidth(10);rect.setHeight(20);System.out.println(rect.area());//将Rectangle换成其子类Square，输出为400Rectangle rect = new Square(0);rect.setWidth(10);rect.setHeight(20);System.out.println(rect.area()); LSP的保证 LSP表明了ISA关系是与对象行为有关的 一个子类型不得具有比基更多的限制，这是因为可能对于基类型的某些使用是合法的，但是会因为违背子类型的其中一个额外限制，从而违背了LSP 一个简单的做法是不要将基类中子类不需要的函数暴露给子类 设计模式（understanding） Abstract Factory（抽象工厂） PROTOTYPE（原型模式） Singleton（单例模式） Adapter（适配器模式） 抽象工厂（Abstract Factory） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类 原型模式（Prototype） 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 缺点是每一个类都必须配备一个克隆方法 其实是将product和factory功能合二为一了 单例模式（Singleton） 保证一个类仅有一个实例，并提供一个访问它的全局访问点 解决的主要是性能问题，而非耦合（变化）的问题 适配器模式（Adapter） 把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作 适配类可以根据参数返还一个合适的实例给客户端 桥梁模式（Bridge） 将抽象部分与它的实现部分（行为）分离，使它们都可以独立地变化 解决2个方面的变化问题：抽象与实现（行为）。即一个类中多个方向的变化问题]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（十）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88j%EF%BC%89%2F</url>
    <content type="text"><![CDATA[要求OO设计步骤，结构优化准则，对照架构模式，设计原则和设计模式 面向对象的设计准则 模块化 抽象 信息隐藏 弱耦合 强内聚 可重用 启发规则 设计结果应该清晰易懂 提高软件可维护性和可重用性重要措施 用词一致 使用已有的协议（重载） 减少消息模式的数目 避免模糊的定义 一般—特殊结构的深度应适当 应该使类等级中包含的层次数适当 设计简单的类 尽量设计小而简单的类，便于开发管理 避免包含过多的属性 有明确的定义 尽量简化对象之间的合作关系 不要提供太多服务（保持适当内聚的基础上） 使用简单的协议 使用简单的服务 把设计变动减至最小（结构稳定） 架构模式（Architecture Patterns）An architectural pattern is a proven structural organization schema for software systems（架构模式是指用于软件系统中经实践证明的机构化的组织格式化） 层次、CS、MVC、Pipe-Filter、Master-slave 层次架构 eg: 网络协议（OSI/ISO 七层模型） 每层向上层提供服务 越低层越稳定 职责分离，每层可独立开发 提供给上层高的抽象接口不容易写 低层可能做一些高层用不到的功能 MVC架构 model: 核心功能和数据（是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据） view： 向用户展示信息（是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的） controller： 处理用户的输入（是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据） 用于交互式系统 控制流程 CS架构 Server组件向多个client提供服务 客户端通过向服务器请求得到服务 请求是在进程和机器边界上完成的 采用进程间通信机制 而层级架构则是横跨进程和机器边界 Server通常是长期运行的，拥有监听来自Client的请求 Examples： Remote DB access （远程数据库接入） Remote file systems（远程文件系统） Multi-tier information system（多层信息系统） Web applications（网页应用） 通常在单独的线程中处理请求 Server和Client的交互通常包含在一个session（会话）中 Stateless servers（无状态的服务） 会话状态由client保存（例如：cookie机制） 每个请求都带上client保存的会话状态信息 Stateful servers（有状态服务） 会话状态由Server端保存 所有的Client的请求都关联到其对应的client-id Master-slave（主从模式） 主从模式支持容错和并行计算 主组件将工作分配给若干个从组件，从组件各自计算，最后主组件从这些从组件返回的结果中计算最终的结果 Examples: Process control(进程控制) Embedded systems(嵌入式系统) Large-scale parallel computations（大规模并行计算） Fault tolerant systems(容错系统) ==&gt; 比如磁盘阵列（可以用其中一块或多块硬盘做奇偶校验，可以达到容错的效果） 执行流程： 分析： 一旦Master挂掉，整个系统也就挂了 从组件之间是独立的，不共享状态 从组件之间可以并行运行 对于硬实时系统（对延迟很敏感），主从组件之间的通信延迟可能是一个问题 要解决的问题必须是可分解的 应用领域： 容错 并行计算 精确计算 Pipe-Filter(管道过滤器模式) 该架构适用于处理数据流的系统 每一个处理都封装在一个过滤器组件当中 数据通过相邻过滤器之间的管道（pipe）进行传输 pipe主要负责处理缓存和同步 Examples： Compilers（编译器） Unix shell commands 分析： 很容易插入新的过滤器 过滤器可重用 过滤器可以被独立开发 潜在数据转换开销 输入可以来自不同的数据源，输出也可以输出到不同的地方 天然的并行处理 过滤器间不共享状态 不适用于交互式系统，适用于批处理系统 Java中的管道 InputStream in = new BufferedInputStream(new DataInputStream(System.in)) Broker（代理模式） Peer-to-peer（P2P模式和） Event-bus Blackboard]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（九）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88i%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述要求： 掌握OO分析的方法和步骤，业务，能够使用UML图进行分析建模（类图、用例图、状态图、顺序图等） 面向对象分析是是辈出问题域内的对象，并分析它们相互间的关系，最终建立起问题域的简洁、精确、可理解的正确模型 在用面向对象观点建立起的三种模型中，对象模型（类图）是 最基本、最重要、最核心的 面向对象分析的过程面向该对象分析，就是抽取和整理用户或需求并建立问题域精确模型的过程 用用例图捕获需求 基于用例图构件类图 3个子模型5个层次 3个子模型：对象模型，动态模型，功能模型 5个层次 主题层（通常对应包的划分） 类与对象层 结构层 属性层 服务层 大体流程 寻找类与对象 识别结构 识别主题 定义属性 建立动态模型 建立功能模型 定义服务 需求陈述 通常，需求陈述的内容包括：问题范围，功能需求，性能需求，应用环境及假设条件等。总之，需求陈述应该阐明“做什么”而不是“怎样做” 描述用户的需求而不是提出解决问题的方法 应该避免对设计策略施加过多的约束，也不要描述系统的内部结构，这样做将限制实现的灵活性 对系统性能及系统与外界环境交互协议的描述，是合适的需求 此外，对采用的软件工程标准、模块构造准则、将来可能做的扩充以及可维护性要求等方面的描述，也都是适当的需求。 建立对象模型 确定类与对象 找出和候选的类与对象 用自然语言书写的需求陈述为依据，把陈述中的名词作为类与对象的候选者 用形容词作为确定属性的线索 把动词作为服务(操作)的候选者 筛选出正确的类与对象 冗余、无关、笼统、属性、操作、实现.. 确定关联 初步确定关联 大多数关联可以通过直接提取需求陈述中的动词词组而得出 通过分析需求陈述，还能发现一些在陈述中隐含的关联 筛选 已删去的类之间的关联 与问题无关或应在实现阶段考虑的关联 瞬时关联 三元关联 派生关联 完善 正名 分解 补充 标明重数 划分主题 在开发大型、复杂系统的过程中，为了降低复杂程度，习惯于把系统再进一步划分成几个不同的主题，也就是在概念上把系统包含的内容分解成若干个范畴 确定属性 分析 属性的确定既与问题域有关，也和目标系统的任务有关 应该仅考虑与具体应用直接相关的属性，不要考虑那些超出所要解决的问题范围的属性 在分析过程中应该首先找出最重要的属性，以后再逐渐把其余属性增添进去 在分析阶段不要考虑那些纯粹用于实现的属性 选择 认真考察经初步分析而确定下来的那些属性，从中删掉不正确的或不必要的属性 误把对象当作属性 把链属性误作为属性 把限定误当成属性 误把内部状态当成了属性 过于细化 存在不一致的属性 识别继承关系 反复修改 建立动态模型 第一步，是编写典型交互行为的脚本 第二步，从脚本中提取出事件，确定除服每个事件的动作对象以及接受事件的目标对象（画出事件跟踪图） 第三步，排雷事件发生的次序，确定每个对象可能有的状态及状态之间的转换关系，并用状态图描绘它们 建立功能模型 画出基本的系统模型图 画出功能级数据流图 EG: 对象模型参考： 动态模型参考 脚本 事件跟踪图 功能模型参考]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（八）]]></title>
    <url>%2F2017%2F12%2F31%2F2017-12-31-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88h%EF%BC%89%2F</url>
    <content type="text"><![CDATA[要求掌握UML图的绘制方法，需求规范概述Unified Modeling Language(UML) 统一建模语言 1977.11.17，OMG采纳 ==&gt; ISO标准 ==&gt; 事实的工业标准 元元模型（meta_metamodel）层 由UML中最基本的元素“事物（thing）”组成 元模型（metamodel）层 这一层的每个概念都是元元模型中“事物”概念的实例 模型（model）层 用户模型（user model）层 UML的表示法 视图（view） 通常包括多个图 图（diagram） 模型元素（model element）=&gt;可以在图中使用的概念 通用机制（general mechanism） 通过通用机制可以为UML中的图附加一些额外的信息 比如：构造型，标签值，笔记（写注释）等 UML中的图 用例图 （use-case diagram） 用例是对系统提供的功能（即系统的具体用法）的描述 用例图从用户的角度描述系统功能，并指出各个功能的操作者 用例图定义了系统的功能需求 用例图描述的是一个动态的交互场景，而不是一个静态的功能 静态图（static diagram） 静态图描述系统的静态结构，包括： 类图（class diagram） 对象图（object diagram） ==&gt; 是类图的实例，有生命周期 一般说来，对象图没有类图重要，它主要用来帮助对类图的理解，也可用在协作图中，表示一组对象之间的动态协作关系 行为图（behavior diagram） 这类图描述系统的动态行为和组成系统的对象间的交互关系，包括： 状态图(state diagram) ==&gt; 描述一个类，多个场景 活动图(activity diagram) ==&gt; 描述多个类，多个场景 交互图 （interaction diagram） 这类图描述对象间的交互关系，包括 顺序图（sequence diagram） 协作图（collaboration diagram） 描述一个场景中若干个类的交互（动态协作） 实现图（implementation diagram） 这类图提供关于系统实现方面的信息，包括： 构件图（component diagram） 配置图（deployment diagram）]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（七）]]></title>
    <url>%2F2017%2F12%2F24%2F2017-12-24-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88g%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面向对象方法学概述 概念 认为客观世界是由各种对象组成的，任何事物都是对象个，复杂的对象可以由比较简单的对象以某种方式组合而成。 把所有对象都划分成各种对象类（简称为类，class），每个独享都定义了一组数据和一组方法 按照子类（或称为派生类）与父类（或称为基类）的关系，把若刚个对象类组成功一个层次结构的系统（也称为类等级） 对象彼此之间仅能通过传递消息互相联系 OO = objets + classes + inheritance + communication with messages 优点 与人类习惯的思维方式一致 稳定性好 可重用性好 较易开发大型软件产品 可维护性好 面向对象建模用面向对象方法开发软件，通常需要建立三种模式的模，分别是描述系统数据结构的对象模型，描述系统控制结构的动态模型和描述系统功能的功能模型 对象模型（在UML部分详细介绍） 动态模型 功能模型 三种模型之间的关系在面向对象方法学中，对象模型是最基本最重要的，为其它两种模型奠定基础，依靠对象模型完成三种模型的集成 针对每个类建立的动态模型，描述了类实例的生命周期或运行周期 状态转换驱使行为发生，行为在数据流图中被映射成处理，与对象模型中的服务相对应 功能模型中的处理对应对象模型中类提供的服务 顶层数据流图中的处理对应复杂对象提供的服务；低层数据流图中的处理对应更基本的对象(基本对象是复杂对象的组成部分)的服务 有时一个处理对应多个服务，也有一个服务对应多个处理的时候 功能模型中的数据存储，以及数据的源点/终点(在功能模型中称为动作对象)，通常是对象模型中的对象。DataStore-ER entity-Object 功能模型中的数据流，往往是对象模型中的属性值，也可能是整个对象 功能模型中的处理可能产生动态模型中的事件 对象模型描述了功能模型中的动作对象、数据存储以及数据流的结构]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（六）]]></title>
    <url>%2F2017%2F12%2F24%2F2017-12-24-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88f%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通常把编码和测试统称为实现 所谓编码就是把软件设计翻译成计算机可以理解的形式——用某种程序设计语言书写的程序 编码是设计的自然结果，程序的质量主要取决于软件设计的质量 但所选用的程序设计语言的特点和编码风格也会对程序的可靠性、可读性、可测试性和可维护性产生深远的影响。 软件测试对软件可靠性的影响是重要的（软件生命周期中，差错不可避免） 尽可能早地发现并纠正差错 测试的目的就是在软件投入生产性运行之前，尽可能多地发现软件中的错误 软件测试在软件生命周期中横跨两个阶段 单元测试（一般模块的编写者和测试者是同一个人） 综合测试（通常由专门的测试人员承担这项工作） 统计资料表明，软件测试的工作量往往占软件开发总工作量的40%以上，对于关键应用系统的测试，可能相当于软件工程其他步骤总成本的3～5倍 测试目标是发现软件中的错误，但不是最终目的。调试是诊断并改正错误，这是最终目的。调试是测试阶段最困难的工作 对测试结果进行收集和评价，确定系统的可靠性 编码 (understanding) 选择程序设计语言 总的来说，高级语言明显优于汇编语言。除了对程度执行时间和使用的空间都有很严格限制的情况；需要产生任意的甚至非法的指令序列；体系结构特殊的微处理机，以致在这类机器上通常不能实现高级语言编译程序；或者大型系统中执行时间非常关键的(或直接依赖于硬件的)一小部分代码；其他程序应该一律用高级语言书写 编码风格 源程序代码的逻辑简明清晰、易读易懂是好程序的一个重要标准，应该遵循下述规则 程序内部的文档（注释） 数据说明 语句构造 输入输出 效率 软件测试基础 (master)软件工程其他阶段都是“建设性的”，而测试阶段的目的却是为了“破坏”已经建造好的软件系统————竭力证明程序中有错误，不能按照预定要求正确工作。 测试目标 测试是为发现程序中的错误而执行程序的过程 好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案 成功的测试是发现了至今为止尚未发现的错误的测试 测试准则 所有的测试都应该能追溯到用户需求（因需制宜） 应该在测试开始之前的相当长时间，就制定出测试计划 把Pareto原理应用于软件测试：测试发现的错误中的80%很可能是由程序中20%的模块造成的（2-8定理） 测试应该从“小规模”开始，并逐步进行“大规模”测试（由小到大） 穷举测试是不可能的 为了达到最佳的测试效果，应该由独立的第三方来从事测试工作（心理学角度上来讲，让编码人员找自己的错误是不现实的） 测试方法 黑盒测试 黑盒测试又称为功能测试 是在接口层面的测试，把程序看成一个黑盒子，不考虑内部结构和处理过程 适合于程序后期测试接口 白盒测试 白盒测试又称为结构测试 把程序看成装在一个透明的白盒子里，也就是完全了解程序的结构和处理过程 按照程序内部的逻辑测试程序，检验程序中的每条通路是否都能按预定要求正确工作。 适合于早期测试模块内部逻辑 测试步骤 单元测试，也称模块测试 集成测试 确认测试 系统测试 ps: α测试：在受控环境下测试（实验室环境） β测试：在非受控环境下测试（实际工作环境） 单元测试 单元测试和编码属于软件工程过程同一阶段（同属于编码和单元测试，因为单元测试通常是在编码的过程中进行的） 在编写出源程序代码并通过了编译程序的语法检查之后，应用人工测试和计算机测试这样两种类型的测试，完成单元测试工作 这两种类型的测试各有所长，互相补充 单元测试主要采用白盒测试技术，而且对多个模块的测试可以并行地进行 测试重点 模块接口 局部数据结构 重要的执行通路 出错处理通路 边界条件 代码审查 人工测试源程序可以由编写者本人非正式地进行，也可以由审查小组正式进行，后者称为代码审查，是一种非常有效的程序验证技术，对于典型的程序来说，可以查出30%～70%的逻辑设计错误和编码错误 审查小组组成： 组长，应该是一个很有能力的程序员，而且没有直接参与这项工程 程序的设计者 程序的编写者 程序的测试者 计算机测试 模块并不是一个独立的程序，必须为每个单元测试开发驱动软件（负责调用本模块）和(或)存根软件（负责模拟被本模块调用的子模块，比如对于一个用于数据处理的子模块，本模块需要的是其输出一个数据结构，那么就可以直接用一个构造的数据实例来替代这个子模块） 驱动程序就是一个“主程序”，接收测试数据，把这些数据传送给被测试的模块，并且输出有关结果 存根程序代替被测试的模块所调用的模块，也可以称为“虚拟子程序”。（桩模块） 使用被它代替的模块的接口，做最少量的数据操作，输出对入口的检验或操作结果，并且把控制归还给调用它的模块 集成测试集成测试是测试和组装软件的系统化技术，在把模块按照设计要求组装起来的同时进行测试，主要目标是发现与接口有关的问题 非渐增式测试方法 先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序 一次性集成测试 渐增式测试把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。这种每次增加一个模块的方法称为渐增式测试 自顶向下集成 首先测试M1（需要写M2、M3、S4对应的桩模块），然后将M1作为M2、M3、S4的驱动程序，集成并测试。以此类推 不用写驱动模块，但是需要写大量桩模块 优点： 不需要测试驱动程序 能够在测试阶段的早期实现并验证系统的主要功能 能在早期发现上层模块的接口错误 缺点： 需要存根程序 低层关键模块中的错误发现较晚 早期不能充分展开人力（不利于团队分工测试） 自底向上集成 步骤： 把低层模块组合成实现某特定软件子功能的簇 写一个驱动程序(用于测试的控制程序)，协调测试数据的输入和输出 对由模块组成的子功能簇进行测试 去掉驱动程序，沿软件结构自下向上移动，把子功能簇组合起来形成更大的子功能簇，重复2~4 优缺点与自顶向下集成相反 回归测试 不是一种测试方法，也不是一个测试阶段。重新执行已经做过的测试的某个子集，以保证上述这些改变没有带来非预期的副作用 回归测试（regression）与累进测试(progression) 回归测试：用之前版本的测试方案，测试好现在的程序 累进测试：用新的测试方案，测试同一版本的程序 确认测试 确认测试也称为验收测试，目标是验证软件的有效性 使用了确认(Validation)和验证(Verification)这样两个不同的术语 验证 就是要用数据证明我们是不是在正确的制造产品。注意这里强调的是过程的正确性 确认 就是要用数据证明我们是不是制造了正确的产品。注意这里强调的是结果的正确性 确认测试的范围 软件配置复查 Alpha和Beta测试 α测试：在受控环境下测试（实验室环境） β测试：在非受控环境下测试（实际工作环境） 白盒测试技术 (master) 逻辑覆盖是设计白盒测试方案的技术。设计测试方案是测试阶段的关键技术问题 测试方案包括具体的测试目的(例如，要测试的具体功能)，应该输入的测试数据和预期的输出结果 逻辑覆盖 语句覆盖 选择足够多的测试数据，使被测程序中每个语句至少执行一次 是很弱的逻辑覆盖标准 只关心判定表达式的值，不关心表达式内部具体每个条件取哪些值 举个栗子： 只需选取一组测试数据，覆盖路径ace即可 比如可以取 测试用例的格式：【输入的(A, B, X)，输出的(A, B, X)】 满足语句覆盖的测试用例：【(2, 0, 4), (2, 0, 3)】 判定覆盖 不仅每个语句必须至少执行一次 而且每个判定的每种可能的结果都应该至少执行一次，也就是每个判定的每个分支都至少执行一次 同样只关心判定表达式的值，不关心表达式内部具体每个条件取哪些值 举个栗子： 测试用例的格式：【输入的(A, B, X)，输出的(A, B, X)】 满足判定覆盖的测试用例： 【(2, 0, 4), (2, 0, 3)】覆盖ace 【(1, 1, 1), (1, 1, 1)】覆盖abd 条件覆盖 不仅每个语句至少执行一次，而且判定表达式中每个条件都取到各种可能的结果 条件覆盖不一定比判定覆盖强，甚至可能连语句覆盖都达不到 举个栗子： 本例中b处没有逻辑代码，如果有，则上面的第二种方案就达不到语句覆盖，但是能达到条件覆盖 判定/条件覆盖 判定覆盖不一定包含条件覆盖，条件覆盖也不一定包含判定覆盖，判定/条件覆盖能同时满足这两种覆盖标准 举个栗子： 条件组合覆盖 条件组合覆盖就是设计足够的测试用例，运行被测程序，使得每个判断的所有可能的条件取值组合至少执行一次 举个栗子： 所有可能的条件组合： 一个满足条件组合覆盖的测试方案 点覆盖 边覆盖 路径覆盖 控制结构测试 基本路径测试 (master) 根据过程设计结果画出相应的流图 计算流图的环形复杂度n 确定线性独立路径的基本集合（找到n条能覆盖整个流图的独立路径） 独立路径指至少引入程序一个新处理语句集合或一个新条件的路径，用流图术语描述，独立路径至少包含一条在定义该路径之前不曾用过的边 程序的环形复杂度决定了程序中独立路径的数量 在不考虑业务逻辑的情况下找到的路径有可能是无效的（多个判定条件之间可能有一定联系，导致某个独立路径上的判定条件无法同时满足） 设计可强制执行基本集合中每条路径测试用例 举个栗子： 环形复杂度：6 路径： 路径1：1-2-10-11-13 路径2：1-2-10-12-13 路径3：1-2-3-10-11-13 路径4：1-2-3-4-5-8-9-2··· 路径5：1-2-3-4-5-6-8-9-2··· 路径6：1-2-3-4-5-6-7-8-9-2··· 路径4、5、6后面的省略号(…)表示，可以后接通过控制结构其余部分的任意路径(例如，10-11-13) 条件测试 (pass) 循环测试 (pass) 简单循环 串接循环 嵌套循环 黑盒测试技术 (master) 黑盒测试着重测试软件的功能需求，让软件工程师设计出能充分检查程序所有功能需求的输入条件集 黑盒测试和白盒测试两者互补(A代表需求，B代表实现) 白盒测试至多能覆盖实现 黑盒测试至多能覆盖需求 只有两者结合使用才能做到全方位的测试 白盒测试在测试过程的早期阶段进行，而黑盒测试主要用于测试过程的后期 黑盒测试力图发现下述类型的错误：① 功能不正确或遗漏了功能；② 界面错误；③ 数据结构错误或外部数据库访问错误；④ 性能错误；⑤ 初始化和终止错误 等价划分 目的 需要研究程序的功能说明，确定输入数据的有效等价类和无效等价类 经验 如果规定了输入值的范围，则可划分出一个有效的等价类(输入值在此范围内)，两个无效的等价类(输入值小于最小值或大于最大值) 如果规定了输入数据的个数，则类似地也可以划分出一个有效的等价类和两个无效的等价类 如果规定了输入数据的一组值，而且程序对不同输入值做不同处理，则每个允许的输入值是一个有效的等价类，此外还有一个无效的等价类(任一个不允许的输入值) 如果规定了输入数据必须遵循的规则，则可以划分出一个有效的等价类(符合规则)和若干个无效的等价类(从各种不同角度违反规则) 如果规定了输入数据为整型，则可以划分出正整数、零和负整数等三个有效类 如果程序的处理对象是表格，则应该使用空表，以及含一项或多项的表 边界值分析 处理边界情况时程序最容易发生错误 边界值处测试数据的选取 刚好等于 刚刚小于 刚刚大于 栗子： 错误推测 错误推测法在很大程度上靠直觉和经验进行 基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案 调试 调试(也称为纠错)作为成功的测试的后果而出现，即调试是在测试发现错误之后排除错误的过程 调试不是测试，但是它总是发生在测试之后 途径： 蛮干法：打印内存数据、关键输出、断点 回溯法：由症状回推可能的原因 原因排除法：对分查找、归纳、演绎等方法 软件可靠性]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（五）]]></title>
    <url>%2F2017%2F12%2F23%2F2017-12-23-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88e%EF%BC%89%2F</url>
    <content type="text"><![CDATA[详细设计阶段的任务还不是具体地编写程序，而是要设计出程序的“蓝图”，以后程序员将根据这个“蓝图”写出实际的程序代码。 结构程序设计 (master)如果一个程序的代码块仅仅通过顺序、选择和循环这三种控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。 三种基本控制结构 关于GOTO语句 上面关于结构化程序经典定义过于狭隘，结构程序设计本质上并不是无GO TO语句的编程方法，而是一种使程序代码容易阅读、容易理解的编程方法 大多数情况下，无GO TO的代码确实是容易阅读、容易理解，但在某些情况下，为达到容易阅读和容易理解的目的，需要使用GO TO语句 结构程序设计是尽可能少用GO TO语句的程序设计方法。最好仅在检测出错误时才使用GO TO语句，而且应该总是使用前向GO TO语句 但是一般题目中问一段代码为什么不是结构化程序，很大可能是使用了GOTO语句 经典的结构程序设计 如果只允许使用顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这三种基本控制结构，则称为经典的结构程序设计 扩展的结构程序设计 如果除了上述三种基本控制结构之外，还允许使用DO-CASE型多分支结构和DO-UNTIL型循环结构，则称为扩展的结构程序设计 修正的结构程序设计 如果再加上允许使用LEAVE(或BREAK)结构，则称为修正的结构程序设计。 人机界面设计 (cut)人机界面设计是接口设计的一个组成部分 设计问题 系统响应时间 用户帮助设施 出错信息处理 命令交互 设计过程 用户界面设计是一个迭代的过程，也就是说，通常先创建设计模型，再用原型实现这个设计模型，并由用户试用和评估，然后根据用户的意见进行修改 界面设计指南 一般交互指南 保持一致性 提供有意义的反馈 在执行有较大破坏性动作之前要求用户确认 允许取消大多数操作 减少在两次操作之间必须记忆的信息量 提高对话、移动和思考的效率 允许犯错误 按功能对动作分类，并据此设计屏幕布局 提供对用户工作内容敏感的帮助设施 用简单动词或名词短语作为命令名 信息显示指南 只显示与当前工作内容有关的信息。 用户在获得有关系统的特定功能的信息时，不必看到与之无关的数据、菜单和图形。 不要用数据淹没用户 使用一致的标记、标准的缩写和可预知的颜色 允许用户保持可视化的语境 产生有意义的出错信息 使用大小写、缩进和文本分组以帮助理解 使用窗口分隔不同类型的信息 使用“模拟”显示方式表示信息 高效率地使用显示屏 数据输入指南 尽量减少用户的输入动作 保持信息显示和数据输入之间的一致性 允许用户自定义输入 交互应该是灵活的 使在当前动作语境中不适用的命令不起作用 让用户控制交互流 对所有输入动作都提供帮助 消除冗余的输入 过程设计的工具 (master)图形、表格、语言 程序流程图 程序流程图又称为程序框图，是历史最悠久使用最广泛的描述过程设计的方法，然而也是用得最混乱的一种方法 缺点： 绘制随意，容易只考虑流程控制而不考虑全局结构，而破坏结构化程序设计 不容易表示数据结构 程序流程图中使用的符号 盒图（N-S图） 盒图没有箭头，因此不允许随意转移控制。坚持使用盒图作为详细设计的工具，可使程序员逐步养成用结构化的方式思考问题和解决问题的习惯 能保证设计出的程序一定是结构化的 但是绘制的时候受空间限制，难以扩充 盒图的基本符号 PAD图（Problem Analysis Diagram） 它用二维树形结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易 与盒图相比，不受空间限制，易于扩充 可保证设计出来的程序一定是结构化的 PAD图的基本符号 (a) 顺序(先执行P1后执行P2)； (b) 选择(IF C THEN P1 ELSE P2)； (c) CASE型多分支；(d) WHILE型循环(WHILE C DO P)； (e) UNTIL型循环(REPEAT P UNTIL C)； (f) 语句标号； (g) 定义 可使用PAD提供的定义功能来逐步求精 判定表 当算法中包含多重嵌套的条件选择时，判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系 判定树 比判定表直观，包含判定的先后顺序 父节点：判定条件 叶子节点：一个动作 过程设计语言（PDL: Process Design Language） 伪代码 程序复杂度的定量度量 (master)常用的方法有McCabe方法（采用流图）、Halstead方法，下面仅介绍第一种 McCabe 方法 流图 为了突出表示程序的控制流，可以使用流图(也称为程序图) 流图仅描绘程序的控制流程，完全不表现对数据的具体操作以及分支或循环的具体条件。 流图用圆表示节点，一个圆代表一条或多条语句（如果多条语句在一个顺序结构上，可以省略中间，只画两边的节点） 流图中的箭头线称为边，和程序流程图中的箭头线类似，代表控制流 由边和节点围成的面积称为区域，区域数应该包括图外部未被围起来的区域。 基本结构： 把程序流程图映射成流图(a)程序流程图；(b)流图 PDL翻译成流图 123456789101112131415procedure: sort do while records remain read record; if record field1 = 0 then process record; store in buffer; incremert counter; elseif record filed2 = 0 then reset counter; else process record; store in file; endif endif enddo end 由包含复合条件的PDL映射成的流图 流图环形复杂度的计算 流图中的区域数等于环形复杂度 流图G的环形复杂度V(G)＝E-N+2，其中E是流图中边的条数，N是流图中节点数 流图G的环形复杂度V(G)＝P+1，其中P是流图中判定节点的数目 举个栗子： 上图中共有四个区域，故环形复杂度为4 上图中共有11条边，9个点，所以环形复杂度位：11 - 9 + 2 = 4 上图中共有三个判定节点，分别为”1”, “2,3”, “6”，所以环形复杂度为：3 + 1 = 4 PS: 在计算区域数的时候别忘了包括最外围的区域 在计算判定节点的时候，不仅包括条件分支的判断，循环判定的节点也算]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（四）]]></title>
    <url>%2F2017%2F12%2F23%2F2017-12-23-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88d%EF%BC%89%2F</url>
    <content type="text"><![CDATA[结构化设计（Structured Design, SD） (整体understanding)结构化设计工作通常划分为概要设计和详细设计两个阶段 概要设计又称总体设计或初步设计 概要设计的主要任务：分析软件规格说明（来自需求分析的输出）,对软件进行功能分解，划分为模块，设计出模块结构 详细设计阶段：详细设计每个模块，确定每个模块功能的算法和数据结构 设计过程总体设计过程通常由两个主要阶段组成：系统设计阶段，确定系统的具体实现方案;结构设计阶段，确定软件结构。 设想供选择的方案 选择合理的方案 推荐最佳方案 功能分解 设计软件结构 设计数据库 制定测试计划 书写文档 复查和复审 设计原理 模块化 概念 模块是由边界元素限定的相邻的程序元素的序列，而且有一个总体标识符来代表。 面向对象范型中的对象是模块，对象内的方法也是模块。模块是构成程序的基本构件。 每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求 模块化和软件成本 每一个程序都相应地有一个最适当的模块书目M，使系统的开发成本最小 优点 结构清晰 容易阅读和理解 容易测试和调试 有助于提高软件的可靠性 可修改性 便于组织和管理 抽象 把事物、状态或过程之间存在的共性集中概括起来，暂时忽略他们之间的差异，这就是抽象 逐步求精 为了能集中精力解决主要问题而尽量推迟对问题细节的考虑 求精实际上就是细化的过程 抽象与求精是一对互补的概念 抽象使得设计者能够说明过程和数据，同时却忽略低层细节。 抽象是一种通过忽略多余的细节同时强调有关的细节，而实现逐步求精的方法。 求精则帮助设计者在设计过程中揭示出低层细节。 这两个概念都有助于设计者在设计演化过程中创造出完整的设计模型。 信息隐藏和局部化 一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的 模块独立 （master） “模块独立”概念是模块化、抽象、逐步求精和信息隐藏等概念的直接结果，也是完成有效的模块设计的基本标准。可以由两个定性标准来度量，这两个标准分别称为内聚和耦合。 耦合：耦合衡量不同模块彼此间互相依赖(连接)紧密程度 内聚：内聚衡量一个模块内部各个元素彼此结合的紧密程度 对于模块设计，我们一般追求：模块内部高内聚，模块之间低耦合 耦合 非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，非直接耦合的模块独立性最强，模块间的耦合程度最低 数据耦合：通过简单的数据参数传递产生的耦合，是一种低耦合 标记（特征）耦合： 传递参数表记录信息，如文件、数组、指针等。 当把整个数据结构当做参数传入模块，但是模块实际上只需要其中的一部分元素 控制耦合： 传递的信息中有控制信息，有可能是一个简单变量，但可能改变程序流程。 它是中等程度的耦合，增加了系统的复杂程度，适当分解可以用数据耦合替代它。 外部耦合：一组模块都访问同一全局简单变量 公共环境耦合：一组模块访问同一个公共数据环境 内容耦合： 一组模块使用另一模块内部数据；模块通过非正常渠道进入另一模块执行 这是最高程度的耦合 使用原则：尽量使用数据耦合，少用控制耦合，限制公共环境耦合的范围，完全不用内容耦合。 内聚 理想内聚的模块只做一件事情，设计模块时，通常追求模块内部是高内聚的内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合 低内聚： 偶然内聚 逻辑内聚 时间内聚 中内聚 过程内聚 通信内聚 高内聚 顺序内聚（信息内聚） 功能内聚 启发规则长期实践经验所得，有助于实现有效的模块化 改进软件结构提高模块独立性 模块规模应该适中 深度、宽度、扇出和扇入都应适当 深度：树高 宽度：某层最大模块数 扇出：直接控制的模块数 扇入：有多少个上机的模块直接指向它 模块的作用域应该在控制域之内 如图所示，A的控制域就包括BCDEF 如果G也在A的作用域之内，则就不是一个合理的设计 应该把G下放一层，放在A的控制域之内 力争降低模块接口的复杂程度 设计单入口单出口的模块 模块功能应该可以预测 相同输入，得到可预测的想通过输出 描绘软件结构的图形工具 （master）层次图、HIPO图和结构图 层次图 层次图也称H图 在层次图中一个矩形框代表一个模块，框间的连线表示调用关系(位于上方的矩形框所代表的模块调用位于下方的矩形框所代表的模块)。 HIPO图 HIPO图是美国IBM公司发明的“层次图加输入/处理/输出图”的英文缩写。 为了使HIPO图具有可追踪性，在H图(即层次图)里除了顶层的方框之外，每个方框都加了编号。 然后每个方框对应用一张IPO图来描述，IPO图中应该明显的标出其在上述改进的H图中的编号 结构图（了解） 结构图和层次图类似，也是描绘软件结构的图形工具 结构图中带注释的箭头表示模块调用过程中来回传递的信息 尾部是空心圆表示传递的是数据，实心圆表示传递的是控制信息 其它符号 判定为真时调用A，为假时调用B 模块M循环调用模块A，B，C 面向数据流的设计方法 （understanding）面向数据流的设计方法的目标是给出设计软件结构的一个系统化的途径。它定义了一些不同的“映射”，利用这些映射可以把数据流图变换成软件结构 概念 变换流 信息通常以“外部世界”的形式进入软件系统，经过处理以后再以“外部世界”的形式离开系统 事物流 接收输入数据（输入数据又称为事物） 分析每个事物，以确定它的类型 根据事务类型选取一条活动的通路 设计过程 变换分析 复查基本系统模型 复查并精化数据流图 确定数据流图具有变换特性还是事务特性 确定输入流和输出流的边界，从而孤立出变换中心 完成“第一级分解” … 完成“第二级分解” 未精化的输入结构 未精化的变换结构 未精化的输出结构 使用设计度量和启发规则对第一次分割得到的软件结构进一步精化 事务分析 虽然在任何情况下都可以使用变换分析方法设计软件结构，但是在数据流具有明显的事务特点时，也就是有一个明显的“发射中心”(事务中心)时，还是以采用事务分析方法为宜。 事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同。 对于一个大系统，常常把变换分析和事务分析应用到同一个数据流图的不同部分，由此得到的子结构形成“构件”，可以利用它们构造完整的软件结构 事务分析的映射方法： 设计优化（refactoring） P112]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（三）]]></title>
    <url>%2F2017%2F12%2F22%2F2017-12-22-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88c%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述需求分析是发现、求精、建模、规格说明和复审的过程。 准则 必须理解和表示问题的信息域，根据这条准则应该建立数据模型。 必须定义软件应完成的功能，这条准则要求建立功能模型。 必须表示作为外部事件结果的软件行为，这条准则要求建立行为模型。 必须对描述信息、功能和行为的模型进行分解，用层次的方式展示细节。 分析过程应该从要素信息移向实现细节 业务 → 技术 逻辑 → 物理 要素 → 细节 需求分析的任务 确定对系统的综合要求 数据要求 功能需求 性能需求 可靠性和可用性需求 出错处理需求 接口需求 约束 逆向需求（不应该做的） 将来可能提出的要求 分析系统的数据要求 任何软件系统本质上都是信息处理系统 建立数据模型（E-R图） 数据字典 层次方框图 Warnier图 导出系统给的逻辑模型 数据流图、E-R图、状态转换图、数据字典、算法描述 修正系统的开发计划 与用户沟通获取需求的方法 访谈 面向数据流自顶向下求精 简易的应用规格说明技术 快速建立软件模型 快速原型应该具备的第一个特性是“快速”。 快速原型应该具备的第二个特性是“容易修改”。 分析建模与规格说明实体——联系图（E-R图） (master)数据模型包含三种相互关联的信息：数据对象、描述数据对象属性及数据对象彼此间相互连接的关系 ER图中包含实体(即数据对象)、关系和属性三种基本成分。 数据规范化一、二、三范式 状态转换图 (master)状态转换图(状态图)通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为一个状态图只能描述一个对象的行为变化，包括一系列状态、事件以及状态之间的转移 状态和事件 状态：状态是任何可以被观察到的系统行为模式（当前对象属性值的集合） 事件：事件在某个特定个时刻发生的事情，引起系统从一个状态转换到另一个状态 符号 初态：实心圆 终态：一对同心圆 中间状态：用圆角矩形表示，可分为三部分：状态名、状态变量、活动表（其中状态名是必选的，其余两个是可选的） 活动表的语法格式：事件名（参数表）/ 动作表达式 entry (在进入该状态时执行) exit （退出该状态时执行） do （在该状态下一直执行） 状态转换：两个状态之间带箭头的连线，箭头指明了转换方向 连线上通常标出导致状态转化的触发事件 触发事件表达式的语法：事件说明[守卫条件]/动作表达式 事件说明：事件名（参数表） 守卫条件：一个布尔表达式 动作表达式：是一个过程表达式，当状态转换开始后时执行该表达式 栗子： 状态转换 简单转移 自转移 （自己转移到自己，需要事件触发） 自动转移 （通常是本状态需要做的一个活动完成时转换到下一个状态） 复合转移 组合状态————子状态 一个状态下可以嵌套许多子状态 顺序子状态 =&gt; 子状态是串行连续变化的 并发子状态 =&gt; 存在并发存在互不影响的子状态 补充 同步 分劈（Fork） 接合（Join） 伪状态 符号用圈里面一个*表示 用来表示并发状态的同步 在子状态图之间使用（放在分隔子状态的虚线上） 历史状态 符号用圈里面一个H表示 记录在离开某个状态时，其处于哪个子状态中 对于同一层级的状态来说，初态只有一个，终态可以有多个 其它图形工具 层次方框图 层次方框图用树形结构的一些列多层次的矩形框描绘数据的层次结构 Warnier图 IPO图 IPO图是输入、处理、输出图的简称 左边框中列出有关的输入 中间框中列出主要的处理 右边框中列出产生的输出 处理的顺序暗示了执行的顺序 箭头指出数据通信的情况 验证软件的需求（了解）验证软件的一致性、完整性、现实性和有效性]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（二）]]></title>
    <url>%2F2017%2F12%2F22%2F2017-12-22-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88b%EF%BC%89%2F</url>
    <content type="text"><![CDATA[可行性研究的任务不是解决问题，而是确定问题是否值得去解决。 分析可能的解法 判定系统规模和目标是否能够实现 效益是否可观 较高层次的系统分析和设计过程 技术可行性：开发此系统是可行的，是有好处的 经济可行性：根据系统目标衡量所需技术是否具备 操作可行性：系统是否易于使用并能够创造价值 法律可行性：是否存在侵犯、妨碍和责任等问题 可行性研究过程（understanding）了解就好 复查系统规模和目标 改正含糊或不确切的叙述 清晰地描述限制和约束 确保分析员解决正确的问题 研究目前正在使用的系统 完成现有系统的基本功能分析 解决现有系统的问题 绘制高层系统数据流图 掌握与其他系统的接口 导出新系统的高层逻辑模型 现有物理系统 → 现有系统的逻辑模型 → 目标系统逻辑模型 → 新的目标系统 高层数据流图 初步的数据字典 进一步定义问题 以数据流图和数据字典为基础 复查问题定义、工程规模和目标 分析员和用户 重复1~4步，直至提出的逻辑模型完全符合系统目标 导出和评价供选择的解法 从技术角度出发，考虑解决问题的不同方案 技术可行性，排除不现实的系统 操作可行性，排除用户不能接受的方案 经济可行性，排除利润低的方案 制定进度表 (估算生命周期每个阶段的工作量) 推荐行动方针（是否做？） 分析员：如果值得开发，则选择最好的解法 用户：成本/效益分析 草拟开发计划 工程进度表 各类开发人员、各种资源需求情况 生命周期每个阶段的成本 下一个阶段详细进度表和成本估计 书写文档提交审查 用户、客户组织负责人、评审组审查 系统流程图 （understanding）系统流程图概括描绘物理系统的传统工具用图形符号，以黑盒子形式描述组成系统的每个部件程序、文档、数据库、人工过程 符号： 栗子： 数据流图 (master)数据流图(DFD) 描绘信息流和数据从输入移动到输出的过程中所经受的变换。 数据流图的四种基本符号： 加工中常见关系的符号表示： 注意： 信息的流动 信息流不能为动词 实体到实体的信息流动 处理要有输入输出 处理名不能为名词 确保层间的一致性（确保输入输出流的量是一致的） 命名: 数据流的名字应代表整个数据流(数据存储、处理)的内容，而不是仅仅某些成分。 不要使用空洞的、缺乏具体含义的名字(如“数据”、“信息”、“输入”之类)。 处理名字最好是一个具体的及物动词。 示例：出入库管理系统 0级数据流图 1级数据流图 2级数据流图 数据字典 (master) 数据字典是关于数据的信息的集合，即对设计图中包含的元素的定义。 数据字典的用途是供人查阅不了解的条目的解释，提供分析设计过程中关于数据的描述。 只有设计图和对应的元素的精确定义放在一起，才能构成系统完整的规格说明。 定义数据的方法 = : 意思是等价于(或定义为); + : 意思是和(即，连接两个分量); [] : 意思是或(即，从方括弧内列出的若干个分量中选择一个)，用“｜”号分开供选择的分量; {} : 意思是重复(即，重复花括弧内的分量); () : 意思是可选(即，圆括弧里的分量可有可无); 使用上限和下限进一步注释表示重复的花括弧。 左边用上角标和下角标分别表明重复的上限和下限 左侧标明重复的下限，在闭括弧的右侧标明上限 例如： 举个栗子： 北京某高校可用的电话号码有以下几类:校内电话号码由4 位数字组成，第1位数字不是0;校外电话又分为本市电话和外地电话两类,拨校外电话需先拨0,若是本市电话则再接着拨8位数字(第1位不是0),若是外地电话则拨3位区码再拨8位电话号码(第1位不是0)。请用上述提到的定义数据的方法，定义上述的电话号码。1234567891011电话号码 = [ 校内电话号码 | 校外电话号码 ]校内电话号码 = 非零数字 + 3位数字校外电话号码 = [ 本市电话号码 | 外地电话号码]本市电话号码 = 数字零 + 8位数字外地电话号码 = 数字零 + 3位数字 + 8位数字非零数字 = [1|2|3|4|5|6|7|8|9]3位数字 = 3&#123;数字&#125;3数字零 = 08位数字 = 非零数字 + 7位数字7位数字 = 7&#123;数字&#125;7数字 = [0|1|2|3|4|5|6|7|8|9] 数字字典的实现 CASE工具 人工卡片 成本效益分析（了解）成本/效益分析是客户从经济角度判断是否继续投资项目的主要依据。 成本估计 代码行技术 任务分解技术 效益分析 货币的时间价值 投资回报期 纯收入 投资回报率（最重要的参考数据）]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习（一）]]></title>
    <url>%2F2017%2F12%2F22%2F2017-12-22-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%EF%BC%88a%EF%BC%89%2F</url>
    <content type="text"><![CDATA[软件危机（understanding）软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重的问题 软件危机的表现 对开发成本和进度的估计往往很不准确 用户对“已完成的”软件系统不满意的现象时常发生 软件质量差 软件通常难以维护 软件没有适当的文档资料 软件成本在计算机系统的总成本中所占的比例逐年上升（软件成本日益增长） 软件开发速度跟不上计算机发展速度 产生软件危机的原因 技术原因 软件规模越来越大 软件复杂度越来越高 管理原因 软件开发缺乏正确的理论指导，过分依赖个人技巧和创造性 对用户需求没有完整准确的认识，就匆忙着手编写程序 引入统一变动付出代价随时间变化的趋势 上图展示的就是软件开发过程中，需求变化出现在开发过程的后期将会带来巨大的修改代价 所以应该在软件开发的早期，甚至是定义的时候就尽量的接近用户的真是需求 但通常，用户的牙膏不会一下子挤完（甚至一开始，大多数用户对自己的需求都不是很明确） 如何克服软件危机？ ==&gt; 软件工程 消除软件危机的途径 对计算机软件的正确认识 1983年IEEE对软件的定义：计算机程序、方法、规则、相关的文档资料以及在计算机上运行程序时所必须的数据 软件 ≠ 程序 软件工程三要素 推广使用开发软件成功的技术和方法，并且研究探索更好有效的技术和方法 开发和使用更好的软件工具 需要组织管理措施（过程） 总之，为了解决软件危机，既要有技术措施（方法和工具），有要有必要的组织管理措施。 无章法（个人英雄主义）=&gt; 工程项目管理模式（团队合作开发） 软件工程(understanding)1968第一届NATO会议：软件工程称就是为了经济的获得可靠的且在实际机器上有效运行的软件，而建立和使用的完善的工程原理1993年IEEE： 把系统的、规范的、可度量的途径应用于软件开发、运行和维护的过程，也就是把工程应用于软件 研究1中提到的途径 主要目标：高效开发高质量软件 软件工程的基本原理 用分阶段的生命周期计划严格管理 坚持进行阶段评审 错误发现的越晚，所需付出的代价也越大 对每个已完成的阶段进行评审，以便尽早发现错误 实行严格的产品控制 软件开发过程中不应该随意改动需求，对修改意见需要经过严格的评审后才能实施 采用现代化程序设计技术 结果应该能清楚的审查 开发小组的成员应该少而精 承认不断改进软件工程实践的必要性 软件工程方法学 通常把在软件生命周期全部过程各种使用的一整套技术方法的集合称为方法学（methodology）,也称为泛型（paradigm） 软件工程方法学3要素 方法：“如何做？” 工具：“用什么做？” 过程：“如何控制、协调、保证质量？” 传统方法学（静态分析） 传统方法学也称为生命周期方法学或结构化泛型，它采用结构化技术 这种方法学把软件生命周期的全过程依次划分为若干阶段，然后顺序的完成每个阶段的任务 特点： 生命周期模型 软件过程划分为若干个阶段 每个阶段有各自的任务 阶段之间有某种顺序性 局限： 当软件规模较大，或对软件的需求是模糊的或随时间变化的时候，使用结构化泛型开发软件往往不成功 此外，使用传统方法学开发出的软件通常维护起来都很困难 面向对象方法学（动态分析） 特点： 面向对象方法学的出发点和基本原则，是尽可能模拟人类的思维方式 用面向对象方法学开发软件的过程，是一个主动多次反复迭代演化的过程 概念和表示方法上的一致性，阶段间平滑（无缝）过度 特殊到一般的归纳思维过程；一般到特殊的演绎思维过程（继承的思想） 软件生命周期 (重点)概括的说，软件生命周期由软件定义、软件开发和运行维护（也称为软件维护）3个过程 问题定义 要解决什么问题？ 可行性研究 对上一阶段确定的问题是否有行之有效的解决方案？ 需求分析 目标系统必须做什么？用正式的文档记录对目标系统的需求（规格说明） 总体设计（概要设计） 概括的说，应该怎样实现目标系统？（从此阶段开始设计实现和技术的细节）又称为初步设计、逻辑设或、概要设计或高层设计 详细设计 把上阶段提出的解决方案具体化，回答“应该如何具体的实现这个系统？”又称为模块设计、物理设计或低层设计 编码和单元测试 具体coding。写出正确的容易理解、容易维护的程序模块，并测试 综合测试 集成测试、验收测试、系统测试 软件维护 通过各种必要的维护活动使系统持久地满足用户的需要 四类维护活动 改正性维护：诊断和改正真在使用过程中发现的软件错误 适应性维护：即修改软件以适应环境的变化 完善性维护：即根据用户的要求改进或扩充软件使它更完善 预防性维护：即修改软件为将过来的维护活动预先做准备 软件过程 （重点）软件过程是为了获得赶工质量软件所需要完成的一些列的任务的框架，它规定了完成各项任务的工作步骤 瀑布模型 阶段间具有顺序性和依赖性 推迟实现的观点 清楚的区分逻辑设计与物理设计，尽可能推迟程序的物理实现 质量保证的观点 每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务 每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误 瀑布模型的成功过在很大程度上由于它基本上是一种文档驱动的模型 优点：可强迫开发人员采用规范的方法（例如，结构化技术）； 严格地规定了每个阶段必须提交的文档；要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证 缺点：瀑布模型是由文档驱动的。由于瀑布模型几乎完全依赖于书面的规格说明，很可能导致最终开发出的软件产品不能真正满足用户的需要。 适用范围：应用需求明确的项目 快速原型模型 快速建立起可以运行的程序，其功能往往是最终产品功能的子集 通过将简单的模型给用户试用，以获取到用户更多更详细的需求（努力挤牙膏） 快速原型的本质是“快速” 原型的用途是获取用户的真正需求，一旦需求确定了，原型将被抛弃（原型通常没有严格的规范化，缺少文档，难以维护）。 优点：软件产品的开发基本上是线性顺序进行的 原型系统已经通过与用户交互而得到验证，据此产生的规格说明文档正确地描述了用户需求，，不会因为规格说明文档的错误而进行较大的返工。 开发人员通过建立原型系统已经学到了许多东西，在设计编码阶段发生错误的可能性比较小，自然减少了反馈。 缺点： 缺乏丰富而强有力的软件工具和开发环境。 缺乏有效的管理机制，还未建立起自己的开发标准。 对设计开发环境要求较高。 在多次重复改变原型的过程中，程序员会感到厌倦。 系统的易变性对测试有一定影响，难于做到彻底测试，更新文档较为困难。 适用范围：有结构的系统或者需求不明确的系统 增量模型 增量模型也称为渐增模型。把软件产品作为一系列增量构件来设计、编码、集成和测试 每个构件由多个相互作用的模块构成，并且能够完成特定的功能。 使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能。(滚雪球方式) 与瀑布模型相比： 瀑布模型：力求一次性给用户完整的系统。 增量模型：逐步增加系统功能。 增量模型： 一种风险更大的增量模型 优点： 能在较短时间内向用户提交可完成部分工作的产品 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。 缺点：待解决的问题必须允许有一个可递增的软件解决方案。如果需要的软件必须将所有的功能表现出来，那么递增的模型是不合适的。还有就是为了递增模型成功，必须找出整个系统的体系结构。 适用范围：不能在设定的期限内完成产品时，先推出核心产品 使用这种方法将冒构件无法集成到一起的风险，除非密切地监控整个开过程 螺旋模型 螺旋模型的基本思想是使用原型及其他方法尽量降低风险。 简化的螺旋模型 可以在一定程度上降低风险，但对有些风险也是无能为力的 需要专业的风险评估人员 完整的螺旋模型 优点： 对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标 减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险 在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别 缺点：仅适用于内部项目，大型项目受限，需要风险分析专家。 适用范围：主要适用于内部开发的大规模软件项目。 喷泉模型 迭代是OO开发过程的主要特性。 喷泉模型是典型的面向对象生命周期模型。 “喷泉” 体现了面向对象软件开发过程迭代和无缝的特性。 为避免喷泉模型的过分无序，把一个线性过程作为总目标。 迭代：逐步求精 阶段间没有明显的界限－面向对象的思想保证了各个阶段开发的一致性。 喷泉模型： Rational统一过程 敏捷过程与极限编程 敏捷软件开发宣言 个体和交互胜过过程和工具（Individuals and interactions over processs and tools） 可以工作的软件胜过面面俱到的文档（Working software over comprehensive socumentation） 客户合作胜过合同谈判（Customer collaboration over contract negotiation） 响应变化胜过遵循计划（Responding to change over following a plan） 敏捷软件开发的原理（The principles of agile methods） 客户参与（Customer involvement） 增量交付（Incremental delivery） People not process 拥抱变化（Embrace change） 保持简单（Maintain simplicity） 极限编程有效实践（极限编程是敏捷过程中最富盛名的一个） Incremental planning Small releases Simple design Test-first development Refactoring Pair programming Collective ownership Continuous integration Sustainable pace On-site customer 适用范围： 项目团队的人数不能太多 项目经常发生变更 高风险的项目实施 开发人员可以参与决策]]></content>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（补充）——分解算法浅析]]></title>
    <url>%2F2017%2F11%2F11%2F2017-11-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面：今天笔者将会对BCNF和3NF分解算法做简要的分析，不过实际上大多数的分解用肉眼即可，以下分解算法不依赖于过多的条件可以直接讲一个满足1NF的模式分解为3NF或BCNF BCNF 分解算法 教材上关于BCNF分解算法的伪代码实现有部分印错（本科教学版） 该算法的结果是一个满足BCNF的无损分解，但可能不是保持依赖的（毕竟3NF是保持依赖并且可以满足无损分解的最高范式） 伪代码实现对满足1NF的模式R作如下处理可分解成满足BCNF范式的模式R1, R2, …, Rn 12345678910result := &#123;R&#125;; done := false; 计算F+; while(not done) do if(result中存在模式Ri不属于BCNF) then begin 令 α→β 为一个在Ri上成立的非平凡函数依赖，满足 α→β ∈ F+， 并且 α∩β = ∅; result := (result - Ri) ∪ (Ri - β) ∪ (α, β) end else done := true 先来分析一波上面的代码吧 首先令reslut = {R} 接着计算一下F的函数闭包F+（计算函数闭包还是挺麻烦的，所以在下面判断的时候挑一个函数依赖，判断一下是否被F逻辑蕴含即可） 然后判断结果集result中是否还存在哪个模式不满足BCNF范式，如果都满足，则直接跳到步骤5，如果存在某个模式 Ri ∈ result，不满足BCNF范式，则执行步骤4 选择一个在Ri上成立的非平凡函数依赖 α→β，并且 α→β 属于 F+，并且α∩β=∅。然后将模式Ri分解成两个模式，分别为 (Ri - β) 和 (α, β)。并且将Ri从result中移除，江新得到的两个模式添加到result中。接着回到步骤3继续判断 分解完成，输出结果 纸上学来终觉浅，让我们拿教材上的栗子出来刷一刷～～ 有模式class, 通过上述算法，对其进行满足BCNF范式的分解 U = {course_id, title, dept_name, credits. sec_id, semester, year, building, room_number, capticy, time_slot_id} F = {course_id → (title, dept_name, credits),(building, room_number)→capaticy,(course_id, sec_id, semester, year)→(building, room_number, time_slot_id)} 首先还是看一下上面模式的候选码是什么吧（书上的栗子是直接给出来了，但是有些题可能不给，需要自己算） 通过上一篇博客讲的候选码求解算法，容易求得模式class的候选码为{course_id, sec_id, semester, year} 接着判断模式class是否满足BCNF范式 模式R中存在依赖 course_id → (title, dept_name, credits), 但course_id并不是R的一个超码，故R不满足BCNF范式 对R做如下分解 course(course_id, title, dept_name, credits) class_1(course_id, credits. sec_id, semester, year, building, room_number, capticy, time_slot_id) 继续判断，易知course是满足BCNF范式的，而course_1同理不满足BCNF范式， 继续分解 找到非平凡依赖(building, room_number)→capaticy， 且其属于F 对class_1分解如下 classroom(building, room_number, capacity) section(course_id, credits. sec_id, semester, year, building, room_number, time_slot_id) 检测一下发现现在模式classroom和section也满足BCNF范式了 OK，原来的模式class现在分解为如下三个模式 course(course_id, title, dept_name, credits) classroom(building, room_number, capacity) section(course_id, credits. sec_id, semester, year, building, room_number, time_slot_id) 3NF分解算法以下分解算法中用到了正则覆盖的概念，这个笔者在之前的博客中也提到过，点我传送 该分解算法可以保持依赖，并且是无损分解 伪代码实现 123456789101112131415161718令Fc为F的正则覆盖;i:= 0;for each Fc 中的函数依赖 α→β i := i + 1 Ri := αβ;if 模式 Rj, j = 1, 2, ..., i 都不包含R的候选码then i := i + 1 Ri := R的任意候选码/*(以下代码可选)用来移除冗余关系，如果没有冗余关系则可以不care*/repeat if 模式 Rj包含于另一个模式Rk中 then /*删除Rj*/ Rj := Ri i := i - 1until 不再有可以删除的Rjreturn (R1, R2, ..., Ri) 老规矩，还是先分析一下上面的伪代码 首先求出F的正则覆盖Fc（实际上就是利用Amstrong公式化简原来的函数依赖集的过程） 接着将Fc中的每一个函数依赖单独分解成一个模式，得到一个模式列表S = {R1, R2, …, Ri} 如果上述模式列表S中的任意一个模式包含模式R的候选码，则跳到步骤5，否则执行步骤4 选取R的任意一个候选码，组成一个新的模式R’, 将R’添加到模式列表S中 （可选）如果模式列表中存在冗余（即某个模式被其他模式包含），则可以删除这个模式 输出S 讲真，3NF分解的步骤还是很简单的，主要还是计算一下F的正则覆盖，详细栗子就不举了，下面简单提一提 比如上面分析BCNF分解算法时用到的模式class， 利用上述算法分解之后可以得到和 利用BCNF算法分解一样的结果 所以，神奇的事情发生了，利用3NF分解算法得到的结果可能还会满足BCNF范式 实践中BCNF分解的另一种途径： 先用3NF算法分解，然后对结果中不满足BCNF范式的模式用BCNF分解算法分解，如果结果不保持依赖，则回退回3NF]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（补充）——候选码的确定方法]]></title>
    <url>%2F2017%2F11%2F10%2F2017-11-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E5%80%99%E9%80%89%E7%A0%81%E7%9A%84%E7%A1%AE%E5%AE%9A%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面：前面一堆都了解了解，重点在后面一个关于求候选码的算法（要是题里面没有给主属性，就要通过这个方法求哪些是主属性，哪些不是了，所以还是挺实用的） 候选码定义: 设K为关系模式R的属性(组)，若K→FU，则称K为R的 候选码。 主码：若R有多个候选码，则可以从中选定一个作为R的主码。 主属性：包含在任一个候选码中的属性，称作主属性。 非主属性：不包含在任一个候选码中的属性，称作非主属性(或非码属性)。 全码：关系模式的码由全部属性构成。 注: 码或者是某一函数依赖的左部, 或是一个属性组。 引例：求出关系模式R的所有候选码：U={ A , B , C , D , E }F={AB→C, B→D, C→E, EC→B, AC→B } 解： 验证AB是否码, 须证明 AB→FABCDE是否成立?∵AB→C(已知), 而AB→AB(自反), ∴AB → ABC(合并)∵B→D(已知), ∴AB→AD(增广), ∴AB → ABCD(合并)∵C→E(已知), AB→C(已知), ∴AB → E(传递) 于是 AB → ABCDE(合并) 同理可证：AC也是一个候选码 上述例题实际上就是利用Amstrong公式，最后得到一个属性集可以推出U（关系模式的全集） 练习： 根据码的定义，求关系模式R的所有候选码。U={ A , B , C , D }， F={A→ B, C→B } 答：ACD 关于2NF的结论 不存在非主属性的关系模式属于2NF。 （没有非主属性） 全码关系模式属于2NF。 （没有非主属性） 码只由一个属性组成的关系模式属于2NF。（不会有部分依赖） 二目关系模式属于2NF。 （码或是一个属性，或是全码） 若R属于1NF，但R不一定属于2NF。例如, 关系模式 S(S#, SN, SD, DEAN, C#, G) 关于3NF的结论 不存在非主属性的关系模式属于3NF。 （没有非主属性） 全码关系模式属于3NF。 （没有非主属性） 二目关系模式属于3NF。 （不会存在传递依赖） 若R属于3NF，那么R也属于2NF。（可证明，反证） 若R属于2NF，但R不一定属于3NF。例如，关系模式 S_SD(S#, SN, SD, DEAN) BCNF定义：关系模式R ∈1NF，对于属性组X和Y，若X→Y且Y ∉ X时X必含有码，则R ∈BCNF 由BCNF的定义，对于非平凡的函数依赖: X → Y X包含码，或者X本身就是码（换句话说，X是一个超码） 所有非主属性对每一个码都是完全函数依赖， 即, 若R∈BCNF, 则R∈2NF。 所有的主属性对每一个不包含它的码也是完全函数依赖。 没有任何属性完全函数依赖于非码的任何一组属性。 若R∈BCNF, 则必有R∈3NF; 反之不一定成立 铛铛铛！！！敲黑板，候选码的求解算法以下算法会涉及到求属性集的闭包，函数依赖集和属性集闭包传送阵 设关系模式R 将R的所有属性分为 L、 R、N和 LR四类，并令X代表L、N两类，Y代表LR类。 L类: 仅出现在F的函数依赖左部的属性； R类: 仅出现在F的函数依赖右部的属性； N类: 在F的函数依赖左右两边都不出现的属性； LR类:在F的函数依赖左右两边都出现的属性 。 求属性集闭包X+，若 X+包含了R的全部属性则X即为R的唯一候选码, 转5; 否则, 在Y中取一属性A，求属性集闭包(XA)+，若(XA)+包含了R的全部属性，则转4；否则，调换一属性反复进行这一过程，直到试完所有Y中的属性。 如果已找出了所有的候选码，则转(5)；否则在Y中依次取2个、3个、…属性，求X与它们的属性集闭包，直到其闭包包含R的全部属性。 停止，输出结果。 例1： 设关系模式R(A, B, C, D), 其函数依赖集：F={D→B, B→D, AD→B, AC→D}，求R的所有候选码。 解: L类: A, C R类: N类: LR类: B, D因为(AC)F+=ACDB，所以AC是R的唯一候选码 例2：设关系模式R(A, B, C, D, E, P), 其函数依赖集：F={A→D, E→D, D→B, BC→D, DC→A}，求R的所有候选码。 解: L类: C, ER类:N类: PLR类: A, B, D因为(CEP)F+=CEPDBA，所以CEP是R的唯一候选码。 例3： 设关系模式R(S, D, I, B, O, Q), 其函数依赖集:F = { S→D, I→B, B→O, O→Q, Q→I }，求R的所有候选码。 解: L类(S); R类(D) ; N类(无) ; LR类(I, B, O, Q)因为S+=SD, 所以S不是R的候选码； 因为(SI)+=SIDBOQ，所以SI是一个候选码； 因为(SB)+=SBDOQI，所以SB也是一个候选码； 因为(SO)+=SODQIB，所以SO也是一个候选码； 因为(SQ)+=SQDIBO，所以SQ也是一个候选码。]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（补充）——数据库设计和E——R模型]]></title>
    <url>%2F2017%2F11%2F08%2F2017-11-08-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%92%8CE%E2%80%94%E2%80%94R%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[实体—联系模型 实体集 实体（entity）：现实世界中一个可以区别于其他对象的一个“事物”或对象 实体集（entity set）：相同类型（即具有相同性质/属性）的实体的集合 外延（extension）：属于实体集的实体的实际集合 ps: 实体集和外延的关系类似于之前讲的模式和实例的关系 属性（attribute）：实体集中每个成员所具有的描述性性质 值（value）：每个实体的每个属性都有一个值 联系集 联系（relationship）：多个实体间的相互关联 联系集（relationship set）： 相同类型联系的集合 实体集之间的关联称之为参与：实体集E1, E2, E3 参与 联系集R 联系也可以具有 描述性属性 实体在联系中扮演的功能称为角色 参与联系集的实体集的数目称为联系集的度， 二元联系集的度为2 属性 域（domain）/ 值集：每个 属性 都有一个 可取值的集合 ，称为该属性的 域 或 值集 简单（simple） 和复合（composite）属性 简单属性不可以再分成更小的部分，而复合属性可以(例如下面的name即为复合属性) 单值（single-value）和多值（multivalued）属性 单值：一个实体在的单值属性只对应一个值 多值：一个实体的多值属性可以对应多个值（如，phone_number） 派生（derived）属性 派生属性的值可以从别的相关属性或实体派生出来 eg.:银行账户的余额可以从账户的存取款明细中计算出来 派生属性在原则上是不用保存的，但是有时候保存派生属性可以节约计算时间（空间换时间） 约束 映射基数约束 一对一（one-to-one） 一对多（one-to-many） 多对一（many-to-one） 多对多（many-to-many） 参与约束 全部参与：实体集E的每一个实体都参与到联系集R的至少一个联系中 部分参与：实体集E中只有部分实体参与到联系集R的联系中 码 超码 候选码 主码 #### 从实体集中删除冗余属性 要点： 删除其他实体的主键 其他实体的主键相当于外建的存在，一般属于联系集的属性 举个栗子： instructor(ID, name, dept_name, salary)，其中ID为主键 department(dept_name, building, budget)，其中dept_name为主键 属性dept_name在两个表中都出现了，所以它属于冗余属性，他又是department的主键，故应该将其从instructor表中移除（实际数据库实现的时候instructor表中是有一个dept_name属性的，他作为一个外建存在，实际上是两者的联系集是简单的1对多的关系，便没有单独成表，而是采用外键相联系） 实体——联系图 基本结构 分成两部分的矩形 代表 实体集 菱形 代表 联系集 未分割的矩形 代表 联系集的属性 线段 将实体集连接到联系集 虚线 将联系集属性连接到联系集 双线 显示实体在联系集中的参与度(用双线与联系集相连表示全部参与) 双菱形 代表连接到弱实体集的 标志性实体集 映射基数 一对一 一对多 多对一 多对多 balabala，图画起来太麻烦了，其他的直接看书，下面聊一聊弱实体集 弱实体集 定义：没有足够的属性以形成主码的实体集称之为 弱实体集（weak entity set） 先举个栗子：(由于简书不支持下划线的写法，所以下面表中所有的主码都用斜体表示) course (course_id, titles, credits) section (sec_id, semester, year) 对于上面的两个实体集，参与如下联系集 sec_course(course_id, sec_id, semester, year) 上面的section实体集实际上就是一个弱联系集 一个section实体如果不与一个course对相关联是毫无意义的，并且只有sec_id, semester, year三个属性也是决定不了一个section的 弱实体集必须于另一个称作标识（identifying）或属主和实体集（owner entity set）的实体集相关联才有意义 虽然弱实体集没有主码，但是本身仍要有在依赖于强实体集的基础上的进一步区分的方法，弱实体集的分辨符/部分码（discriminator）便可以用来做进一步的区分 上述例子中的sec_id, semester, year便组成了section的分辨符 在画ER图的时候，组成分辨符的属性底下画虚线（可参见教材 图7-5） 弱实体集的主码由 标识实体集的主码 加上 该弱实体集的分辨符 构成 ER图中的表示 组成分辨符的属性底下画虚线，而不是实线 关联弱实体集和标识性强实体集的联系集以双菱形表示 接着，只需要把教材图7-15的图看懂理解，ER图的绘制基本上就没有毛病了 ER图转换为关系模式这个不难下面简单列几点注意事项 复合属性 将每个子属性单独作为一个属性来处理 派生属性 不显示表示出来 多值属性 单独成表 弱实体集转换 对于从弱实体集转换而来的模式，该模式的主码由其所依赖的强实体集的主码与弱实体集的分辨符组成 联系集 多对多的情况一定单独成表 联系集拥有描述性属性的情况单独成表 其它情况下均可不单独成表 一对一情况下讲任意实体集的主键作为另一个实体集的外建均可 一对多和多对一的情况下，将“一”端的主键作为”多”端的外建]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（十二）——函数依赖理论和分解算法]]></title>
    <url>%2F2017%2F11%2F01%2F2017-11-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%90%86%E8%AE%BA%E5%92%8C%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[函数依赖理论 逻辑蕴涵 定义： 存在如下条件 关系模式：r(R) 依赖集：F （由一个或多个依赖组成） 依赖：f 若r(R)满足F ==&gt; r(R)满足f 我们称 F 逻辑蕴涵 f ps: 其中f可由F通过Armstrong公理推得 举个栗子： 给定关系模式 r(A, B, C, G, H, I) F包含如下依赖 A &rarr; B A &rarr; C CG &rarr; H CG &rarr; I B &rarr; H 函数依赖f : A &rarr; H 其中 f 被 F 逻辑蕴涵 由Amstrong传递公理可知：A &rarr; B, B &rarr; H ==&gt; A &rarr; H 函数依赖集的闭包 令 F 为一个函数依赖集。则 F的闭包 是 被 F 逻辑蕴涵的所有函数依赖的集合 记作：F+ Armstrong公理（Armstrong’s axiom） 公理是科学的客观规律，不需要自己证明，直接用就行 Armstrong 公理 自反律（reflexivity rule）。若α为一个属性集，且β⊆α， 则α&rarr;β 举个栗子：(A, B)&rarr;A 增补律（augmentation rule）。若α&rarr;β成立且γ为一属性集，则γα&rarr;γβ 举个栗子：(A, B)&rarr;C ==&gt; (A, B, D, E)&rarr;(C, D, E) 传递律（transitivity rule）。若α&rarr;β和β&rarr;γ成立，则 α&rarr;γ 成立 举个栗子：A&rarr;B, B&rarr;C ==&gt; A&rarr;C Armstrong公理是完备的，对于一个给定的函数依赖集F，通过Armstrong公理可以产生全部的F+ Armstrong公理的一些推论 可由Armstrong公理直接推得，也可以当做公理使用 合并律（union rule）。若α&rarr;β和α&rarr;γ成立，则α&rarr;βγ 举个栗子：A&rarr;B, A&rarr;C ==&gt; A&rarr;(B, C) 分解律（decomposition rule）。若α&rarr;βγ成立，则α&rarr;β和α&rarr;γ成立 举个栗子：A&rarr;(B, C) ==&gt; A&rarr;B, A&rarr;C 伪传递律（pseudotransitivity rule）。若α&rarr;β和γβ&rarr;δ成立，则αγ&rarr;δ成立 举个栗子：A&rarr;B, (B, C)&rarr;D ==&gt; (A, C)&rarr;D 属性集的闭包 令α为一个属性集，我们将函数依赖集 F 下被α 函数确定的所有属性的额集合为称为F下α的闭包 记作：α+ 伪代码如下：1234567result := α repeat for each 函数依赖 β→γ in F do begin if β ⊆ result then result := result ∪ γ end until(result 不变) 正则覆盖（极小函数依赖集） 如果去除函数依赖中的一个属性不改变函数依赖集的闭包，则称该属性是无关的 F的正则覆盖 Fc 是一个依赖集，使得F逻辑蕴涵Fc 中的所有依赖，并且Fc 逻辑蕴涵F中的所有依赖。此外，Fc 必须具有如下性质 ： Fc 中任何函数依赖都不含无关属性 Fc 中函数依赖的左半部都是唯一的。即Fc 中不存在两个依赖α1&rarr;β1和α2&rarr;β2， 满足α1=α2 无损分解 如果用两个关系模式r1(R)和r2(R)替代r(R)时没有信息损失，则我们称该分解时无损分解（lossless decomposition） SQL 表示 123-- 下面查询的结果与r具有相同结果的元组集SELECT *FROM r1 natural join r2 关系代数表示： ∏R1(r) ⋈ ∏R2(r) = r 分解算法（下回分解）]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（十一）—— 范式]]></title>
    <url>%2F2017%2F11%2F01%2F2017-11-01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一般而言，关系数据库的设计目标是生成一组关系模式，使我们存储信息时避免不必要的冗余，并且让我们可以方便地获取信息。这是通过设计满足适当范式（normal form）的模式来实现的。 引例 首先有如下两个模式 instructor( ID, name, dept_name, salary ) department( dept_name, building, budget ) 若将上面两个模式合并成一个大的模式 inst_dept(ID, name, salary, dept_name, building, budget) 存在数据冗余（building和budget被存储了多份，实际上每个系的楼和预算只要存一次就好了） 存在插入、删除和更新异常 需要分解成更小的模式 并不是所有模式的分解都是有益的 employee(ID, name, street, city, salary) 分解成下面两个模式 employee1(ID, name) employee2(name, street, city, salary) 由于可能存在同名的可能，所以分解以后导致了数据的丢失 比如有两个叫Sunny的人，我们用其中一个Sunny的ID去查询他的地址信息的时候，因为存在两份信息相互混淆，导致得不到正确的结果，但是在分解之前通过ID是可以得到唯一的地址的 有损分解和无损分解 像上面的例子中，分解以后导致信息丢失的分解称之为有损分解（在实际进行分解时要避免这种分解） 反之则称之为无损分解（无损分解在重新合并后可以得到和分解之前一致的状态） 函数依赖 什么是函数依赖？ 有如下模式 U = {Sno, Sname, Cno, Sdept, Mname, Grade} (分别代表学号、学生姓名、课程号、系、系主任、分数) Sname = f(Sno) ==&gt;学生的姓名函数依赖于学号 记作：Sno→Sname 读作：Sno推出Sname 非平凡函数依赖和平凡函数依赖 X 和 Y 为模式U中一个或多个属性的集合 非平凡函数依赖 X→Y，但Y∉X 平凡函数依赖（包含冗余） X→Y，且Y∈X 完全函数依赖和部分函数依赖 写函数依赖时，完全函数依赖和部分函数依赖的写法中，P和F是写在箭头的正上方的，由于Markdown不能很好的展现，就标在了箭头的右上角所以用下面的表示法： &rarr;F ：完全依赖 &rarr;P ：部分依赖 完全函数依赖 在模式R(U)中X→Y，但是对于任意X的真子集X’， 都没有X‘→Y, 则称Y完全函数依赖于X，记作X&rarr;FY X实际上就是能推出Y的最小集 例如：(Sno, Cno)→Grade 部分函数依赖 在模式R(U)中X→Y，存在某个X的真子集X’， 有X‘→Y, 则称Y部分函数依赖于X，记作X&rarr;PY 例如：(Sno, Cno)→Sdept 而实际上：Sno→Sdept 也是可行的，上面的依赖关系中，Cno是冗余的 传递函数依赖 X→Y, Y→Z ==&gt; X→Z 码 超码、候选码和主码 可以沿用SQL中码的概念 超码是可以唯一标识一个元组的属性集（可以有多个） 候选码是每个超码中去除不必要属性但是仍然能够标识一个元素的最精简属性集（可以有多个） 主码只有一个，在候选码中选一个当做主码 用函数依赖来定义 K为R&lt; U, F &gt;中的属性或属性组合，若K→U(→上面有一个F)(即U完全依赖于K)，则称K为R的候选码，若候选码多与一个，则选择其中一个作为主码 主属性与非主属性 主属性：包含于某个候选码的属性 非主属性：不被任何候选码包含的属性 范式 首先还是构造一个例子 R&lt; U, F&gt; U = {Sno, Sdept, Sloc, Cno, Grade} (分别代表学号、系、系所在楼、课程号、分数) F = {(Sno, Cno)&rarr;F Grade, Sno&rarr;Sdept, (Sno, Cno)&rarr;P Sdept, Sno&rarr;Sloc, (Sno, Cno)&rarr;PSloc} 主属性：Sno, Cno 非主属性：Sdept, Sloc, Grade 上面的依赖关系可以用下面的图示表示 第一范式（1NF） 一个域是原子的(atomic)，则该域的元素被认为是不可分的单元 比如name属性就可以不是原子的，name(first_name, middle_name, last_name) 一个关系模式R属于第一范式（1NF）==&gt;R上的所有属性都是原子的 上述例子中的每个属性都是原子的，所以满足第一范式 第二范式（2NF） R ∈ 1NF，并且每一个非主属性完全依赖于码（实际上就是在1NF的基础上，去除了非主属性对码的部分函数依赖） 上述例子中存在非主属性对码的部分函数依赖，故不满足2NF 对上述例子作出如下分解 R1&lt; {Sno, Cno, Grade}, {(Sno, Cno)&rarr;FGrade} &gt; R2&lt; {Sno, Sdept, Sloc}, {Sno&rarr;Sdept, Sdept&rarr;Sloc}&gt; ps:其中R2隐含了Sno&rarr;Sloc (由之后即将学习的AmStrong公理可以推算出来) 上面的依赖关系可以用下面的图示表示 经过上面的分解之后，每一个非主属性都完全依赖于码了，所以分解之后的模式满足2NF 第三范式（3NF） R∈2NF, 并且不存在非主属性对码的传递依赖（实际上就是在2NF的基础上去除了非主属性对码的传递依赖） 上述经过分解以后的模式中存在非主属性对码的传递依赖，故不满足3NF Sno&rarr;Sdept, Sdept&rarr;Sloc ==&gt; Sno&rarr;Sloc 对上面的模式进行进一步的分解 R1&lt; {Sno, Cno, Grade}, {(Sno, Cno)&rarr;FGrade} &gt; R2&lt; {Sno, Sdept}, {Sno&rarr;Sdept} &gt; R3&lt; {Sdept, Sloc}, {Sdept&rarr;Sloc} &gt; 上面的依赖关系可以用下面的图示表示 经过上面的进一步分解之后，就不存在非主属性对码的传递依赖了，故进一步分解之后的模式满足3NF 2NF和3NF中的约束都是针对于非主属性的。在日常开发的时候只要ER图设计好，一般都是满足到3NF的，3NF也是可以保证无损分解的最高范式 Boyce-Codd范式（BCNF） R ∈ 3NF， 并且不存在主属性间的部分函数依赖和传递函数依赖 （实际上就是在3NF的基础上，去除了主属性的部分函数依赖和传递函数依赖） 举个栗子 R&lt; U, F &gt; U = {S, T, J} F = { (S, J)&rarr;T, (S, T)&rarr;J, T&rarr;J } 从上面的函数依赖易判断出：S、T、J都是主属性 因为{S, J}， {S, T} 都是候选码 因为不存在非主属性，所以该模式已经满足到3NF 上面模式的依赖可以用下面的图示表示 上面的栗子中的模式主属性中存在部分函数依赖，所以不满足BCNF 作出如下分解 R1&lt; {S, T, J}, { (S, J)&rarr;T, (S, T)&rarr;J } &gt; R2&lt; {T, J}, { T&rarr;J } &gt; 上面的依赖关系可以用下图表示 经过分解之后的模式就不存在主属性间的部分函数依赖和传递函数依赖， 故满足BCNF 当我们分解不属于BCNF的模式的时候，产生的模式中可能有一个或多个不属于BCNF。在这种情况中，需要进一步分解，其最终结果是一个BCNF的模式集合 更高的范式还有第四范式和第五范式，但是应用较少，且考纲不要求，这里就不再赘述了]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017级Android第一次例会]]></title>
    <url>%2F2017%2F10%2F24%2F2017-10-24-2017%E7%BA%A7Android%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BE%8B%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[Android 前世今生 版本名称 版本号 发布时间 API版本 官方支持状态 Android (Alpha) 1.0 September 23, 2008 1 不支持 Beta (Internally known as “Petit Four”) 1.1 February 9, 2009 2 不支持 Cupcake（纸杯蛋糕） 1.5 April 27, 2009 3 不支持 Donut（甜甜圈） 1.6 September 15, 2009 4 不支持 Eclair（闪电泡芙） 2.0 – 2.1 October 26, 2009 5 – 7 不支持 Froyo（冻酸奶） 2.2 – 2.2.3 May 20, 2010 8 不支持 Gingerbread（姜饼） 2.3 – 2.3.7 December 6, 2010 9 – 10 不支持 Honeycomb（蜂巢） 3.0 – 3.2.6 February 22, 2011 11 – 13 不支持 Ice Cream Sandwich（冰淇淋三明治） 4.0 – 4.0.4 October 18, 2011 14 – 15 不支持 Jelly Bean（果冻豆） 4.1 – 4.3.1 July 9, 2012 16 – 18 不支持 KitKat（奇巧巧克力棒） 4.4 – 4.4.4 October 31, 2013 19 支持 Lollipop（棒棒糖） 5.0 – 5.1.1 November 12, 2014 21 – 22 支持 Marshmallow（棉花糖） 6.0 – 6.0.1 October 5, 2015 23 支持 Nougat（牛轧糖） 7.0 – 7.1.2 August 22, 2016 24 – 25 支持 O/Oreo（奥利奥） 8.0 August 22, 2017 26 支持 开发语言组里主要以Java语言为主，同时会介绍一些Kotlin开发Android。90% Java + 10% Kotlin Java Kotlin C++ …开发环境 Eclipse（拒绝） Visual Studio Android Studio(推荐) 2.3（稳定版）==&gt;不支持Kotlin 3.0（pre）==&gt;支持Kotlin，对Java8有较好的支持Java 环境配置：Kotlin 可以基于JVM，不需要额外配置，IDEA中可直接创建Kotlin项目 点此传送进行Java环境配置（http://www.jianshu.com/p/21abe20aadf2） 最好是下专业版IDEA（专业版需要注册码，可以用学校邮箱注册学生账号，可免费一年，过期需要手动再次激活） Java书籍推荐 入门：《Java核心技术 卷Ⅰ》、《疯狂Java讲义》 进阶：《Java编程思想》、《Java核心技术 卷Ⅱ》 强烈安利：《Effective Java》（这本书建议对Java有一定的熟悉程度，并有一定开发经验之后再看，会受益匪浅） 电子书资源： 点我下载（http://pan.baidu.com/s/1boXCxbT）Android环境配置 Google Developer （https://developers.google.cn/） Google Android Developer IDE 下载： 建议下载最新的Android Studio3.0预览版（稳定版和预览版可以共存，所以你也可以2.3和3.0都装） 官网下载 Android中文社区，可下载2.3.3和3.0预览版稳定版AS（http://www.android-studio.org/） 环境配置 CSDN教程 极客学院视频教程 极客学院视频 极客学院离线视频资源]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（十）——关系代数]]></title>
    <url>%2F2017%2F10%2F17%2F2017-10-17-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[基本运算每一种基本运算的结果都是一个新的关系，可以用这个关系继续参与运算，借此便可进行复杂的运算 选择运算（select）==&gt;相当于SQL语句中的WHERE子句的职能 格式：σ选择谓词(关系) 举个栗子： σSAL&gt;1000(EMP) 上式表示取出查询工资大于1000的所有员工的信息 等价于下面的SQL语句123SELECT *FROM EMPWHERE SAL &gt; 1000 选择谓词的分类 比较：=、≠、&lt;、≤、&gt;和≥ 连词：and(∧)、or(∨)和not(¬)==&gt;可以将多个谓词合并成一个大的谓词 可以包括两个属性（字段的比较）：σCOMM&gt;SAL(EMP)表示抽成大于工资的人 投影运算（project）==&gt;相当于SQL语句中的SELECT子句的职能 格式：∏字段序列(关系) 举个栗子 ∏ENAME,SAL(EMP) 上式表示查看所有员工的姓名和工资 等价于下面的SQL语句12SELECT ENAME, SALFROM EMP 关系的组合运算==&gt;就像SQL中select、where子句那样的组合效果 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) 上面的式子求出了所有工资大于1000的员工的名字和工资(实际上就是将σSAL&gt;1000(EMP)执行的结果当做一个临时的关系，参与了投影运算得到的) 等价于下面的SQL语句123SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000 事实关系的组合运算就是那么简单，分析的时候把每个简单运算的结果当做一个新的关系参与后面的运算，这样一层层剥开来，再复杂的语句也变得容易分析 并运算（union）==&gt;相当于SQL中UNION关键字的职能 格式：（关系r）∪（关系s） 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) ∪ ∏ENAME,SAL(σCOMM&gt;300(EMP)) 上面的式子求出了所有工资大于1000或抽成大于300的员工的姓名和工资，等价于下面的SQL语句 1234567SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000UNIONSELECT ENAME, SALFROM EMPWHERE COMM &gt; 300 几点需要额外注意的： 此处的并运算是集合运算，所以结果是去重的，结果集中不存在重复的元组（而在SQL语句中，指定UNION ALL是可以保留重复的） 关系r与关系s必须是同元的，即它们的属性的数目要求必须相同（这就和SQL语句中UNION使用的时候要求上下两个语句的字段数相同是一样的意思） 关系r和关系s对应位置的属性域应该是类型兼容的（同样和SQL中UNION使用时，每个对应位置字段类型兼容是一样的意思） 集合的差运算（set-defference）==&gt;相当于SQL语句中的EXCEPT 格式：(关系r)-(关系s) 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) - ∏ENAME,SAL(σCOMM&gt;300(EMP)) 上面的式子表示工资大于1000但抽成不大于300的员工的姓名和工资，等价于下面的SQL语句1234567SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000EXCEPTSELECT ENAME, SALFROM EMPWHERE COMM &gt; 300 几点需要额外注意的： 此处的注意同上面的并运算的注意事项 笛卡尔积运算（Cartesian-product）==&gt;等价于SQL语句中两个表进行笛卡尔积（全匹配）得到的结果，即SQL中进行多表连接时不指定连接条件的情况 格式：(关系r)×(关系) 举个栗子： EMP × DEPT 上面的式子表示两个表进行全匹配，等价于下面的SQL语句12SELECT *FROM EMP, DEPT 下面两个式子是等价的 ∏ENAME,DNAME(σEMP.DEPTNO=DEPT.DEPTNO(σJOB=”MANAGER”(EMP×DEPT))) ∏ENAME,DNAME(σEMP.DEPTNO=DEPT.DEPTNO((σJOB=”MANAGER”(EMP))×DEPT) 下面是对这两个式子的SQL转化，转化之后就一目了然了1234567891011-- 对应第一个式子SELECT ENAME, DNAMEFROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNOWHERE JOB = 'MANAGER'-- 对应第二个式子SELECT ENAME, DNAMEFROM DEPT JOIN (SELECT * FROM EMP WHERE JOB = 'MANAGER') ON EMP.DEPTNO = DEPT.DEPTNO 更名运算（rename）==&gt;等价于SQL语句中as的职能 格式：ρX(A1,A2,…,An)(E)==&gt;表示的是将关系E更名为X，Ai表示的是给E的第i个字段指定别名 举个栗子 ∏ENAME,DNAME(σe.DEPTNO=d.DEPTNO(σJOB=”MANAGER”(ρe(EMP)×ρd(DEPT)))) 上面式子含义就不解释了，是上面举的栗子，只是引入了更名运算符，它等价于下面的SQL语句123SELECT ENAME, DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNOWHERE JOB = 'MANAGER' 来，学习完上面的基本运算，来做个实际的栗子，要求找到员工表中的最高工资（因为目前还没有介绍类似SQL中组函数的操作，后面会介绍。所以通过以下方式来实现） step1: 找到所有不是最高工资的人 ∏e1.SAL(σe1.sal &lt; e2.sal(ρe1(EMP)×ρe2(EMP))) step2: 用所有的员工减去上面的员工，即得到最高工资 ∏SAL(EMP) - ∏e1.SAL(σe1.sal &lt; e2.sal(ρe1(EMP)×ρe2(EMP))) 在书写关系运算表达式的时候可以用序列号代替字段名（但是不直观，不常用，一般不用） 举个栗子 ∏$6(σ$6 &lt; $14(EMP×EMP)) 等价于下面的运算 ∏e1.SAL(σe1.sal &lt; e2.sal(ρe1(EMP)×ρe2(EMP))) 附加运算附加运算是由基本运算组成的，不能增强基本运算的运算能力，但是能简化运算 集合交运算（intersection）==&gt;相当于SQL语句中INTERSECT关键字的职能 格式：(关系r)∩(关系s) 因为集合交运算是可以由前面的基本运算组合产生的，所以把它归到附加运算 A ∩ B &lt;=&gt; A - (A - B) 举个栗子 ∏ENAME,SAL(σSAL&gt;1000(EMP)) ∩ ∏ENAME,SAL(σCOMM&gt;300(EMP)) 上面的式子表示工资大于1000并且抽成大于300的员工的姓名和工资，等价于下面的SQL语句1234567SELECT ENAME, SALFROM EMPWHERE SAL &gt; 1000INTERSECTSELECT ENAME, SALFROM EMPWHERE COMM &gt; 300 自然连接（natural join）==&gt; 相当于SQL语句中的NATURAL JOIN 格式：(关系)⋈(关系) 自然连接的形式化定义 r,s是两个关系 R，S是上面两个关系对应的关系模式（其实就是上述两个关系各自的属性列表） R ∩ S 表示r和s的同名属性列表 R ∪ S 表示出现在r或s上的属性名列表(是一个集合，不包同名属性，存在同名属性会去重) R - S 表示出现在R上，但不出现在S上的属性名列表 则可做如下定义 r⋈s = ∏R∪S(σr.A1=s.A1 ∧ r.A2=s.A2 ∧ … ∧ r.An=s.An(r×s)) ，其中 R∩S={A1, A2, …, An} 举个栗子 ∏name, course_id(instructor ⋈ teaches) 上面的式子列出了所有老师的名字以及其所授课程的id，等价于下面的SQL语句12SELECT name, course_idFROM intructor natural join teaches ps: 两个关系模式执行自然连接以后属性的排布顺序： 排在最前面的是两个关系模式相同的属性 其次是只属于第一个关系模式的属性 最后是只属于第二个关系模式的属性！！！所以所两个关系模式进行自然连接以后，总的属性的个数是减少了，具体减少的个数等于同名属性的个数 theta连接==&gt;是自然连接的扩展，相当于SQL中的join on 格式：(关系)⋈Θ(关系) 形式化定义： r ⋈Θ s = σΘ(r × s) 举个栗子 ∏name, course_id(instructor ⋈intructor.SAL &gt; 5000 teaches) 上面的式子表示列出所有工资高于5000的老师的名字以及其所授课程的id， 等价于下面的SQL语句12SELECT name, course_idFROM instructor join teaches on instructor.ID = teaches.ID 除运算（division） 这个在书上没讲，是老师上课的时候补充的 格式：(关系)÷(关系) 形式化定义：R÷S = ∏R∪S( ( ∏R-S(r) × S ) - ∏R-S, S(r) ) 解释起来挺麻烦的，这边给出一个博客链接：点我 赋值运算 就是将一个关系表达式的结果赋值取一个临时的名字，就相当于定义了一个临时关系。这个操作就相当于SQL中with语句的职能 格式： temp_name ← 关系表达式 举个栗子：temp1 ← R × Stemp2 ← σr.A1=s.A1 ∧ r.A2=s.A2 ∧ … ∧ r.An=s.An(temp1)result = ∏R∪S(temp2) 上面的式子等价于： result = r⋈s 外连接运算 左外连：⟕ 右外连：⟖ 全外连：⟗ 扩展运算扩展运算是不能用基本的关系代数运算来实现的一类查询，可以满足复杂的查询需求 广义投影（Generalized-projection） 与基本运算中的投影运算相比，就是多了允许在选择列表中出现表达式（在基本运算中的投影的选择列表中只能出现字段） 格式：∏F1, F2, … , Fn(E) 其中F1, F2, … , Fn可以是字段或者是表达式 E代表一个关系 举个栗子： ∏name, sal * 1.2(instructor) 上面的式子表示查出所有老师的名字，以及涨了20%以后的工资，等价于下面的SQL语句 12SELECT name, sal * 1.2FROM instructor 聚集函数（Aggregation function） 聚集函数的符号表示是用书写体G，这边就直接用G指代了 聚集函数是输入值的一个汇聚，以多个值作为输入，将一个单一的值作为返回结果 多重集：使用聚集函数对其进行操作的汇集中，一个值可以出现多次，值出现的顺序是无关紧要的。这样的汇集称为多重集（就比方说统计一个员工表中员工的数量，然后我们通过统计员工的名字来统计，即便是同名的员工我们也是计算的） 格式： G1, G2, … , GnGF1(A1), F2(A2), …, Fn(An)(E) 其中前面的G1, G2, … , Gn表示的是分组条件 后面的F1(A1), F2(A2), …, Fn(An)是聚集函数表达式列表 Fi(i = 1, 2, …, n)表示聚集函数：sum、count、average、max、min A1, A2, … , An代表字段 举个栗子： A1, A2Gsum(A3)(∏A1, A2, …, An(σP(r1×r2×…×rm)) ) 等价于下面的SQL语句1234SELECT A1, A2, sum(A3)FROM r1, r2, ..., rmWHERE PGROUP BY A1, A2 上面的聚集函数在进行计算的时候采用的都是多重集，也就是相同的值可以多次重复计算（也就是在执行聚集函数的时候是不去重计算），如果要去重计算的话就要采用下面的几个函数写法 sum_distinct count_distinct averag_distinct max_distinct min_distinct 举个栗子： A1, A2Gsum_distinct(A3)(∏A1, A2, …, An(σP(r1×r2×…×rm)) ) 上面的式子等价于下面的SQL语句1234SELECT A1, A2, sum(distinct A3)FROM r1, r2, ..., rmWHERE PGROUP BY A1, A2]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（九）——对违反约束的处理]]></title>
    <url>%2F2017%2F10%2F15%2F2017-10-15-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E8%BF%9D%E5%8F%8D%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章的一些尾巴，然后开始讲第六章的关系代数笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们构造一些简单表 1234567891011121314151617181920212223242526272829303132333435-- 执行下面的语句构造表CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE CASCADE ON UPDATE CASCADE);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 级联操作在指定外键以后，由于存在完整性约束，所以在执行删除或更新的时候由于语句可能会破坏完整性约束而执行失败。因此可以在定义外键的时候声明为级联删除和级联更新(是一种对违反参照完整性约束时的处理方式) 使用方式1234567CREATE table 表名( ... FOREGIN KEY (字段序列) REFERENCES 表名(字段序列) ON DELETE CASCADE ON UPDATE CASCADE, ...) 级联删除（ON DELETE CASCADE） 级联删除是在定义外键时指定的，但是却会在执行删除语句时产生影响 举个栗子 我们先不指定级联 12345678910111213141516171819202122232425262728293031323334DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id));INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 然后执行下面的删除操作 123-- 下面我们试图删除中国的信息，但是在person表里有一条数据引用了中国，所以因为参照完整性约束的存在，所以这条语句会执行失败DELETE countryWHERE country_id = 1 接下来我们重新构造一遍（当然直接用DDL语句更新也是可以的）–并在构造person表时指定了级联删除 1234567891011121314151617181920212223242526272829303132333435DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE CASCADE);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 然后再次执行下面的删除操作 123-- 此时执行会发现语句成功执行了，不但删除了中国的信息，连带person表中引用了中国信息的所有数据都被删除了DELETE countryWHERE country_id = 1 上面的例子便很好的说明了级联删除的作用。如果我们视图删除外键参照键所在表（此处为country表）的某条数据A（此处是中国的信息），而这条数据又被外键所在表的一条或多条数据B所关联（此处person表中Sunny的country_id关联了country表中中国的id）。在指定了级联删除的情况下，删除A会连带着删除所有满足条件的B 当然在实际使用的时候用的还是比较少的，因为参照完整性约束在一定程度上可以防止数据的误删除，对数据库的完整性起了一定的保护作用，如果指定了级联删除，这层保护就失效了。所以还是视情况而用 级联更新（ON UPDATE CASCADE） 类似的，级联更新和级联删除一样，如果我们更新时违反了完整性约束，同样更新操作不被拒绝，而是级联更新 举个栗子（我们在上面操作的基础上执行，上面构造时指定了级联删除，但是没指定级联更新） 1234-- 我们试图执行下面的更新操作，我们把修改English的country_id， 但是由于person表中还有数据的country_id=2,如果下面的更新成功执行，则会导致person表中存在country_id=2的数据，而country中却没有对应数了，违反参照完整性约束，故下面的语句执行失败UPDATE countrySET country_id = 4WHERE country_id = 2 同样的，我们重新构造一下，此时指定级联更新 123456789101112131415161718192021222324252627282930313233343536DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE CASCADE ON UPDATE CASCADE);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 此时再执行一下上面的更新语句 1234-- 由于指定了级联更新，所以会发现下面的语句执行成功了，不但更改了country表中的数据，连带着person表中的数据也一并更新了UPDATE countrySET country_id = 4WHERE country_id = 2 上面就是级联更新的效果 另一类对违反完整性约束的处理 SET DEFAULT 一旦违反完整性约束，就将参照域（此处为country_id）设置为默认值 SET NULL 一旦违反完整性约束，就将参照域（此处为country_id）设置为NULL 举个栗子 执行下面的构造 1234567891011121314151617181920212223242526272829303132333435DROP TABLE person;DROP TABLE country;CREATE TABLE country( country_id INTEGER PRIMARY KEY , country_name VARCHAR(20));CREATE TABLE person( person_id INTEGER PRIMARY KEY , name VARCHAR(20), country_id INTEGER FOREIGN KEY REFERENCES country(country_id) ON DELETE SET NULL);INSERT INTO country (country_id, country_name) VALUES ( 1, 'China');INSERT INTO country (country_id, country_name) VALUES ( 2, 'English');INSERT INTO country (country_id, country_name) VALUES ( 3, 'America');INSERT INTO person (person_id, name, country_id) VALUES ( 1, 'Sunny', 1);INSERT INTO person (person_id, name, country_id) VALUES ( 2, 'Robbin', 2);INSERT INTO person (person_id, name, country_id) VALUES ( 3, 'Jane', 3); 然后执行下面的删除操作 123-- 下面的删除操作成功执行，但不是级联删除，而是把person表中原来country_id=1的数据的country_id都设成了NULLDELETE countryWHERE country_id = 1 延迟检查这是由于数据库默认是在执行每一条SQL语句的时候都进行完整性约束的检查，导致有些操作无法进行。延迟操作就将完整性约束的检查延迟到了事务结束的时候检查（大多数数据库不支持，比如SQL Server， 但Oracle数据支持） 由于不常用，SQL Server也不支持，这里就讲一下概念，不举实际的栗子了。 假设上面的例子表中没有指定延迟检查 执行下面的语句1234567-- 执行下面两条语句是会出错的，因为插入第一条数据的时候，由于完整性约束的存在，要求country表中要有country_id=4的数据，但是这个数据目前还不存在（所以只要先执行第二条语句，这两个语句才能成功执行）INSERT INTO person (person_id, name, country_id) VALUES ( 4, 'Jerry', 4);INSERT INTO country (country_id, country_name) VALUES ( 4, 'France'); 而如果指定了延迟检查呢 执行下面语句（下面两个语句处于同一个事务中）12345678-- 由于是延迟检查，所以两条数据都插入完，执行commit，事务结束时才进行完整性约束的检查，此时就不会出错，可以正常插入INSERT INTO person (person_id, name, country_id) VALUES ( 4, 'Jerry', 4);INSERT INTO country (country_id, country_name) VALUES ( 4, 'France');COMMIT 虽然SQL标准中有这个概念，但是大多数数据库没有提供支持，并且不常用]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（八）——视图 、事务]]></title>
    <url>%2F2017%2F10%2F10%2F2017-10-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E8%A7%86%E5%9B%BE%20%E3%80%81%E4%BA%8B%E5%8A%A1%20%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章(第三章的多表部分会挪到这一部分讲)笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们继续延用之前用的表(´`) 视图首先还是来谈谈笔者对视图概念的理解吧，在笔者看来视图这个数据库对象在不考虑物化的情况下就是一张虚表，本身没有实际的数据，但是可以利用视图在某个视角下观察一张或多张表的数据。所有对视图的操作最后都将转成对表的操作 视图定义（创建一个视图） 格式： 1CREATE VIEW 视图名 AS 子查询 举个栗子： 1234-- 下面的语句创建了一个简单的视图temp_view，其中包含员工名以及其所在部门名两个字段CREATE VIEW temp_view ASSELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO; 接下来我们对上面创建的视图进行查询操作 12SELECT *FROM temp_view; 得到如下结果： 数据库只存储视图的定义本身 视图通常是这样来实现的：当我们定义一个视图的时候，数据库系统就吧这个视图的定义（其实就是一个子查询语句）本身存储下来，一旦我们使用这个视图，数据库系统就会用定义中的查询语句替换视图 举个栗子123456789101112-- 我们继续沿用上面定义的视图temp_view，它的定义是这样的CREATE VIEW temp_view ASSELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO;-- 则对视图的查询操作可以作下面的等价(下面两个查询语句是等价的)SELECT *FROM temp_view;SELECT *FROM (SELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO) as temp_view; 可更新的视图 条件 FROM子句中只有一个数据库关系（即在定义视图的时候，后面的SELECT语句中只能查询一个表） SELECT子句中只包含关系的属性名，不包含任何的表达式，集聚函数或distinct声明 任何没有出现在SELECT子句中的属性可以取空值（即这些属性既没有not null 约束，也不构成主码的一部分） 查询中不含有group by 或 having 子句 满足上述条件的视图我们称作可更新的视图，在可更新视图上允许执行update、insert、delete操作 视图是在表的基础上定义的，所有对视图的操作最后都将作用在表上 视图的update、insert、delete 先定义一个视图，值包括员工的职工号、名字和工资 123CREATE VIEW emp_info ASSELECT EMPNO, ENAME, SALFROM EMP; 视图查询的结果如下： update 举个栗子123456789-- 下面的语句更新SMITH的工资UPDATE emp_infoSET SAL = 900WHERE ENAME = 'SMITH'--接下来查询表中的数据是否受到影响（查询的结果是900，就不贴图了）SELECT ENAME, SALFROM EMPWHERE ENAME = 'SMITH'; insert 举个栗子1234-- 往视图中插入一条数据（下面插入是可以执行成功的，可以自己试试，创建一个视图，只包含员工名字和工资，不包含EMPNO，这样就不能执行插入语句，违反了上面四个条件中的第三个条件）INSERT INTO emp_info (EMPNO, ENAME, SAL) VALUES ( 8888, 'Robbin', '1000'); –查询一下原表中的数据，会发现多了下面这条 视图的插入操作，最终作用到表上，并且是给视图中有的字段赋值，没有的字段都赋null值（这就解释了上面可更新视图的四个条件中的条件3） delete 举个栗子123-- 执行结构就是原表中的数据也被删除了DELETE emp_infoWHERE emp_info.EMPNO = 8888 物化视图 就是保存视图的结构，再使用时直接用保存的结果表，而不用再去将视图替换成定义，再次执行一遍查询视图的操作。这个在对视图的操作很频繁的时候是对效率很有增益的，但是同时带来的是同步的问题。就是原表中的数据更新了，但是视图物化的数据却没有更新，导致数据不一致。 一般用的很少，常用于数据仓库 事务 一个事务就是一个原子的，不可分割的任务，里面可能包含多条SQL语句。在事务机制下，一个事务中的多条SQL语句要么都执行，要么都不执行。 性质 原子性 事务是原子的，里面包含的一条或多条SQL语句要么都执行，要么都不执行 一致性 在隔离的执行多个事务时，用同步锁保证对数据库数据的一致性访问 隔离性 多个事务并行执行，若其中一个事务还没有结束，其他事务内是无法观察到这个事务对数据库的影响的 持久性 一旦事务正常完成，并提交，则其对数据库的修改就会持久化到数据库内。 事务的开始和终止 虽然各种关系型数据库都支持事务，但是不同的数据库的实现不同。具体的事务的开始和终止有隐式和显示之分 事务的开始 显示：begin transition （例如SQL Server数据库） 隐式：第一条DML语句（增删改查语句）开始执行就会开启一个事务 （例如Oracle数据库） 事物的终止 显示： end transition (例如SQL Server数据库) 隐式：执行 rollback、commit或者一条DDL语句 （例如Oracle数据库） 数据库加锁的范围不同 表级锁 页级锁 行级锁 举个栗子(由于使用SQL Server做的测试，所以采用显示的事务开启和关闭)12345678910111213141516-- 首先查看博客开头ALLEN的工资是1600-- 下面开启一个事务，并执行一条涨工资的操作（执行会立即完成）BEGIN TRANSACTIONUPDATE EMP SET SAL = SAL * 2WHERE ENAME = 'ALLEN';-- 与此同时，开启另一个事务，执行一条涨工资的操作（语句没有执行，一直在等待。这是因为上面那个事务对ALLEN的数据进行操作了，并且事务没有结束，由于同步锁的缘故，所以本事务中的修改语句要等上面那个事务执行完才能继续执行）BEGIN TRANSACTIONUPDATE EMP SET SAL = SAL * 3WHERE ENAME = 'ALLEN';-- 如果此时结束第一个事务，那么第二个事务的语句就能继续执行，此时提交第二个事务，最后得到的结果是，ALLEN的工资为9600COMMIT 完整性约束 主键约束 外键约束（参照完整性约束） 单关系上的约束 not null unique check(&lt;谓词&gt;)]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（七）]]></title>
    <url>%2F2017%2F09%2F29%2F2017-09-29-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章(第三章的多表部分会挪到这一部分讲)笔者接下来的代码示例会主要在SQL Server数据库中测试(由于SQL Server 数据库不支持自然连接，所以自然连接部分的将会在MySQL数据库中进行测试) 在开始今天的摸鱼大业之前，让我们继续延用之前用的表 外键约束：即具有外键约束的两张表，在进行操作时会收到一定程度的限制，如果某个操作执行后会破坏这个完整性，就将被拒绝执行。这个在之前的博客中有介绍==&gt; 传送门 自连接一个表与自身相连接的操作，其实与多表连接是一样的，只是连接的两张表用的是同一张表而已 举个栗子1234-- 下面的语句查询了所有员工的名字以及其经理的名字SELECT w.ENAME as worker_name, m.ENAME as manager_nameFROM EMP w JOIN EMP m ON w.MGR = m.EMPNO; 得到如下结果： 上面得到的结果是采用内连接得到的结果，所以对于那些MGR为null（没有经理）的员工，其信息就得不到显示，可以采用左外连接（LEFT OUTER JOIN） 员工表中MGR 和 EMPNO 字段应该有一层限制，MGR的取值应该是某一个EMPNO的取值（话句话说，一个员工的经理号应该也是同一张表中这个经理的职工号）。在定义这张表的时候可以给这两个字段加上一个外键约束。 12345678--下面的语句模拟了这一操作--只关注了EMPNO和MGR这两个字段，其他字段的描述省略了CREATE TABLE EMP( EMPNO INTEGER PRIMARY KEY , MGR INTEGER, .... FOREIGN KEY(MGR) REFERENCES EMP(EMPNO)) 还是那句话：绝大多数连接条件是建立在外键与外键的参照键之间的(自连接也不例外) 自然连接（NATURAL JOIN）其实自然连接就是写法更简单的多表连接，无需书写连接条件，让数据库自己判断应该采用什么连接条件（自然连接的语法是SQL的标准语法，但是并不是所有的数据库都支持，SQL Server就不支持自然连接的语法，但是Oracle和MySQL数据库都是支持的。。所以下面的测试就在MySQL里面测试啦，上次用IDEA连的那个数据库里面我已经建好了和在上面测试用例一样的表和数据，可以直接用） 可采用自然连接的前提条件：两个表中要有同名字段，并且同名字段的数据类型要一致 举个栗子 1234567891011-- 下面的语句就实现了查询所有的员工名字及其所在部门名-- 相当于内连接-- 因为两个表中有同名字段DEPTNO，并且数据类型相同，数据库就用这个作为连接条件SELECT e.ENAME, d.DNAMEFROM EMP e NATURAL JOIN DEPT d;-- 上面的语句等价于下面的内连接语句SELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d ON e.DEPTNO = d.DEPTNO; 得到如下结果： 如果两个表中有同名字段，但是数据类型不一致，执行自然连接是会失败的，因为此时数据库不知道应该怎么连接两张表 当然如果想要执行外连接（左外，右外，全外）也是一样的 举个栗子 12345678910111213-- 下面几个语句是等价的，会得到相同的结果，都采用了左外连接SELECT e.ENAME, d.DNAMEFROM EMP e NATURAL LEFT OUTER JOIN DEPT d;SELECT e.ENAME, d.DNAMEFROM EMP e NATURAL LEFT JOIN DEPT d;SELECT e.ENAME, d.DNAMEFROM EMP e LEFT OUTER JOIN DEPT d ON e.DEPTNO = d.DEPTNO; 得到如下结果： 在使用自然连接时，同名字段（用于连接的字段）不能写限定名（虽然老师上课这么讲，但实际上呢？） 举个栗子 123456789101112-- 我们在上面例子的基础上，多显示一个部门号，下面的两条语句如果能执行，执行完的结果都是一样的-- 下面的语句在Oracle数据库执行会报错-- 但是在MySQL中执行是能过的SELECT e.ENAME, d.DNAME, e.DEPTNOFROM EMP e NATURAL JOIN DEPT d;-- 下面这种写法在Oracle和MySQL中都是能过的SELECT e.ENAME, d.DNAME, DEPTNOFROM EMP e NATURAL JOIN DEPT d; 让我们先分析一下，为什么在使用自然连接的时候同名字段可以不写限定名 先看看执行下面的语句有什么结果： 123SELECT *FROM EMP e NATURAL JOIN DEPT d; 得到下面结果： 可以看出来，采用自然连接以后，原本的同名字段DEPTNO只出现了一次,可以理解为采用自然连接以后FROM子句的结果就是上面那张表，同时原来的同名字段合成了一个。所以在SELECT子句中书写的时候可以不加表限定名（在Oracle数据库中不能加表限定名） 让我们对上面的结果小结一下 在采用自然连接的时候，对于同名字段，可以不写表限定名 至于能不能写，得看具体是什么数据库，Oracle此种情况下就不允许在同名字段前写表限定名，而MySQL中则可以 所以推荐是在采用自然连接的时候，非同名字段都加上限定名，同名字段都不加 下面是在多表操作中的一点建议 在多表连接中，所有的字段前面都建议加上限定名 特殊的是，在使用自然连接的时候，同名字段不要写限定名 有一个问题就是，由于数据库只分析到数据字典层面，而无法分到数据层，所以就算两个表中的一组同名字段之间没有任何关系，但是数据类型一致，采用自然连接的话，这一组同名字段也会被作为连接条件。 举个栗子 12345678--下面这个栗子没有实际执行，想象一下就好-- 假设我们给部门表的部门名字段更名：DNAME--&gt;ENAME-- 然后我们仍然执行上面的例子-- 结果应该是没有数据，除非有一个员工，他的名字和他所在部门的名字是一样的。SELECT e.ENAME, d.ENMAEFROM EMP e NATURAL JOIN DEPT d 导致上面结果的原因是采用了自然连接以后，数据库会把所有同名并且类型相同的字段作为连接条件 有时候我们并不希望所有的同名字段都作为条件，这个时候我们就不能用上面的自然连接操作，就应该使用介绍的有关JOIN … USING的用法 利用JOIN … USING 可以灵活的指定用什么字段做连接条件 JOIN…USING 同样是一种自然连接，且是一种特殊的自然连接，不需要显示写明连接条件，只需要指定用什么字段连接即可 举个栗子 12345678910-- 用下面的语句同样可以实现查询所有员工名字以及其所在部门名字的需求SELECT e.ENAME, d.DNAMEFROM EMP e JOIN DEPT d USING (DEPTNO);-- 同样的，如果我们给部门表的部门名字段更名：DNAME--&gt;ENAME-- 为了避免上面提到的问题，我们可以只指定DEPTNO作为连接条件，就轻松解决上面的问题SELECT e.ENAME, d.ENAMEFROM EMP e JOIN DEPT d USING (DEPTNO); 得到如下结果： 其中JOIN 表名 USING (字段序列)，字段序列可以是一个或多个字段 如果两个表中存在同名字段，但是数据类型不一样，这样执行自然连接是会失败的 连接类型和连接条件(就是老师上课提到的课本上那个图) 连接类型 INNER JOIN LEFT OUTER JOIN RIGHT OUTER JOIN FULL OUTER JOIN 连接条件 NATURAL ON&lt; predicate> USING(A1, A2, …, An) 其中上面的连接类型和连接条件可以任意组合使用 但不是所有数据库都支持NATURAL 和 USING的用法，SQL Server不支持，Oracle和MySQL支持，即便支持，有一些细节还是不一样的（比如上面同名字段前面能不能加限定词的问题） ON的话是都支持的，建议用ON，有更好的可读性和灵活性 FROM子句中的子查询 如果子查询出现在FROM子句中，我们将子查询的结果当做一个临时的关系（表），奕称之为虚表 举个栗子 123456-- 下面的例子求出了工资比本部门平均工资高的员工的名字和其工资，以及其所在部门的平均工资SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) as avg_sal FROM EMP GROUP BY DEPTNO) as EWHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 得到如下结果： 分析上面的执行过程的时候，可以先分析一下子查询执行的结果是什么，然后再把它当做一张表放在上面，继续分析整个语句 可以给子查询得到的临时表取一个名字，并给里面的每个字段指定名字 最常见的是下面这种命名方法 12345SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO) as E(DEPTNO, avg_sal)WHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 直接在子查询后面用as关系指定表名以及子查询结果中每个字段的别名 但是也不是所有数据库都支持上面那种用法，Oracle数据库中就不支持用as关键字指定子查询的表名，也不支持在表名后面加上每个字段的名字，那这个时候怎么办呢？（可以在子查询里面给每个字段取别名，最后再给子查询得到的虚表用空格分隔取个表名就好了） 12345SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) as avg_sal FROM EMP GROUP BY DEPTNO) EWHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 下面提几点注意（对于FROM子句中的子查询）： 如果子查询中含有聚集函数（组函数）,一定要给它起个别名 对每个子查询得到的虚表都务必取个表名（虽然有些数据库可以不起表名，但是有些数据库不起表名是会出错的，所以建议还是都起一个表名） With 子句其实with子句的作用和在FROM子句中使用子查询时一样的，同样是得到了一张虚表，只是把FROM中冗长的子查询移到外面，可读性 更好一点 with子句的作用是定义一张临时表 WITH子句相当于把FROM中的子查询提出来，如果FROM子句中的子查询比较复杂的时候，这样做是很有好处的，可读性会好很多 WITH 的基本使用方法1WITH &lt; 临时表名 &gt; （字段别名序列）AS (子查询) 举个栗子12345678910111213141516-- 下面的例子和上面找大于本部门平均工资的例子是等效的-- 执行的结果也是相同的WITH avg_tab(DEPTNO, avg_sal)AS (SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO)SELECT e.ENAME, e.SAL, avg_tab.avg_salFROM EMP e, avg_tabWHERE e.DEPTNO = avg_tab.DEPTNO AND e.SAL &gt; avg_tab.avg_sal;-- 下面的语句和上面的等效SELECT e.ENAME, e.SAL, E.avg_salFROM EMP e, (SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO) as E(DEPTNO, avg_sal)WHERE e.DEPTNO = E.DEPTNO and e.SAL &gt; avg_sal; 标量子查询 把子查询的结果当做一个值，可以出现在任何可以放值的地方，比如SELECT,WHERE,HAVING 子查询的结果必须是单个元组的单个属性（即一行一列，只有单个值） 带子查询的DELETE语句 举个栗子： 12345678-- 下面的语句可以用来删除所有销售部的员工的信息DELETEFROM EMPWHERE DEPTNO = ( SELECT DEPT.DEPTNO FROM DEPT WHERE DNAME = 'SALES') 带子查询的INSERT语句 基本格式 12INSERT INTO &lt; 表名 &gt;（字段序列）子查询 举个栗子 1234567891011-- 由于SQL Server中是没有dual这张系统表的，而Oracle和MySQL数据库中是有的，所以下面的测试是在MySQL中测试的-- 下面的语句很巧妙的实现了：--如果部门表中没有部门号为666的部门的话，就将摸鱼部门的信息插入到部门表中--如果部门表中有部门号为666的部门，则不执行插入操作INSERT INTO DEPT (DEPTNO, DNAME, LOC)SELECT '666', 'MOYU', 'DUT'FROM dualWHERE NOT EXISTS(SELECT * FROM EMP WHERE DEPTNO = '666'); UPDATE语句的扩展 有下面几个扩展 可以嵌入子查询（这个不在举例，和上面的用法类似） case分支结构 case分支结构(可以有效的避免更新次序引发的问题) 第一种用法 1234567CASE WHEN &lt;条件&gt; THEN ... WHEN &lt;条件&gt; THEN ... ... ELSE ...END 第二种用法 12345CASE &lt;条件&gt;WHEN &lt;值&gt; THEN ...WHEN &lt;值&gt; THEN ......END 对比两种方法，可以将第一种方法类比成其他编程语言的if-else分支语句，而将第二种用法类比成switch语句 举个栗子123456789101112131415161718192021222324-- 我们的需求是给员工涨工资，工资大于等于3000的涨2%-- 工资大于等于两千的涨3%-- 工资小于2000的涨5%--第一种尝试UPDATE EMPSET SAL = SAL * 1.02WHERE SAL &gt;= 3000;UPDATE EMPSET SAL = SAL * 1.03WHERE SAL &gt;= 2000;UPDATE EMPSET SAL = SAL * 1.05WHERE SAL &lt; 2000;--会发现上面执行的次序不一样会导致结果不一样，如果把第三个更新语句先执行，那么可能某个工资低于2000的员工涨了一次工资后工资大于两千了，于是执行第二个更新语句的时候又给他涨了一遍工资-- 第二种尝试--下面就完美的实现了上面的需求，而且没有执行次序导致的问题UPDATE EMPSET SAL = CASE WHEN SAL &gt;= 3000 THEN SAL * 1.02 WHEN SAL &gt;= 2000 THEN SAL * 1.03 ELSE SAL * 1.05 END case分支结构不止可以用在update子句中，在select子句中也是有的 视图啊啊啊啊啊，这个内容还不是三言两语讲的玩的，下次吧下次吧。&gt;.&lt;]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（六）]]></title>
    <url>%2F2017%2F09%2F26%2F2017-09-26-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第四章(第三章的多表部分会挪到这一部分讲)笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们继续延用之前用的表(为了演示方便，我们在EMP表中多插入了一条数据，这个数据的部门号是空值)，用于演示下面的例子(´`) FROM 中的子查询由于FROM中的子查询涉及到多表的操作，所以准备放在后面讲，先在此处做个小提示，等学完多表操作后，会回来提这个，到时候我会在这边贴一个链接 多表查询中的笛卡尔积（全匹配问题） 如果在进行多表查询操作时没有连接条件 ，则会进行全匹配，结果集相当于两个表进行笛卡尔积 举个栗子1234-- 下面的操作本来是想输出所有的员工的姓名以及其所在的部门名-- 但是由于没有指定连接条件，所以结果将会是每一个员工与每一个部门组合的结果SELECT ENAME, DNAMEFROM EMP, DEPT; 结果如下(结果太多了，总共有52条，下面的图片中只截取了前面的一部分)： 在实际开发过程中笛卡尔积得到的结果一般是没有太大意义的，所以应当尽量避免==&gt;添加连接条件(WHERE emp.deptno = dept.deptno) 举个栗子：1234-- 这个栗子就基本完成了上面的需求SELECT ENAME, DNAMEFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 但是仔细观察会发现，上面的数据只有13条，而员工表里面的数据有14条，其中Sunny所在部门号为空值，在部门表中匹配不到结果，故没有出现在结果集当中。（这是因为采用内连接的缘故，下面将会对内外连接分别做分析） 在WHERE子句中书写连接条件的内连接这种在where子句中写连接条件的实现方式，不是SQL标准中的标准用法，但是大多数数据库都支持这种用法，所以这种用法已经成了一种事实标准。在内连接的范畴中，这种用法与SQL标准的内连接用法是等价的 等值内连 上述那个例子就是最常见的等值内连 123SELECT ENAME, DNAMEFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 等值内连就是在where中书写多表的连接条件的时候比较两个表中某一个或多个字段的值，值相等的则匹配（常见的就是用一个表的外键与另一个表中对应的外键的参照键进行比较） 必须是两张表中能够满足连接条件的数据才会出现在结果集当中（不单是等值连接，下面讲的非等值连接也是，所有内连接都应该瞒住这个） 再来举个上面举过的栗子1234-- 下面的操作得到了所有员工的名字以及其所在部门的名字SELECT ENAME, DNAMEFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 我们发现员工名为Sunny的员工数据和部门号为40的部门数据都没有出现在结果集当中。因为Sunny的部门号为空值，不等于部门表中任意一行数据的部门号，故找不到匹配；因为在员工表中没有员工的部门号为40，所以部门号为40的部门也没有出现在结果集当中。（只有满足连接条件，并且成功找到匹配的数据才会出现杂结果集当中） 这种用where书写的多表连接语句等价于SQL标准中的内连接（inner join） 上面的语句也可以写成下面这种形式1234567891011-- 下面的语句和上面例子中的语句是等价的SELECT ENAME, DNAMEFROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO-- SQL标准中还有下面这种用法（课本上有提到，但是显然SQL Server不支持这种用法）-- 表示的是利用DEPNOT这个字段来进行两表的连接（前提是这两个表中要有同名字段）-- 如果支持这种用法的数据库执行下面操作的话得到的结果和上面的是一样的（经验证，MySQL数据库是支持这种用法的）SELECT ENAME, DNAMEFROM EMP INNER JOIN DEPT USING(DEPNOT) 对于两表中的同名字段，在使用的时候必须用表名或者表别名加以限定，不然SQL语句会有歧义，导致无法正确被解析 举个栗子1234567891011121314151617181920-- 我们想在上面例子的基础上，多显示一个部门号-- 如果写成下面这样，就会报错，因为SQL解析器不知道DEPTNO指的是EMP表的还是DEPT表的SELECT ENAME, DNAME, DEPNOTFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO;-- 正确的写法应该是这样的SELECT ENAME, DNAME, EMP.DEPTNOFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO;--当然也可以用DEPT来限定SELECT ENAME, DNAME, DEPT.DEPTNOFROM EMP, DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO;-- 不过最好用表别名来限定，比较简洁一点SELECT ENAME, DNAME, e.DEPTNOFROM EMP e, DEPT dWHERE EMP.DEPTNO = DEPT.DEPTNO; 如果对一个表起了别名之后就不能再使用原表名了，而要换成其别名 举个栗子1234-- 下面这个语句执行的话是要报大错滴，因为已经给EMP表起了别名e，就不能再用原表名EMP了SELECT ENAME, DNAME, EMP.DEPTNOFROM EMP e, DEPT dWHERE EMP.DEPTNO = DEPT.DEPTNO; 如果再考虑效率问题，在进行多表操作时，最好所有字段都用表名或者表别名限定，这样可以免去SQL解析器帮你分析某个字段属于哪个表的开销，可以在一定程度上提高执行效率 举个栗子123SELECT e.ENAME, d.DNAME, e.DEPTNOFROM EMP e, DEPT dWHERE EMP.DEPTNO = DEPT.DEPTNO; 不等值连接 举个栗子1234-- 下面的语句就查处了所有员工的姓名、工资、以及其工资等级SELECT e.ENAME, e.SAL, g.GRADEFROM EMP e, SALGRADE gWHERE e.SAL &gt;= g.LOSAL AND e.SAL &lt;= g.HISAL; 得到如下结果： 不等值连接就是内连接中除了通过比较值相同来进行连接以外的其他内连接操作 n个表相连，至少需要n-1个连接条件，要不然就会在连接过程中出现笛卡尔积 多表的连接条件一般都是建立在外键和外键的参照键之间，采用等值连接 SQL内连接的标准写法 JOIN … ON … 举个栗子123456-- 下面的语句就是SQL标准中多表内连接的写法SELECT *FROM TABLE1 t1 JOIN TABLE2 t2 ON ... JOIN TABLE3 t3 ON ... JOIN TABLE4 t4 ON ... 外连接内连接的结果是外连接结果的一个子集，外连接的结果中还可以包括只在一张表中出现，并且在另一张表种找不到匹配的结果 左外连接(LEFT OUTER JOIN) 包含JOIN关键字左表中的所有数据（即便某个数据在右表中找不到匹配） 举个栗子123456-- 下面的语句与上面的例子类似-- 同样是得到所有员工的名字以及其所在部门名-- 不同的是采用左外连接以后Suuny的数据会出现在结果集中了SELECT ENAME, DNAMEFROM EMP LEFT OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 右外连接(RIGHT OUTER JOIN) 包含JOIN关键字右表中的所有数据(即便某个数据在左表中找不到匹配 举个栗子12345-- 还是这个栗子，但不同的是我们把LEFT改成了RIGHT-- 会发现，部门号为40的部门信息显示出来了SELECT ENAME, DNAMEFROM EMP RIGHT OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 对比可以发现左外连接和右外连接的效用其实是一样的，只要吧JOIN两边表的位置对调一下，两者就可相互转换。（使用时随意，习惯怎么用就怎么用就好） 全外连接 JOIN关键字两边的表的所有数据都会出现在结果集当中，得到的结果其实就是左外连接和右外连接结果集的并集 举个栗子：123SELECT ENAME, DNAMEFROM EMP FULL OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO; 得到如下结果： 在进行多表连接的时候采用WHERE和ON的区别 其一，在进行外连接的时候，必须用ON 举个栗子 12345678910-- 下面的语句做了简单的外连接操作SELECT *FROM EMP LEFT OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO;-- 下面的语句执行是会报错的，因为没有加onSELECT *FROM EMP LEFT OUTER JOIN DEPTWHERE EMP.DEPTNO = DEPT.DEPTNO; 其二，如果在on子句中指定连接条件，并在where子句中出现其余条件，这样的SQL插叙通常更容易让人读懂 所以在执行内连接的时候，on和where的使用是没有多大区别的，但是在执行外连接的时候就必须用on了。所以建议就是在on子句中指定连接条件，并在where子句中出现其余条件]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（五）]]></title>
    <url>%2F2017%2F09%2F22%2F2017-09-22-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章(第三章部分的多表操作没有在此处讲，准备挪到第四章再一起讨论)笔者接下来的代码示例会主要在SQL Server数据库中测试 在开始今天的摸鱼大业之前，让我们先构造一组表，用于演示下面的例子(´`) Having 子句由于where子句中不能用聚合函数（组函数）做条件，故引入having子句 让我们先看一下各个子句的书写顺序（下面的只是我们一般在写SQL语句时候的书写顺序） SELECT FROM WHERE GROUP BY HAVING ORDER BY 上面各子句的执行顺序：FROM–&gt;WHERE– &gt; GROUP BY–&gt; HAVING–&gt;SELECT–&gt;ORDER BY 其中上面除了GROUP BY和HAVING可以互换位置外，其他位置均固定，但最好采用上面的顺序 从上面的讨论中可以看出 HAVING一般紧随GROUP BY之后，置于ORDER BY之前 而且当聚集函数（组函数）做条件时，只用用HAVING来处理 举个栗子：求所有平均工资大于2000的部门的部门号以及该部门的平均工资 先来看看每个部门的平均工资 123SELECT DEPTNO, avg(SAL) as avg_salFROM EMPGROUP BY DEPTNO 得到如下结果 接下来开始求题设的问题 1234SELECT DEPTNO, avg(SAL) as avg_salFROM EMPGROUP BY DEPTNOHAVING avg(SAL) &gt; 2000; 得到如下结果 聚合函数的嵌套 不同数据库对聚集函数嵌套的规定不同 Oracle数据库规定最多只能有两层嵌套 SQL Server不允许聚集函数嵌套 举个栗子： 1234567--下面的语句在Oracle数据库中执行是可以的SELECT max(avg(sal))FROM EMPGROUP BY deptno--上面的语句在SQL Server中执行会报下面的错[S0001][130] 不能对包含聚合或子查询的表达式执行聚合函数。 ┐(´•_•`)┌ 实际上二层以上的嵌套也是毫无意义的（只是瞎哔哔，不是什么重点，有助于理解为什么聚集函数多层嵌套是没有意义的） 首先回忆一下，聚集函数的操作是多行输入，得到一行输出 举个栗子 123SELECT max(max(avg(sal)))FROM EMPGROUP BY deptno 现在来分析上面语句执行的过程 （avg）首先根据部门号deptno分成若干组，并计算每组的平均工资（返回若干条记录） （max）然后取各部门最高的平均工资（返回一条记录） （max）这个时候只有一条记录，取最大值也还是那一条记录 子查询这部分是重点也是难点呀٩(๑`^´๑)۶，不用担心，让笔者带你细细解剖(≖_≖ )这部分参考了两份笔记和课本 嵌套子查询即SQL标准提供嵌套子查询机制，允许将一个完整的select-from-where查询表达式嵌入到另一个查询语句中 子查询嵌套在where和having子句中的情况（把子查询整体当做一组值，可以是0个，1个，或多个） 单行子查询 在单行子查询中，子查询语句只能返回一行数据 当where子句中用下列逻辑符号连接子查询时，便只能连接单行子查询 = &lt; > &lt;= >= &lt;&gt; 举个栗子(≖_≖ ) 我们现在要找所有员工中，拿到最高工资的人的名字以及工资1234SELECT ENAME, SALFROM EMPWHERE SAL = (SELECT max(SAL) FROM EMP); 得到如下结果 多行子查询 多行子查询中，子查询语句可以返回多行数据 当where子句中用下列关键字连接子查询时，便是多行子查询($代表上面提到的=, &gt;等符号) $ any/some $ all 举几个简单的栗子 &lt; any(…) 表示小于子查询结果集中的最大值 > any(…) 表示大于子查询结果集中的最小值 = any(…) 等价于in = all(…) 没有语法错误，但是只要子查询结果集的个数大于1，则整体的结果必然为空 &lt; all(…) 表示小于子查询结果集中的最小值 > all(…) 表示大于子查询结果集中的最大值 来举个正经的栗子 求比部门号为20的部门的所有员工的工资都要高的员工的名字和工资12345SELECT ENAME, SALFROM EMPWHERE SAL &gt; SOME (SELECT SAL FROM EMP WHERE DEPTNO = 10); 得到如下结果 还有一个要注意的问题(ㅍ_ㅍ)，就是子查询中SELECT后面的字段要根据主查询语句中的字段来确定（简单的说就是子查询语句前面，where后面，出现了什么字段，子查询语句的SELECT列表中理论上就应该出现这些字段） 举个栗子 12345678910111213--下面这个语句是匹配的SELECT ENAME, SALFROM EMPWHERE SAL &gt; SOME (SELECT SAL FROM EMP WHERE DEPTNO = 10);--下面这个语句就不匹配的--因为ENAM并没有出现在主查询语句中SELECT ENAME, SALFROM EMPWHERE SAL &gt; SOME (SELECT ENAME, SAL FROM EMP WHERE DEPTNO = 10); 其实换个角度想想，具体执行的时候是将where后面的字段与子查询语句的结果集进行比较，如果字段都不一样，就没有可比性了 对了，还有一个补充，not in + 子查询，如果子查询的结果集中包含NULL值，那整体的结果必为空。因为NULL值是不确定的值，谁也不能保证某个具体的值是否等于NULL。。。 子查询中存在性的判别可以用exists关键字 举个栗子就好1234567--下面的语句就查出了所有手底下管了人的经理的信息--其实这里已经用到了相关子查询，具体的下面将会讲到SELECT *FROM EMP as eWHERE exists(SELECT 1 FROM EMP WHERE EMP.MGR = e.EMPNO); 试思考下面两个问题，根据提示理解一下，也可以实际操作验证一下 =some 等价于 in， 然而 &lt;&gt;some不等价于not in（&lt;&gt;some表示的是只要不等于结果集中的任意元素即可，可想而知，只要结果集中有大于一个元素，这个条件是恒成立的） &lt;&gt;all 等价于 not in，然而=all不等价于in 相关子查询 慎用，因为一旦使用相关子查询，子查询语句可能会被执行很多次，很影响效率 举个栗子 123456789--下面的语句找出了所有比自己部门平均工资高的员工的信息--检索时，每检索一行数据，子查询语句就要被执行一次--（因为该子查询语句只有在某个具体的部门号下才会有结果--而，要获取部门号，就必须依赖于主查询语句中的某行具体数据）SELECT ENAME, SAL, DEPTNOFROM EMP eWHERE SAL &gt; (SELECT avg(EMP.SAL) FROM EMP WHERE e.DEPTNO = EMP.DEPTNO); 举个上面举过的栗子 1234567--下面的语句就查出了所有手底下管了人的经理的信息--用exists时，只要找到数据即会返回，不会继续向下检索SELECT *FROM EMP as eWHERE exists(SELECT 1 FROM EMP WHERE EMP.MGR = e.EMPNO); 由于exists会在找到数据后立即返回，而不是继续向下检索，所以用exists的相关子查询效率会稍微高一丢丢 可以自己验证一下下面结论 not exists 不受空值的影响 not in 受空值的影响]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（四）]]></title>
    <url>%2F2017%2F09%2F19%2F2017-09-19-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章(第三章部分的多表操作没有在此处讲，准备挪到第四章再一起讨论)下面的例子中的测试都是在MySQL数据库中测试的 集合运算此处集合运算的概念与数学中集合的概念类似，可以借助文氏图加深理解。故此处对并运算进行展开，其他啊两个自己类比，后面还会对集合运算的几个注意点进提醒。 union(集合并运算) union 默认去除重复，并升序排序（因为涉及到排序，故而会有效率上的劣势） union all 就可保留重复项，并且保留原序（不进行排序） 举个栗子（现有两张表如下） |stu_name |age | score ||:——-:|:—:| :—–:||Sunny| 18| 98||Robbin| 18 |96||James| 19| 67||Jane| 17| 82|Student表信息如上 |tech_name |age ||:——-:|:—:||James |32||Marry |33||Lory |33|Teacher表的信息如上 执行以下运算 12345SELECT ageFROM StudentUNIONSELECT ageFROM Teacher 得到如下结果(得到的结果没有重复元素，但是没有排序，说明MySQL数据库在此处没有对其进行排序输出，但是Oracle数据库是会对数据进行升序排序的) |age ||:——-:||18||19||17||32||33| 执行以下运算 12345SELECT ageFROM StudentUNION ALLSELECT ageFROM Teacher 得到如下结果(可以知道，UNION ALL 保留了重复元素) |age ||:——-:||18||18||19||17||32||33||33| intersect(集合交运算) except(集合差运算) Note: 参与集合运算的两个视图的列数要一致 举个栗子1234567-- 下面的语句执行就会出错-- 因为第一个视图有两个字段，而第二个视图只有一个字段，无法进行集合运算SELECT age, scoreFROM StudentUNION ALLSELECT ageFROM Teacher 参与集合运算的两个视图对应位置的字段的数据类型应该是一致的（数据类型兼容即可，字段名无需一致） 举个栗子 1234567-- 按上面的说法下面语句执行是非法的-- 因为第二个字段的数据类型不兼容，一个是浮点型，一个是字符串类型SELECT age, scoreFROM StudentUNION ALLSELECT age, tech_nameFROM Teacher 上面的书法在Oracle数据库里得到了证实，确实执行是会报错的，那MySQL数据库呢？我们执行以下，得到以下结果 |age |score ||:——-:|:—:||18 |98||18 |||19 |67||17 |82||32 |James||33 |Marry||33 |Lory|说明该写法在Mysql里面竟然是合法的（所以所有的特性都要视不同的数据库，视情况而分析） 若无字段可加，又需保证列数相同，可控NULL做填充 举个栗子 12345SELECT age, scoreFROM StudentUNION ALLSELECT age, NULLFROM Teacher 得到如下结果哦 |age |score ||:——-:|:—:||18 |98||18 |||19 |67||17 |82||32 |||33 |||33 || 集合运算的结果视图的字段名以第一个结果集的字段名为主 举个栗子 12345SELECT stu_nameFROM StudentUNIONSELECT tech_nameFROM Teacher 得到如下结果： |stu_name ||:——-:||Sunny||Robbin||Marry||Lory||Jane||James| Oracle数据库中，差运算不是except， 而是minus；Oracle数据库union可以后面跟all， 但是interscet和minus后面不可以（不同数据库不同） 空值NULL NULL就是不确定的值，参与数值运算和字符串运算时，不同的数据库采取的处理不同； Oracle 数据库中，NULL无论参与数值运算还是字符串运算，都会使整体为NULL 获取系统时间 Oracle数据库的查询语句必须有from 故采用如下方法获取系统时间 1234-- 其中dual是Oracle数据库系统自带的一行一列的表-- 其他数据库没有这个表SELECT SYSDATEFROM dual MySQL就没有这个限制 12-- 在MySQL和SQL Server中用下面的语句就可获得系统时间SELECT SYSDATE 日期类型的运算 可与数值类型做加减运算（在Oracle数据库里面单位为天，·.·在MySQL里面竟然是秒） 举个栗子（MySQL里面测试） 1SELECT SYSDATE() - 1, SYSDATE(), SYSDATE() + 1 得到如下结果 |’SYSDATE() - 1’ |’SYSDATE()’ | ‘SYSDATE() + 1’ ||:——-:|:—:| :—–:||20170919183000 |2017-09-19 18:30:01| 20170919183002| 可与日期类型做减运算，得到连个日期之前的差值 不可与日期类型做加运算（在Oracle数据库执行日期间加运算直接报错，Mysql数据库直接真的返回两个日期加以后的值，不过巨耗时，mmp） 与NULL值运算得NULL值（在Oracle和MySQL上测试结果都正确） where 子句，判断是否为空 用is NULL 和 is not NULL 判断 而不用 = NULL 和 != NULL 布尔变量有三个取值：TRUE，FALSE, NULL 三种取值以and，or相连时的结果，与并联串联电路的判断类 TRUE and NULL = NULL TRUE OR NULL = TRUE FALSE and NULL = FALSE FALSE OR NULL = NULL 举个栗子12345-- 下面的语句将会返回Student表中的所有信息-- 因为where子句后面的条件为真SELECT *FROM StudentWHERE TRUE OR NULL 去重关键字 distinct 跟在SELECT的后面，并且置于所有字段的前面 会将其后的字段都作为判断重复的条件 举个栗子123-- 下面的语句就是列出学生表中的数据，并去除stu_name和age都相同的数据重复SELECT DISTINCT stu_name, ageFROM Student 聚集函数（Aggregate Functions）多行输入，一行输出 此类函数有MIN，MAX，COUNT，AVG，SUM。其中AVG和SUM只能参与数值运算 聚集函数在使用时会忽略空值NULL 除了COUNT(*)，COUNT(*)在统计的时候是不忽略空值的 Count 在计数时，忽略空值项 默认是统计重复项的，其中ALL是默认的，顾可以不显示指明 1COUNT(ALL age) 如果统计去除重复以后的结果,可如下面写法 1COUNT(DISTINCT age) Oracle中用作对null值数据处理的函数nvl 123# 下面的语句表示对数据表中的分数做加和，如果遇到为空的项，则取其值为0SELECT SUM(NVL(score, 0))FROM Student COUNT(*)==&gt;可返回满足where子句条件的所有数据的数量 这是COUNT独有的用法，其他聚集函数里面只能放字段或表达式 SUM SUM(age) + SUM(score) &gt;= SUM(age + score) 因为聚集函数在使用时会忽略空值，而NULL值直接参与运算可能会导致整体为空，顾有上述结论 当且仅当数据中没有空值时，上述等号成立 分组聚集（Aggregation） GROUP BY 字段序列 GROUP BY 后面跟的字段序列作为分组条件，值相同的为一组 可以是多个字段（顺序不影响结果） 当SELECT列表中出现了聚集函数，select中能出现以下字段 可以放group by 后面的字段 可以放聚集函数处理了的字段或表达式 上面两种情况下的字段在每组的取值都是唯一的，故而可以保证结果集中每一项的行数是一致的 having， 解决where子句中不能包含聚集函数的问题 传送门]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（三）]]></title>
    <url>%2F2017%2F09%2F16%2F2017-09-16-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章(第三章部分的多表操作没有在此处讲，准备挪到第四章再一起讨论) SELECT * 与 SELECT 全字段 的执 行效率是有差别的 数据库在具体执行 SELECT * 的时候可以这样理解：首先把 * 替换成对应表的全字段序列，再执行。故在执行的的时候 SELECT * 的效率是会更低的 事实上 SELECT * 也是典型的低效语句 故在实际应用过程中应该尽量避免使用 SELECT * where子句 and、or、not的优先级顺序 or &lt; and &lt; not (not的优先级最高) 例如：我们要实现“年龄小于16或大于18，并且分数不小于60的所有学生” 于是写出了 123where age &gt; 18or age &lt; 16and not score &lt; 60 上面的语句实际表示的是: 分数不小于60并且年龄小于16，或者年龄大于18 实际使用的时候不要依赖于它们的优先级顺序！！ 上面的需求可用下面的语句实现：12where (age &gt; 18 or age &lt; 16)and score &gt;= 60 SQL 附加的基本运算 更名运算 as |stu_name |age | score ||:——-:|:—:| :—–:||stu1 | 18| 98|首先存在如上表结构 需要事先申明的是，这里所说的更名并不是实际更改数据库中的表结构，更改只是在执行查询操作的过程中得到的结果视图 as 关键字可用于SELECT语句中给字段更名 执行如下语句： 12SELECT stu_name as student_name, age, scoreFROM Student 得到如下结果 |student_name |age | score ||:——-:|:—:| :—–:||stu1 | 18| 98| as 关键字可用于FROM语句中给表更名 as可以把一个长的关系名替换成短的，这样在查询语句的其他地方用到这个关系名的时候就会方便不少 执行如下语句 1234567-- 下面两个语句实现的效果是一样的,但是显然第二种比较简洁SELECT Student.stu_name, Student.ageFROM StudentSELECT S.stu_name, S.ageFROM Student as S 还有一种情况需要用as修改表名，就是需要比较同一个关系中的元组的时候，必须要用别名，要不然无法区分 |stu_name |age | score ||:——-:|:—:| :—–:||Sunny| 18| 98||Robbin| 18 |96||James| 19| 67||Jane| 17| 82|现在表中有如上数据 我们需要查询表中所有比Jane的成绩高的学生的名字 则可以用下面的语句实现： 123SELECT T.stu_nameFROM Student as T, Student as SWHERE T.score &gt; S.score and S.stu_name = 'Jane' 得到以下结果 |stu_name ||:——-:||Sunny||Robbin| 大多数数据库中可以用空格替代as 12345678-- 下面两个语句是等价的（在Mysql数据库上测试）SELECT T.stu_nameFROM Student as T, Student as SWHERE T.score &gt; S.score and S.stu_name = 'Jane'SELECT T.stu_nameFROM Student T, Student SWHERE T.score &gt; S.score and S.stu_name = 'Jane' 注意：Oracle数据库更改表的别名不能用 as（但是改字段的别名是可以用as的）， 只能用空格，要不然会报错（比如上面的两个语句在大多数数据库执行都是可以通过而且结果一致的，但是在Oracle数据库第一条语句就不会过）** 如果别名中带空格，则别名需要用双引号引起来（因为空格也是可以替代as的，所以如果别名中含有空格而不做处理，可能会导致数据库无法解析这条语句） 首先看下面这条语句 123-- 下面这条语句想给Student表起一个别名，叫做 Student Info, 执行是会失败的SELECT Student Info.stu_nameFROM Student as Student Info 正确的操作应该是这样的 12SELECT "Student Info".stu_nameFROM Student as "Student Info" 字符串的拼接运算 不用数据库采用不同的运算符，常见的有 || 和 + |stu_name |age | score ||:——-:|:—:| :—–:||Sunny| 18| 98||Robbin| 18 |96||James| 19| 67||Jane| 17| 82|现在表中有如上数据 执行下面的语句(笔者是在Mysql下测试的，Mysql的字符串拼接是用connect函数实现的，所以略有不同) 12SELECT S.stu_name, concat('name: ', S.stu_name) as infoFROM Student as S 得到如下结果 |stu_name | info||:——-:|:—:||Sunny |name: Sunny||Robbin| name: Robbin||James |name: James||Jane |name: Jane| 对于null值的处理，不同的数据库采取的处理不同 Oracle会直接忽略空值，而DB2会使整体为null 下面在Mysql中测试与空值拼接，结果是会使整体为null 执行以下语句 12SELECT S.stu_name, concat('name: ', S.stu_name, NULL ) as infoFROM Student as S 结果如下 |stu_name | info||:——-:|:—:||Sunny |null||Robbin| null||James |null||Jane |null| 可以与字符串常量拼接 sql里面就用一对单引号包含一个字符串表示字符串常量，如’name: ‘ 上面的例子里面就用到了与字符串常量拼接，这里就不再赘述了 如果字符串常量里面需要包含单引号，可以用另一个单引号来转义 比如执行下面的语句 123# 下面的字符串常量中出现了四个单引号，其中首位两个是用来标示这个是一个字符串常量，第二个单引号是用来转义第三个单引号SELECT S.stu_name, concat('I''m ', S.stu_name) as infoFROM Student as S 结果如下： |stu_name | info||:——-:|:—:||Sunny |I’m Sunny||Robbin| I’m Robbin||James |I’m James||Jane |I’m Jane| 函数 其实函数每个数据库都有各自的实现，种类和功能不尽相同 比如上面的connect函数是Mysql中的一个函数 upper(s)和lower（s）函数是用来将字符串全部变成大写/小写的函数 模糊匹配（like） 通配符（具体到某个具体的数据库可能还会有功能更强大的通配符，这里只讨论比较通用的两个） % ==&gt;匹配任意长度的字符串（字符串的长度也可以是0） _ ==&gt;匹配一个字符 举个栗子：12345-- 下面的语句标示查询条件是第三个字符是A的stu_nameWHERE stu_name LIKE '__A%'-- 下面的语句标示查询条件是第三个字符是A，且长度至少为4的stu_nameWHERE stu_name LIKE '__A_%' |stu_name |age | score ||:——-:|:—:| :—–:||Sunny| 18| 98||Robbin| 18 |96||James| 19| 67||Jane| 17| 82|现在表中还是有如上数据 执行下面操作 1234-- 下面的语句用来查询表中stu_name的值为Ja开头，且至少长度为三的所有学生名字SELECT stu_nameFROM StudentWHERE stu_name LIKE 'Ja_%' 得到如下结果 |stu_name ||:——-:||James||Jane| 如果模式串（我们这里称like后面的串为模式串）中需要包含‘_’或者‘%’等通配符关键字，就需要用到转义，SQL里面用escape来指定转义字符 举个栗子：123-- 下面的语句在最后面定义‘\’为转义字符-- 所以实际的效果是匹配所有以 Ja_ 开头的 stu_nameWHERE stu_name LIKE 'Ja\_%' escape '\' 排序（order by） 如果没有显示指定升序还是降序，则默认是采用升序的 null 值的处理（不同的数据库采取的处理不同） Oracle 将null值当做最大 SQL Server 将null值当做最小 接下来来去测测Mysql数据库 |stu_name |age | score ||:——-:|:—:| :—–:||Sunny| 18| 98||Robbin| 18 |||James| 19| 67||Jane| 17| 82|首先表中的数据是上面酱紫的 然后执行下面操作 12345-- 下面的语句查询学生表中的所有数据，并按成绩排序（因为没有指定-- 升序还是降序，所以默认是升序的）SELECT *FROM StudentORDER BY score; 结果如下（可以看出，Mysql是将null值当做最小值） |stu_name |age | score ||:——-:|:—:| :—–:||Robbin| 18 |||James| 19| 67||Jane| 17| 82||Sunny| 18| 98| 在排序的时候可以用desc显示指定降序，asc显示指定升序 举个栗子 12-- 下面的排序条件标示先按score降序排序，如果遇到score相同的，则按age升序排序ORDER BY score desc, age asc order by 后面所跟字段，以在前面的字段为主进行排序 desc、asc 更在字段名或表达式后面，并且只能影响其前面的一个字段 举个栗子123-- 下面的排序条件表示，先以score进行升序排序（因为未指定的话默认是升序的），-- 如果遇到score相同的再按age进行降序排序order by score, age desc order by 后面可跟别名，字段名，表达式，字段的顺序号 别名、字段名 表达式 举个栗子12-- 下面排序条件标示把sal*12后按结果降序排序order by 12 * sal desc 字段的顺序号： 举个栗子1234-- 下面这条语句标示查询Sudent表中的所有数据，并按age和score进行升序排序（默认是升序排序）SELECT student_name, age, scoreFROM StudentORDER BY 2, 3 如果要查询的结果集是很大的，排序是很耗时的，会影响性能 where子句beween…and、in between…and（表示一个连续的范围） between a and b &lt;==&gt; a &lt;= x &lt;= b not between a and b &lt;==&gt; x &gt; b | x &lt; a 写的时候，小数写在前面，大数写在后面 in（表示离散的范围） 举个栗子1234# 下面的语句表示查询分数为98、99或者100的学生的信息SELECT student_name, age, scoreFROM Studentwhere score in (98, 99, 100)]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java环境简单配置+IDEA（小白版）]]></title>
    <url>%2F2017%2F09%2F16%2F2017-09-16-Java%E7%8E%AF%E5%A2%83%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2BIDEA%EF%BC%88%E5%B0%8F%E7%99%BD%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JDK配置 首先到官网下载最新版JDK：Oracle官网下载 Accept License Agreement–&gt;下载适合自己pc版本的jdk（此处以64位windows为例。x86是32位，x64是64位） 开始安装JDK 选择安装路径，可以不安装在C盘，记住安装到哪就行了，默认也行，我安装在（C:\Program Files\Java\jdk1.8.0_131） 安装过程中会跳出Jre的安装界面，你可以放到和之前JDK在同一个文件夹下，也可默认。然后直接下一步开始安装 环境变量配置 右击我的电脑–&gt;属性–&gt;高级系统设置–&gt;环境变量 新建环境变量，变量名为：JAVA_HOME，变量值为之前JDK的安装路径，此处安装在：C:\Program Files\Java\jdk1.8.0_131（可以在系统变量下新建，这样可以为每个登录该pc的用户都配置，如果在用户变量中新建，则只为当前用户配置，此处以在系统变量下新建为例） 找到Path变量–&gt;编辑 如果是win10系统，则进入后界面如下，选择新建两个环境变量，一个值为：%JAVA_HOME%\bin另一个为：%JAVA_HOME%\jre\bin（此处笔者已经配置好）配置好就如下图 如果是win7及之前的系统则进入后界面如下:在变量值最后输入 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;（注意原来Path的变量值末尾有没有;号，如果没有，先输入；号再输入上面的代码） 验证一下^-^ win + R–&gt;输入cmd，进入cmd命令行 输入：java -version 就可以查看版本信息，如果显示如下信息，则表示环境配置成功 到这里我们就可以骚操作一波，用记事本写简单Java程序（纯属骚操作，如果用IDE开发（比如我们接下来的部分要介绍的重头戏，用IDEA实现真正的骚操作）可不看这个hhhhhh，如果不想使用IDE开发的话，建议可以使用NotePad++、sublimeText或Atom进行代码编辑，不过真想用记事本敲也无可厚非） 新建一个文本文档，并修改后缀为.java修改以后如下：如果没有显示后缀名，则可通过如下方式修改： 用记事本打开，输入以下代码：12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;Oh, balabala&quot;); &#125;&#125; 直接在创建文件的文件夹下按住Shift + 右键，选择在此处打开命令窗口（环境变量的配置使得用户可以在任意目录下调用javac 和java 命令）输入：javac Hello.java （用于编译java源程序）java Hello（运行java程序） 自此JDK的配置就OK了，可以开始Java从入门到放弃的修炼了~~ 极其好用的IDE–&gt;IDEAps:如果在打开IDEA之前没有下载好JDK的道友，请先往上看详细步骤 先来一波官网的下载链接：IDEA官网下载地址我们下载社区版（别问为啥，社区版免费，如果下载左边的旗舰版也行，但是需要注册码，之前有个网上长期流传的获取注册码的路子，现在貌似不好用了，如果道友是学生就可以用学校给的邮箱百度“IDEA学生”去注册一个IDEA的学生账号（学生账号有自己的注册码，有效期为1年），如果不是就买或者用社区版吧）： 第二步我们来开始安装： 选择安装路径： 上面的是创建桌面图标，选择自己电脑对应的版本就行了；下面的可以全选，表示什么格式的文件可直接关联到IDEA，用IDEA来打开 下一步直接install 启动刚安装好的IDEA 如果第一次安装，就直接不导入设置，ok 选个喜欢的主题（此处笔者选这骚气黑），然后next 直接next 直接start 接下来新建一个项目练练手 create a project 如果显示NO SDK， 找到之前安装的JDK所在路径，然后next next 第二行选择项目的存放路径，第一行给项目取个名字，然后Finish 右击src文件夹–&gt;new–&gt;java class 给类取个名字，ok 输入以下代码：12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;Oh, balabala&quot;); &#125;&#125; 运行程序：运行成功，开始你的表演：]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（一）]]></title>
    <url>%2F2017%2F09%2F12%2F2017-09-12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL教程 DBS（Database System） 传统的文件处理系统中存储组织信息的主要弊端 数据的冗余和不一致性（data redundancy and inconsistency） 数据访问困难（dificulty in accessing data） 数据孤立（data isolation） 完整性问题（integrity problem） 原子性问题（atomicity problem） 并发访问异常（concurrent-access anomaly） 安全性问题（security problem） 数据库系统的目标：提供一种可以方便高效地存取数据库信息的途径 数据视图数据库系统的一个主要目的是给用户提供数据的抽象视图，也就是说隐藏关于数据存储和维护的某些细节 数据抽象 物理层（physical level） 最低层次的抽象 描述了数据实际上是怎么存的（比如是都存在一个文件里还是分散在多个文件里） 逻辑层（logical level） 比物理层层次稍高的抽象 描述了数据库中存什么数据以及数据之间的关系 逻辑层的用户不需要去关系数据具体是怎么存的，这称作物理数据独立性（physical data independence） ps: 对于具有物理数据独立性的设计，即便底层的物理存储改变了，逻辑层也不需要做任何的修改 视图层（view level） 最高层次的抽象，只描述整个数据库的某个部分 简而言之，对于逻辑层的数据，我们可以通过不同的视图，以不同的视角以及视野去查看它 实例和模式 类比：模式类比于变量的声明，实例类比于变量在特定时刻的值 模式： 数据库的总体设计 数据库的模式限定了数据库中都有哪些表，表中都有哪些字段以及表与表之间的关系 实例： 特定时刻存储在数据库中的信息的集合 数据库的一个实例包含了数据库在一个时刻下的所有表的信息 数据模型 关系模型 实体—联系模型 基于对象的数据模型 半结构化的模型 网状数据模型 层次数据模型 关系型数据库的一些基本术语 relation（关系）==&gt;表 column（列）==&gt;字段（同一字段内所有数据的数据类型一致） row（行）==&gt;对应于数据库表中的一行数据（对应于数学概念中的元组） SQL（Structured Query Language）==&gt;结构化的查询语言 DDL：Data Define Language（数据定义语言）==&gt;执行 该类SQL语句会导致表结构的变化 DML：Data Manager Language（数据操纵（管理）语言）==&gt;执行该类SQL语句对表中的数据进行增删改查 tuple（元组）==&gt;对应于数据表中的一行数据 domain（域）==&gt;字段的取值范围 schema（方案/模式）==&gt;数据库中的Schema，为数据库对象的集合，一个用户一般对应一个schema Cartesian product（笛卡儿积） 百度百科对笛卡尔积的解释 一篇介绍笛卡儿积与数据库关联的博客 ps: 应当避免表与表之间相关联的时候采用全匹配（如果采用笛卡尔积的匹配方式即为全匹配） DDL （数据定义语言）数据库模式定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。一个数据库模式包含该数据库中所有实体的描述定义。 执行此类语句会导致数据库结构的变化 create（创建一个表） 1234567-- 下面的语句创建了一个用户表，以id为主键，并添加了username和age字段CREATE TABLE User( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) DEFAULT "", age INT DEFAULT 18);CREATE UNIQUE INDEX User_id_uindex ON User (id); alter（修改表的结构） 12-- 下面的语句修改了user表的id属性ALTER TABLE user MODIFY id INT(11) unsigned NOT NULL AUTO_INCREMENT; drop（删除一张表） 12-- 下面的语句删除了为user表DROP TABLE demo.user; rename（用于对一张表的名字进行重命名） Oracle数据库将其划分到DDL SQL server数据库将其归到DML12-- 下面的语句将user表的表名改成new_userrename table user to new_user truncate（截断==&gt;用于删除数据表中的所有数据，但是保留表结构，不同公司的数据库实现的机制不同） DML数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令，因此有很多开发人员都把加上SQL的SELECT语句的四大指令以“CRUD”来称呼。 此类语句对数据进行增删改查（CRUD） insert 12-- 下面的语句往user用户表中插入一条记录INSERT into user(username, age) VALUES('Robbin', 18) update 12-- 下面的语句修改了user表中username为Robbin的表项（元组）的数据UPDATE user SET username = 'Robbin2', age = 17 WHERE username = 'Robbin' delete 12-- 下面的语句删除user表中username为Robbin2的表项（元组）DROP FROM user WHERE username = 'Robbin2' select DB2将select归到DML Oracle将select单独划为一类（因为select操作只是对数据库进行查询操作，没有实质改变数据库中的数据）12-- 下面的语句查询user表中的所有数据SELECT * FROM user DML和DDL的区别 DML语句支持回滚，采用事务，可以保证数据的一致性；而DDL语句采用隐式commit，是不支持回滚的（一旦执行就不可撤回） 四种SQL语句 Key（键/码） superkey（超码）==&gt;一个或多个字段的集合，可唯一标识一行数据 candidate keys（候选码）==&gt;最小的超码（即本集合为超码，且集合内除本身外的任何子集都不能作为超码） Primary key（主码/主键）==&gt;从候选码中选取一个作为主码（主键），可以由多个字段组成 Primary attribute（主属性）==&gt;包含于某个候选码的属性 Non-Prime attribute（非主属性）==&gt;不包含于某个候选码的属性 Note: 数据表中字段的个数是有限的 属性在元组中是无序的（但是设计的时候一般把主键放在前面） 设计字段的时候要保证字段的原子性 NULL==&gt;空值表示不确定的值，不代表0，也不代表空串]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库笔记（二）]]></title>
    <url>%2F2017%2F09%2F12%2F2017-09-12-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面：本篇博客大部分内容参考数据库系统概念（本科教学版）第三章 SQL的组成PS：其中DDL、DML、integrity有一些补充，剩下的几项都是课本内容，应该后面会讲到。现在就先放在那边吧 数据定义语言（Data-Definition Language， DDL） 提供定义关系模式，删除关系以及修改关系模式的命令 如create、drop、alter等执行以后会产生、销毁表（定义、删除关系模式）或改变表的结构（修改关系模式） 数据操纵语言（Data-Manipulation Language，DML） SQL DML提供从数据库中查询信息，以及在数据库中插入元组、删除元组、修改元组的能力 只是对表中数据的增删改查，并没有实际影响表的结构（即关系并没有改变，只是该表关系的实例） 完整性约束（integrity） SQL DDL 会给每一个关系（每一张表）在定义或者修改的时候定义一定的完整性约束。之后所有的操作都应该满足这些约束，不满足的操作将不被允许执行 复习注释: 不过如果对违反约束的行为做了处理，有些违反约束的语句也是可以成功执行的。比如在定义外键的时候指定了级联删除，那么一旦删除语句违反了外键约束，数据库不是拒绝执行，而是级联删除相关数据 比如主键约束表示一个或多个字段唯一标识了一行数据，如果试图插入主键值相同的数据，就不会被允许 具体的下面会单独说明并举例 视图定义（view definition） SQL DDL 包括定义视图的命令 事务控制（transaction control） SQL包括定义事务的开始和结束的命令 嵌入式SQL和动态SQL（embedded SQL） 嵌入式和动态SQL定义SQL语句如何嵌入到通用编程语言，如C、C++、Java 授权 SQL DDL包括定义对关系和视图的访问权限的命令 基本类型这些基本数据类型不依赖于某一个具体的数据库，是SQL数据库通用的类型 char(n)——全称character 用户指定长度的字符串，所有取值的长度都固定位n长的char 比如身份证或者电话号码等长度固定的数据可以使用这个 一般实际用的较少 varchar(n)——全称character varying 可变长的字符串，n为串的最大允许长度 实际存的时候数据多长，就存多长，较省空间 实际应用中大多用varchar，而不是char int——integer 整数类型，没啥好讲的，Oj8k smallint 小整数类型 number(p, d) 定点数，这个数有p位数字，其中小数点右边有d位 例如，numberic(3, 1)可表示-99.9 ~ 99.9 下面在MySQL数据库上面的测试，举个栗子：(测试结果表明，如果定义numberic(3, 1), 则小数点前面有三位数时是无法插入的，如果小数点后面有多位小数，则通过四舍五入的方法只保留一位小数) 先简单定义一张Student表（没有定义主键，允许插入相同的数据） 123456-- 下面定义了一张学生表，其中grade的取值范围为-99.9 ~ 99.9（不合理的取值，只是为了测试）CREATE TABLE Student ( study_id VARCHAR(20) NOT NULL, age INTEGER DEFAULT 0, grade NUMERIC(3, 1)); 执行正常的插入操作 12345678910111213141516171819202122232425-- 下面两条插入语句都能正常执行，并且结果正确INSERT INTO Student(study_id, age, grade) VALUES ( '201590001', 18, 92.5)INSERT INTO Student(study_id, age, grade) VALUES ( '201590002', 18, -92.5)-- 执行下面一条插入操作，最后保存的记录是 -92.6，INSERT INTO Student(study_id, age, grade) VALUES ( '201590003', 18, -92.56)-- 执行下面一条插入操作，最后保存的记录是 -92.5，INSERT INTO Student(study_id, age, grade) VALUES ( '201590004', 18, -92.54)-- 下面的这条插入操作将会报错-- [22001][1264] Data truncation: Out of range value for column 'grade' at row 1INSERT INTO Student(study_id, age, grade) VALUES ( '201590005', 18, 192.5) 执行上面操作后的结果 study_id age grade 201590001 18 92.5 201590002 18 -92.5 201590003 18 -92.6 201590004 18 -92.5 real,double,precision 浮点数与双精度浮点数 float(n) 精度至少为n位的浮点数 Date, time, timestamp, interval 日期类型 SQL中的完整性约束下文中列举的只是部分简单约束，具体的会在后面的内容中讨论 先来简单聊一聊我对完整性约束的理解吧，其实数据库中的完整性约束讲起来就是数据库在定义一张表的时候，对其作出了一系列的约束 （这些个约束可能影响一个或多个字段，甚至影响整个表结构）。如果后续的操作中（不管是DDL还是很DML），如果违背了之前定义的 约束，（***如果没有对违反约束行为做特殊的处理***）这个操作就不会成功 primary key（A1, A2, …, An）——主键约束 该约束主要指定了以属性A1~An构成关系的主键，该主键值必须非空且唯一 即只要一个表的主键确定，那这个表中就不允许存在一行数据其主键的值为null， 也不允许存在两行数据其主键的值一样。一旦后续操作违反了这个原则（约束），则该操作就不会被执行 举个栗子： 新定义一张department表 1234567-- 下面的操作创建了一张department表，并指定dept_name为主键CREATE TABLE department ( dept_name VARCHAR(20), building VARCHAR(15), budget NUMERIC(12, 2), PRIMARY KEY (dept_name)); 下面顺序执行一系列插入操作 1234567891011121314-- 下面的操作将成功插入一条记录INSERT INTO department (dept_name, building, budget)VALUES ('Software', 'A', 100000);-- 下面再执行一次与上面一模一样的操作，会发现报错，因为之前已经有一条-- 记录的主键值为'Software'，顾无法再插入主键值相同的数据-- [23000][1062] Duplicate entry 'Software' for key 'PRIMARY'INSERT INTO department (dept_name, building, budget)VALUES ('Software', 'A', 100000);-- 下面的语句试图插入一条dept_name为空的数据，显然也是报错的-- 因为作为主键的字段是不允许为空的-- [23000][1048] Column 'dept_name' cannot be nullINSERT INTO department (dept_name, building, budget) VALUES (NULL , 'A', 100000); 执行上面操作后的结果 dept_name building budget Software A 100000 foregin key(A1, A2, …, An) references —— 外键约束 简单来讲如果一个关系（表）A中包含一个外键C，则作为外键的一个或多个字段必然是另一张表B的主键。则由于外键约束这一层关系，对A表和B表都会收一定程度的限制（现在解释的还是比较抽象，看下面的例子会比较直观一点） 如果想向A表中插入一条数据，且数据中C的值在B表中找不到对应表项，则这个操作不会成功（就像你如果向运动员表中插入一条数据，国家属性对应的标识在国家表中不存在，则这次插入操作就会失败） 如果试图删除一个表B的记录，而这条记录的主键只正好是A表中某条数据的外键，则这次删除操作不会成功 举个栗子： 先创建两张表 1234567891011121314151617-- 创建一张表department，并制定dept_name为主键CREATE TABLE department ( dept_name VARCHAR(20), building VARCHAR(15), budget NUMERIC(12, 2), PRIMARY KEY (dept_name));-- 再创建一张couese表，并指定dept_name为本表关于department表的外键CREATE TABLE course ( course_id VARCHAR(7) NOT NULL, title VARCHAR(50), dept_name VARCHAR(20), credits NUMERIC(2, 0), PRIMARY KEY (course_id), FOREIGN KEY (dept_name) REFERENCES department (dept_name)); 我们先试图插入一条course记录 1234-- 下面试图往course表中插入一条记录，但是department表中并没有-- dept_name = 'DUT'的记录，故该操作会失败INSERT INTO course (course_id, title, dept_name, credits)VALUES ('08', 'English', 'DUT', 3) 我们先往department表中插入记录，再往course表中插入记录，下面的操作就能成功插入 12345INSERT INTO department (dept_name, building, budget) VALUES ('DUT' , 'A', 100000);INSERT INTO course (course_id, title, dept_name, credits)VALUES ('08', 'English', 'DUT', 3) 执行上面操作后的结果 |dept_name |building | budget ||:——-:|:—:| :—–:||DUT|A|100000| |course_id |title | dept_name |credits||:——-:|:—:| :—–:| :—-:||08|Endlish|DUT|3 此时我们如果试图删除department表中dept_name = DUT的那条数据 123-- 执行下面的操作就会报错，因为course表中还有一项数据的dept_name的值为DUT，如果删除掉department中的这条数据，就会破坏其完整性，顾执行失败-- 23000][1451] Cannot delete or update a parent row: a foreign key constraint fails (`db_study`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`dept_name`) REFERENCES `department` (`dept_name`))DELETE FROM department WHERE dept_name = 'DUT'; 同样的如果，我们试图删除department表，则只要course表中还有数据，这个操作就会失败 not null——非空约束 理解上面两个约束以后这个就很好理解了，这个约束就是指定某个字段不能为空，试图传入null值的操作都不会成功 作为主键的字段隐式拥有非空约束]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
